{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Stateforward is a comprehensive library designed to facilitate the creation and management of state machines and domain models across multiple programming languages, including Python, JavaScript, and Rust. With its modular architecture and extensive feature set, Stateforward aims to become the go-to solution for developers looking to implement complex stateful systems with ease and precision. Currently available for Python, the library plans to expand its offerings with robust Rust and JavaScript packages in the near future.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Intuitive Modeling: Define complex hierarchies, relationships, and behaviors using simple, declarative syntax.</li> <li>Cross-Platform Support: Unified API across Python, JavaScript, and Rust, enabling consistent development experiences.</li> <li>Asynchronous Support: First-class support for asynchronous operations in Python, making it suitable for IO-bound tasks.</li> <li>Concurrency Control: Easily manage concurrency with support for sequential, threaded, multiprocessing, and asynchronous execution.</li> <li>Event Handling: Robust event system that responds to a variety of event types, from time-based to custom triggers.</li> <li>Behavioral Abstraction: Encapsulate state-specific behaviors within states, transitions, and actions.</li> <li>Domain-Specific Modeling: Customize and extend the library for domain-specific applications, ensuring flexibility and adaptability.</li> </ul>"},{"location":"#future-developments","title":"Future Developments","text":"<p>Note</p> <p>stateforward_rust is nearing completion and will be used as the backend for the Python package. The Rust package will be released shortly after the Python package enters beta.</p> <p>Looking ahead, Stateforward aims to launch packages that allow Rust and JavaScript developers to utilize its features seamlessly integrated into their respective ecosystems. This expansion will empower developers to model and run state machines with high performance and in a language-agnostic manner, promoting unified design patterns across different platforms.</p> <p>By bridging the gap between different programming languages, Stateforward will enable a broader spectrum of software developers to leverage the power of state machines in their applications\u2014be it web development with JavaScript or systems programming with Rust.</p>"},{"location":"Python/Overview/","title":"Overview","text":"<p>StateForward Python is in alpha</p> <p>This is a work in progress and is not ready for production use yet. The API and implementation are subject to changes on minor versions. See the Roadmap for planned features and the Contributing section for ways to contribute.</p>"},{"location":"Python/Overview/#stateforward--about-stateforward-python","title":"About StateForward Python","text":"<p>StateForward Python is where code complexity meets simplicity. This library is your ally in evolving spaghetti code into elegant, robust state machines. Say goodbye to the dense forest of if-else statements and welcome a world where adding features doesn\u2019t mean unraveling a complex knot.</p> <p>With StateForward Python, you\u2019re building on solid ground. Your code becomes a clear map of states and transitions, making it easily extendable and a joy to maintain. It's about writing software that grows with grace, ensuring that your project's future is as structured and reliable as its present.</p>"},{"location":"Python/Overview/#stateforward--installation","title":"Installation","text":"<pre><code>pip install stateforward\n</code></pre>"},{"location":"Python/Overview/#stateforward--usage","title":"Usage","text":"<p>Light Switch Example</p> DiagramCodeOutput <p>Here is a simple example of a light switch state machine using StateForward Python. <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / print(\"Light off entry\")\n    Off: exit / print(\"Light off exit\")\n    [*] --&gt; Off\n    On: On\n    On: entry / print(\"Light on entry\")\n    On: exit / print(\"Light on exit\")\n    Off --&gt; On : OnEvent\n    On --&gt; Off : OffEvent\n\n</code></pre></p> <pre><code>import stateforward as sf\nimport asyncio\n\n\nclass OnEvent(sf.Event):\n    pass\n\n\nclass OffEvent(sf.Event):\n    pass\n\n\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light on entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light on exit\")\n\n    class Off(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light off entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light off exit\")\n\n    initial = sf.initial(Off)\n    transitions = sf.collection(\n        sf.transition(OnEvent, source=Off, target=On),\n        sf.transition(OffEvent, source=On, target=Off),\n    )\n\n\nasync def main():\n    # instantiate a light switch\n    light_switch = LightSwitch()\n    # start the interpreter and wait for it to be settled\n    await light_switch.interpreter.start()\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OnEvent to the state machine\n    await sf.dispatch(OnEvent(), light_switch)\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OffEvent to the state machine\n    await sf.dispatch(OffEvent(), light_switch)\n    print(light_switch.state)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>Light off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\nLight on entry\n(&lt;__main__.LightSwitch.region.region_0.On object at 0x10683dd90&gt;,)\nLight on exit\nLight off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\n</code></pre>"},{"location":"Python/Roadmap/","title":"Roadmap","text":""},{"location":"Python/Roadmap/#roadmap","title":"Roadmap","text":""},{"location":"Python/Roadmap/#submachine","title":"Submachine","text":"<ul> <li> Implement Submachine: Creation of a substate machine within the larger state machine architecture is complete.</li> <li> Define Entry Point: Establish the initialization state where the submachine commences its process.</li> <li> Institute Exit Point: Designate the final state that concludes the submachine's execution and handle any necessary state cleanup.</li> </ul>"},{"location":"Python/Roadmap/#history-pseudostate","title":"History Pseudostate","text":"<ul> <li> Integrate Shallow History: Develop a state memory system that recalls the most recent active substate without retaining nested state histories, enabling reentry at the last active state.</li> <li> Incorporate Deep History: Implement a comprehensive state memory system that retains complete nested state histories for accurate restoration upon reentry.</li> </ul>"},{"location":"Python/Roadmap/#statemachine-interpreters","title":"StateMachine Interpreters","text":"<ul> <li> Implement Async StateMachine Interpreter: Completed the asynchronous state machine interpreter, facilitating non-blocking state execution.</li> <li> Develop Multi-Processing StateMachine Interpreter: Construct an interpreter that utilizes multiple processes for parallel state processing, enhancing performance for computations.</li> <li> Construct Thread-Based Interpreter: Build an interpreter that manages state operations via threading, optimizing for concurrent I/O-bound tasks.</li> <li> Design SequentialStateMachine Interpreter: Initiate the creation of an interpreter that deals with state transitions in a sequential, ordered manner, designed for straightforward execution flows.</li> </ul>"},{"location":"Python/Roadmap/#unit-tests","title":"Unit Tests","text":"<ul> <li> Develop Unit Tests: Write tests for individual state components to evaluate their independent functionalities, ensuring reliability and bug-free operation.</li> </ul>"},{"location":"Python/Roadmap/#documentation","title":"Documentation","text":"<ul> <li> Compile Documentation: Produce detailed documentation outlining the state machine's configuration, including its states, transitions, and state machine protocols, to support maintenance and usage comprehension.</li> </ul>"},{"location":"Python/Roadmap/#interpreter-refactoring","title":"Interpreter Refactoring","text":"<ul> <li> Refactor Interpreter Logic: Rework the interpreter component to execute a sequence of abstract instructions, rather than direct manipulation of the state tree, for better modularity and maintainability.</li> </ul> <p>See the open issues for a full list of proposed features (and known issues).</p>"},{"location":"Python/API/Core/Decorators/","title":"Decorators","text":"<p>Wraps a callable that is intended to be used as an event handler for call events.</p> <p>The <code>call_event</code> decorator is designed to transform a callable into a subclass of <code>core.CallEvent</code>. The new subclass uses the decorated callable as an event handling operation.</p> <p>This decorator is typically used within the <code>stateforward</code> framework, where events are central to the state changes in a finite state machine.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[CallEvent, Event], Any]</code> <p>The callable that will be transformed into a <code>core.CallEvent</code> subclass. This callable should take a <code>core.CallEvent</code> instance and a <code>core.Event</code> instance as arguments and return any type.</p> required <p>Returns:</p> Type Description <p>Type[core.CallEvent]: A new subclass of <code>core.CallEvent</code> which encapsulates the decorated function as its event operation.</p> <p>Note that the decorator internally uses a wrapper function to perform the decoration, but it is the decorated callable that is returned.</p>"},{"location":"Python/API/Core/Decorators/#stateforward.core.decorators.behavior","title":"<code>behavior(decorated, subtype=core.Behavior)</code>","text":"<p>Creates a new behavior type based on a decorated callable and an optional behavior subtype. This function is a decorator that, when applied to a callable, constructs a new behavior type using a model element factory. It optionally takes a subtype of <code>core.Behavior</code> to be used as a base for the new behavior type. If a subtype is not provided, <code>core.Behavior</code> is used as the default base. The wrapped callable gets transformed into an <code>activity</code> attribute of the new behavior type. The name of the new behavior type is either taken from the <code>__name__</code> attribute of the decorated callable or its representation if <code>__name__</code> is not available.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[Behavior, Optional[Event]], R]</code> <p>The callable to be decorated, which represents the logic of the behavior. The callable should have at least one parameter to accept an instance of <code>core.Behavior</code> and an optional second parameter to accept an instance of <code>core.Event</code>.</p> required <code>subtype</code> <code>Optional[type[Behavior]]</code> <p>The subtype of <code>core.Behavior</code> to use as the base for the new behavior type. If not provided, <code>core.Behavior</code> is used as the default.</p> <code>Behavior</code> <p>Returns:</p> Type Description <code>type[Behavior]</code> <p>type[core.Behavior]:  A new subclass of <code>core.Behavior</code> or the provided subtype, with the decorated callable assigned as the <code>activity</code> method.</p> Source code in <code>stateforward/core/decorators.py</code> <pre><code>def behavior(\n    decorated: Callable[[core.Behavior, Optional[core.Event]], R],\n    subtype: Optional[type[core.Behavior]] = core.Behavior,\n) -&gt; type[core.Behavior]:\n    \"\"\"\n    Creates a new behavior type based on a decorated callable and an optional behavior subtype.\n    This function is a decorator that, when applied to a callable, constructs a new behavior type using a model element factory. It optionally takes a subtype of `core.Behavior` to be used as a base for the new behavior type. If a subtype is not provided, `core.Behavior` is used as the default base.\n    The wrapped callable gets transformed into an `activity` attribute of the new behavior type. The name of the new behavior type is either taken from the `__name__` attribute of the decorated callable or its representation if `__name__` is not available.\n\n    Args:\n        decorated (Callable[[core.Behavior, Optional[core.Event]], R]):\n             The callable to be decorated, which represents the logic of the behavior. The callable should have at least one parameter to accept an instance of `core.Behavior` and an optional second parameter to accept an instance of `core.Event`.\n        subtype (Optional[type[core.Behavior]]):\n             The subtype of `core.Behavior` to use as the base for the new behavior type. If not provided, `core.Behavior` is used as the default.\n\n    Returns:\n        type[core.Behavior]:\n             A new subclass of `core.Behavior` or the provided subtype, with the decorated callable assigned as the `activity` method.\n\n    \"\"\"\n\n    @wraps(decorated)\n    def wrapper(_decorated: Callable = decorated) -&gt; Callable[[core.Behavior], R]:\n        \"\"\"\n        Decorates a function to create a new CallEvent type with the provided function as its operation.\n        This function is intended to be used as a decorator, which when applied to another function, utilizes the functionality\n        of the `model.element.new` method to create a new subclass of `core.CallEvent` with the decorated function as\n        its operation. The name of the new CallEvent type will be the same as the name of the decorated function.\n\n        Args:\n            _decorated:\n                 The function to be used as the operation for the new CallEvent type. The default value is the\n                decorated function itself, which allows this wrapper to be used as a decorator.\n\n        Returns:\n            Type[core.CallEvent]:\n                 A new subclass of core.CallEvent that encapsulates the provided operation function.\n\n        \"\"\"\n        return model.element.new(\n            getattr(_decorated, \"__name__\", repr(_decorated)),\n            bases=(subtype,),\n            activity=_decorated,\n        )\n\n    return wrapper(decorated)\n</code></pre>"},{"location":"Python/API/Core/Decorators/#stateforward.core.decorators.call_event","title":"<code>call_event(decorated)</code>","text":"<p>Creates a CallEvent subclass that is associated with the provided callable. This function is a decorator factory which, when called with a function reference (<code>decorated</code>), returns a decorator. The decorator then constructs a new subclass of <code>core.CallEvent</code> that incorporates the <code>decorated</code> callable as its operation.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[CallEvent, Event], Any]</code> <p>The callable to be associated with the CallEvent subclass. This callable typically performs an operation related to an event in the event-handling system.</p> required <p>Returns:</p> Type Description <code>Type[CallEvent]</code> <p>Type[core.CallEvent]:  A new subclass of <code>core.CallEvent</code> that is tied to the <code>decorated</code> callable.</p> Source code in <code>stateforward/core/decorators.py</code> <pre><code>def call_event(\n    decorated: Callable[[core.CallEvent, core.Event], Any],\n) -&gt; Type[core.CallEvent]:\n    \"\"\"\n    Creates a CallEvent subclass that is associated with the provided callable.\n    This function is a decorator factory which, when called with a function reference (`decorated`),\n    returns a decorator. The decorator then constructs a new subclass of `core.CallEvent` that\n    incorporates the `decorated` callable as its operation.\n\n    Args:\n        decorated (Callable[[core.CallEvent, core.Event], Any]):\n             The callable to be associated\n            with the CallEvent subclass. This callable typically performs an operation related to\n            an event in the event-handling system.\n\n    Returns:\n        Type[core.CallEvent]:\n             A new subclass of `core.CallEvent` that is tied to the `decorated`\n            callable.\n\n    \"\"\"\n\n    @wraps(decorated)\n    def wrapper(_decorated: Callable[..., Any] = decorated) -&gt; Type[core.CallEvent]:\n        \"\"\"\n        A decorator function that wraps the given callable into a new type derived from `core.CallEvent`.\n        This decorator takes a callable, typically representing an event handling function, and creates a new class type that inherits from `core.CallEvent` with the given callable as its operation. The newly created class type reflects the name of the decorated function and can be used to handle events within the system, where the type encapsulation is needed for event management.\n\n        Args:\n            _decorated (Callable[..., Any], optional):\n                 The callable, usually a function, to be converted into a new `core.CallEvent` subclass. Defaults to the callable passed to the `call_event` decorator.\n\n        Returns:\n            Type[core.CallEvent]:\n                 A newly created subclass of `core.CallEvent` that encapsulates the decorated callable as its operation.\n\n        \"\"\"\n        return model.element.new(\n            _decorated.__name__,\n            bases=(core.CallEvent,),\n            operation=_decorated,\n        )\n\n    return wrapper(decorated)\n</code></pre>"},{"location":"Python/API/Core/Decorators/#stateforward.core.decorators.constraint","title":"<code>constraint(decorated)</code>","text":"<p>Decorate a function to turn it into a Constraint subclass. Takes a function that acts as a condition for a <code>core.Constraint</code> object and returns a new subclass of <code>core.Constraint</code> that can be used within the model to enforce that condition. The <code>decorated</code> function must take two arguments, namely an instance of <code>core.Constraint</code> and an instance of <code>core.Event</code>, and return a boolean indicating whether the condition is met or not.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[Constraint, Event], bool]</code> <p>The function to be turned into a <code>core.Constraint</code> subclass. It should accept a <code>core.Constraint</code> instance and a <code>core.Event</code> instance and return a boolean.</p> required <p>Returns:</p> Name Type Description <code>Type[Constraint]</code> <p>Type[core.Constraint]:  A new subclass of <code>core.Constraint</code> that represents the condition defined by the <code>decorated</code> function.</p> <code>Note</code> <code>Type[Constraint]</code> <p>The <code>wrapper</code> function inside <code>constraint</code> is a closure that captures the <code>decorated</code> function and uses it to create the new subclass of <code>core.Constraint</code>. This subclass is then returned when the <code>constraint</code> function is called.</p> Source code in <code>stateforward/core/decorators.py</code> <pre><code>def constraint(\n    decorated: Callable[[core.Constraint, core.Event], bool],\n) -&gt; Type[core.Constraint]:\n    \"\"\"\n    Decorate a function to turn it into a Constraint subclass.\n    Takes a function that acts as a condition for a `core.Constraint` object and returns a new subclass of `core.Constraint`\n    that can be used within the model to enforce that condition. The `decorated` function must take two arguments, namely\n    an instance of `core.Constraint` and an instance of `core.Event`, and return a boolean indicating whether the condition\n    is met or not.\n\n    Args:\n        decorated (Callable[[core.Constraint, core.Event], bool]):\n             The function to be turned into a `core.Constraint` subclass.\n            It should accept a `core.Constraint` instance and a `core.Event` instance and return a boolean.\n\n    Returns:\n        Type[core.Constraint]:\n             A new subclass of `core.Constraint` that represents the condition defined by the `decorated` function.\n        Note:\n            The `wrapper` function inside `constraint` is a closure that captures the `decorated` function and uses it to create\n            the new subclass of `core.Constraint`. This subclass is then returned when the `constraint` function is called.\n\n    \"\"\"\n\n    @wraps(decorated)\n    def wrapper(_decorated: Callable[[core.Constraint, core.Event], bool] = decorated):\n        \"\"\"\n        Decorates a function to create a new specialized `core.CallEvent` type.\n        This function takes another function (`_decorated`) intended to be used as an operation for a new `core.CallEvent` type. It applies the Python `wraps` decorator to carry over the metadata from `_decorated`. It uses `model.element.new` to dynamically create a new subclass of `core.CallEvent` with `_decorated` as the event operation.\n\n        Args:\n            _decorated (Callable[..., Any]):\n                 The function to use as an operation for the new event type. Defaults to the `decorated` variable from the outer scope which is presumed to be a callable.\n\n        Returns:\n            Type[core.CallEvent]:\n                 A new subclass of `core.CallEvent` that incorporates the `_decorated` function as an operation.\n\n        \"\"\"\n        return model.new(\n            getattr(_decorated, \"__name__\", repr(_decorated)),\n            bases=(core.Constraint,),\n            condition=_decorated,\n        )\n\n    return wrapper(decorated)\n</code></pre>"},{"location":"Python/API/Core/Elements/","title":"Elements","text":"<p>The <code>elements</code> module provides a comprehensive set of classes that represent various components of a state machine. The classes in this module can be utilized to model the states, transitions, events, and behaviors within a state machine architecture. Below is an overview of the main classes and enumerations within the module, each designed to encapsulate specific aspects of state machine behavior and functionality.</p>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements--classes","title":"Classes","text":"<ul> <li> <p><code>Vertex</code>: The base class for nodes within the state machine graph, which can have incoming and outgoing transitions.</p> </li> <li> <p><code>Transition</code>: Represents a state change in the state machine, connecting two vertices and potentially associated with triggering events, guards, and effects.</p> </li> <li> <p><code>TransitionPath</code>: Describes the sequence of vertices a transition passes through, including the vertices to enter and leave during the transition.</p> </li> </ul>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements--enumerations","title":"Enumerations","text":"<ul> <li> <p><code>ConcurrencyKind</code>: Defines the types of concurrency mechanisms used, like <code>threading</code>, <code>multiprocessing</code>, or <code>asynchronous</code> execution.</p> </li> <li> <p><code>TransitionKind</code>: Categorizes transitions as <code>internal</code>, <code>local</code>, <code>external</code>, or <code>self</code> transitions.</p> </li> <li> <p><code>PseudostateKind</code>: Specifies various types of control nodes within the state machine, such as <code>initial</code>, <code>choice</code>, <code>join</code>, <code>fork</code>, and others.</p> </li> </ul>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements--subclasses","title":"Subclasses","text":"<ul> <li> <p><code>FinalState</code>: Represents an end state for a region within a state machine.</p> </li> <li> <p><code>Pseudostate</code>: A subclass of <code>Vertex</code>, representing different kinds of control points within the state machine, such as initial states or junction points.</p> </li> <li> <p><code>State</code>: A vertex that may contain nested regions, representing a state which can also have entry and exit behaviors.</p> </li> <li> <p><code>Region</code>: Organizes the structure of states and transitions, representing a distinct context for stateful behaviors.</p> </li> <li> <p><code>Event</code>: The base class for events which can trigger transitions.</p> </li> <li> <p><code>Constraint</code>: Represents a condition that guards transitions or influences state behavior.</p> </li> <li> <p><code>StateMachine</code>: Encapsulates the entire state machine structure and behavior, acting as a container for states, regions, and transitions.</p> </li> </ul>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements--other-components","title":"Other Components","text":"<ul> <li> <p><code>Behavior</code>: Encapsulates the action or activity associated with a state or event within the state machine.</p> </li> <li> <p><code>CompletionEvent</code>: Represents an event that is fired upon the completion of a state's internal activity.</p> </li> <li> <p><code>ChangeEvent</code>: Triggers a transition based on a conditional expression being satisfied.</p> </li> <li> <p><code>TimeEvent</code>: Is fired when a specific time-related condition is met, like a timeout or an elapsed time period.</p> </li> </ul> <p>This module is intended to be used in conjunction with other modules and utilities that form a framework for state management and behavior modeling. The components defined here can be extended or used as is to create complex and robust state machines for various application domains.</p>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.StateMachine","title":"<code>StateMachine</code>","text":"<p>             Bases: <code>Behavior</code>, <code>CompositeState</code></p> <p>A state machine implementation that inherits from both Behavior and CompositeState. This class encapsulates the concept of a state machine, where a 'submachine_state' acts as the current state of the machine. It provides a property that retrieves the current state of the state machine as a tuple.</p> <p>Attributes:</p> Name Type Description <code>submachine_state</code> <code>State</code> <p>An instance of State that represents the current state of the state machine.</p> <code>Properties</code> <code>State</code> <code>state</code> <code>tuple[State]</code> <p>A tuple containing the states from the interpreter's stack that is also a subtype of State. This represents the current state configuration of the state machine.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class StateMachine(Behavior, CompositeState):\n    \"\"\"\n    A state machine implementation that inherits from both Behavior and CompositeState.\n    This class encapsulates the concept of a state machine, where a 'submachine_state' acts as the current state of the machine. It provides a property that retrieves the current state of the state machine as a tuple.\n\n    Attributes:\n        submachine_state (State):\n             An instance of State that represents the current state of the state machine.\n        Properties:\n        state (tuple[State]):\n             A tuple containing the states from the interpreter's stack that is also a subtype of State. This represents the current state configuration of the state machine.\n\n    \"\"\"\n\n    submachine_state: State = None\n\n    @property\n    def state(self) -&gt; tuple[State]:\n        \"\"\"\n        Property that returns a tuple of State instances from the interpreter's stack.\n        This property iterates over the keys of the stack in the interpreter object, casts\n        each key to a State type, and then filters out only those keys which are subtypes\n        of State as determined by the `is_subtype` method of a `model.element`. It then returns\n        the resulting State instances as a tuple.\n\n        Returns:\n            tuple[State]:\n                 A tuple containing State instances derived from the interpreter's stack.\n\n        \"\"\"\n        return tuple(\n            cast(State, value)\n            for value in self.interpreter.stack.keys()\n            if model.element.is_subtype(value, State)\n        )\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.StateMachine.state","title":"<code>state: tuple[State]</code>  <code>property</code>","text":"<p>Property that returns a tuple of State instances from the interpreter's stack. This property iterates over the keys of the stack in the interpreter object, casts each key to a State type, and then filters out only those keys which are subtypes of State as determined by the <code>is_subtype</code> method of a <code>model.element</code>. It then returns the resulting State instances as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[State]</code> <p>tuple[State]:  A tuple containing State instances derived from the interpreter's stack.</p>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.State","title":"<code>State</code>","text":"<p>             Bases: <code>Vertex</code>, <code>CompositeState</code></p> <p>A class that represents a State in a state machine, which is a specialized vertex that can also act as a composite state. It can have behaviors associated with it such as entry, exit, and activity, as well as a completion event. States can also defer events and reference a submachine for nested state configurations.</p> <p>Attributes:</p> Name Type Description <code>entry</code> <code>Behavior</code> <p>An optional behavior that is executed when entering the state. Defaults to None.</p> <code>exit</code> <code>Behavior</code> <p>An optional behavior that is executed when exiting the state. Defaults to None.</p> <code>activity</code> <code>Behavior</code> <p>An optional ongoing behavior that occurs while in the state. Defaults to None.</p> <code>completion</code> <code>CompletionEvent</code> <p>An optional completion event that can trigger a state transition. Defaults to None.</p> <code>deferred</code> <code>Collection[Event]</code> <p>An optional collection of events that are deferred until the state is exited. Defaults to None.</p> <code>submachine</code> <code>StateMachine</code> <p>An optional reference to a submachine if the state is a composite state that contains another state machine. Defaults to None.</p> <code>Inherits</code> <code>from</code> <code>Vertex</code> <code>from</code> <p>A base class representing the vertices in a state machine graph.</p> <code>CompositeState</code> <code>from</code> <p>A base class for states that contain other states, indicating that this state can act as a composite state.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class State(Vertex, CompositeState):\n    \"\"\"\n    A class that represents a State in a state machine, which is a specialized vertex that can also act as a composite state. It can have behaviors associated with it such as entry, exit, and activity, as well as a completion event. States can also defer events and reference a submachine for nested state configurations.\n\n    Attributes:\n        entry (Behavior):\n             An optional behavior that is executed when entering the state. Defaults to None.\n        exit (Behavior):\n             An optional behavior that is executed when exiting the state. Defaults to None.\n        activity (Behavior):\n             An optional ongoing behavior that occurs while in the state. Defaults to None.\n        completion (CompletionEvent):\n             An optional completion event that can trigger a state transition. Defaults to None.\n        deferred (model.Collection[Event]):\n             An optional collection of events that are deferred until the state is exited. Defaults to None.\n        submachine (StateMachine):\n             An optional reference to a submachine if the state is a composite state that contains another state machine. Defaults to None.\n        Inherits from:\n        Vertex:\n             A base class representing the vertices in a state machine graph.\n        CompositeState:\n             A base class for states that contain other states, indicating that this state can act as a composite state.\n\n    \"\"\"\n\n    entry: \"Behavior\" = None\n    exit: \"Behavior\" = None\n    activity: \"Behavior\" = None\n    completion: CompletionEvent = None\n    deferred: model.Collection[Event] = None\n    submachine: \"StateMachine\" = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Region","title":"<code>Region</code>","text":"<p>             Bases: <code>Element</code></p> <p>A class representing a Region in a state-based model. A Region can be considered as a part of a 'State', or it can be the top-level state containment for state machine. It may contain a collection of 'Vertex' instances representing states and transitions, and points to an 'Initial' pseudo-state that determines the default active state when entering this region. This class extends from 'model.Element', and includes optional references to a 'State' and a 'StateMachine' to which the region belongs. Additionally, it holds an optional collection of 'Vertex' instances that are contained within the region and an 'Initial' pseudo-state representing the default entry point.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>Optional[State]</code> <p>A reference to the 'State' instance that contains this region, if any.</p> <code>state_machine</code> <code>Optional[StateMachine]</code> <p>A reference to the 'StateMachine' instance that contains this region if it is a top-level region.</p> <code>subvertex</code> <code>Collection[Vertex]</code> <p>A collection of 'Vertex' instances that the region contains.</p> <code>initial</code> <code>Initial</code> <p>An 'Initial' pseudo-state specifying the initial active state within the region.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Region(model.Element):\n    \"\"\"\n    A class representing a Region in a state-based model. A Region can be considered as a part of a 'State', or it can be the top-level state containment for state machine. It may contain a collection of 'Vertex' instances representing states and transitions, and points to an 'Initial' pseudo-state that determines the default active state when entering this region.\n    This class extends from 'model.Element', and includes optional references to a 'State' and a 'StateMachine' to which the region belongs. Additionally, it holds an optional collection of 'Vertex' instances that are contained within the region and an 'Initial' pseudo-state representing the default entry point.\n\n    Attributes:\n        state (Optional['State']):\n             A reference to the 'State' instance that contains this region, if any.\n        state_machine (Optional['StateMachine']):\n             A reference to the 'StateMachine' instance that contains this region if it is a top-level region.\n        subvertex (model.Collection[Vertex]):\n             A collection of 'Vertex' instances that the region contains.\n        initial (Initial):\n             An 'Initial' pseudo-state specifying the initial active state within the region.\n\n    \"\"\"\n\n    state: Optional[\"State\"] = None\n    state_machine: Optional[\"StateMachine\"] = None\n    subvertex: model.Collection[Vertex] = None\n    initial: Initial = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Transition","title":"<code>Transition</code>","text":"<p>             Bases: <code>Element</code></p> <p>A UML Transition element that represents a state change in the finite state machine. This class is inherited from the model.Element and acts as a container for the characteristics of a transition between states (or pseudostates) within a region.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Union[Vertex, State, Pseudostate]</code> <p>The starting point of the transition, which can be either a Vertex, State, or Pseudostate.</p> <code>target</code> <code>Union[Vertex, State, Pseudostate]</code> <p>The endpoint of the transition, which can be either a Vertex, State, or Pseudostate.</p> <code>container</code> <code>Region</code> <p>The region that contains this transition. This region is part of the finite state machine structure that the transition belongs to.</p> <code>events</code> <code>Collection[Event]</code> <p>A collection of events that trigger this transition. The transition occurs when one of the events in this collection fires.</p> <code>effect</code> <code>Behavior</code> <p>The effect is a behavior to be performed when the transition occurs. This behavior is executed after the transition takes place.</p> <code>guard</code> <code>Constraint</code> <p>A condition that must evaluate to true for the transition to be taken. If the guard condition is false, the transition will not occur.</p> <code>kind</code> <code>TransitionKind</code> <p>The kind specifies the nature of the transition. Different transition kinds define different types of behavior such as internal, external, etc.</p> <code>path</code> <code>TransitionPath</code> <p>The path attribute provides information about the transition path, including its source and target and any intermediate steps.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Transition(model.Element):\n    \"\"\"\n    A UML Transition element that represents a state change in the finite state machine.\n    This class is inherited from the model.Element and acts as a container for the\n    characteristics of a transition between states (or pseudostates) within a region.\n\n    Attributes:\n        source (Union[Vertex, 'State', 'Pseudostate']):\n             The starting point of the transition,\n            which can be either a Vertex, State, or Pseudostate.\n        target (Union[Vertex, 'State', 'Pseudostate']):\n             The endpoint of the transition,\n            which can be either a Vertex, State, or Pseudostate.\n        container ('Region'):\n             The region that contains this transition. This region is part of\n            the finite state machine structure that the transition belongs to.\n        events (model.Collection['Event']):\n             A collection of events that trigger this\n            transition. The transition occurs when one of the events in this collection fires.\n        effect ('Behavior'):\n             The effect is a behavior to be performed when the transition\n            occurs. This behavior is executed after the transition takes place.\n        guard ('Constraint'):\n             A condition that must evaluate to true for the transition to be\n            taken. If the guard condition is false, the transition will not occur.\n        kind (TransitionKind):\n             The kind specifies the nature of the transition. Different\n            transition kinds define different types of behavior such as internal, external, etc.\n        path (TransitionPath):\n             The path attribute provides information about the transition\n            path, including its source and target and any intermediate steps.\n\n    \"\"\"\n\n    source: Union[Vertex, \"State\", \"Pseudostate\"] = None\n    target: Union[Vertex, \"State\", \"Pseudostate\"] = None\n    container: \"Region\" = None\n    events: model.Collection[\"Event\"] = None\n    effect: \"Behavior\" = None\n    guard: \"Constraint\" = None\n    kind: TransitionKind = None\n    path: TransitionPath = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Vertex","title":"<code>Vertex</code>","text":"<p>             Bases: <code>Element</code></p> <p>A Vertex represents a node in a state machine diagram within a modeling framework. This class is a subclass of <code>model.Element</code> and represents the concept of a vertex in the context of state machines. A <code>Vertex</code> has potential incoming and outgoing transitions, which are references to other <code>Vertex</code> instances via <code>Transition</code> instances. It also maintains a reference to its containing <code>Region</code>, which represents the larger hierarchical structure of a state machine.</p> <p>Attributes:</p> Name Type Description <code>outgoing</code> <code>Collection[Transition]</code> <p>A collection of outgoing transitions from this vertex. The initial value is None, indicating that it may be set later.</p> <code>incoming</code> <code>Collection[Transition]</code> <p>A collection of incoming transitions to this vertex. Similar to outgoing, it is initialized as None.</p> <code>container</code> <code>Region</code> <p>The region that contains this vertex. This attribute is also initialized to None, reflecting that the assignment to a specific region will occur post-initialization.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Vertex(model.Element):\n    \"\"\"\n    A Vertex represents a node in a state machine diagram within a modeling framework.\n    This class is a subclass of `model.Element` and represents the concept of a vertex in the context of state machines. A `Vertex` has potential incoming and outgoing transitions, which are references to other `Vertex` instances via `Transition` instances. It also maintains a reference to its containing `Region`, which represents the larger hierarchical structure of a state machine.\n\n    Attributes:\n        outgoing (model.Collection['Transition']):\n             A collection of outgoing transitions from this vertex. The initial value is None, indicating that it may be set later.\n        incoming (model.Collection['Transition']):\n             A collection of incoming transitions to this vertex. Similar to outgoing, it is initialized as None.\n        container ('Region'):\n             The region that contains this vertex. This attribute is also initialized to None, reflecting that the assignment to a specific region will occur post-initialization.\n\n    \"\"\"\n\n    outgoing: model.Collection[\"Transition\"] = None  # initialize as None\n    incoming: model.Collection[\"Transition\"] = None  # initialize as None\n    container: \"Region\" = None  # initialize as None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Pseudostate","title":"<code>Pseudostate</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>Represents a vertex in the state machine which is a Pseudostate. A Pseudostate is typically used to represent complex transition scenarios in state machines. This class extends from the Vertex class and includes an attribute to represent the specific kind of pseudostate it is.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An enum value that signifies the specific kind of pseudostate, such as initial, choice, junction, etc. The default value is None, which should be set to a specific kind by the user.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Pseudostate(Vertex):\n    \"\"\"\n    Represents a vertex in the state machine which is a Pseudostate.\n    A Pseudostate is typically used to represent complex transition scenarios in state machines. This class extends from the Vertex class and includes an attribute to represent the specific kind of pseudostate it is.\n\n    Attributes:\n        kind (PseudostateKind):\n             An enum value that signifies the specific kind of pseudostate, such as initial, choice, junction, etc. The default value is None, which should be set to a specific kind by the user.\n\n    \"\"\"\n\n    kind: PseudostateKind = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Initial","title":"<code>Initial</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>Represents an initial pseudostate in a state machine. An initial pseudostate is a starting point for any state machine. When the state machine is initialized, it begins execution with the state that has an outgoing transition from this initial pseudostate.</p> <p>Attributes:</p> Name Type Description <code>transition</code> <code>Transition</code> <p>A transition object representing the outright transition from the initial pseudostate to another state in the state machine. This transition is triggered when the state machine starts. Initially, the transition is set to None and should be defined when the initial state is connected to another state.</p> <code>Inheritance</code> <code>Transition</code> <p>Inherits from <code>Pseudostate</code> with an implicit kind of <code>PseudostateKind.initial</code> to indicate that it is an initial pseudostate.</p> <code>Note</code> <code>Transition</code> <p>The class is expected to be used as part of a larger state machine framework, where transitions and states are interlinked to define the behavior of a complex system.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Initial(Pseudostate, kind=PseudostateKind.initial):\n    \"\"\"\n    Represents an initial pseudostate in a state machine.\n    An initial pseudostate is a starting point for any state machine. When the state machine is initialized,\n    it begins execution with the state that has an outgoing transition from this initial pseudostate.\n\n    Attributes:\n        transition (Transition):\n             A transition object representing the outright transition from the initial\n            pseudostate to another state in the state machine. This transition is triggered\n            when the state machine starts. Initially, the transition is set to None and should\n            be defined when the initial state is connected to another state.\n        Inheritance:\n            Inherits from `Pseudostate` with an implicit kind of `PseudostateKind.initial` to indicate\n            that it is an initial pseudostate.\n        Note:\n            The class is expected to be used as part of a larger state machine framework, where transitions\n            and states are interlinked to define the behavior of a complex system.\n\n    \"\"\"\n\n    transition: \"Transition\" = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Behavior","title":"<code>Behavior</code>","text":"<p>             Bases: <code>Model</code></p> <p>A class representing a Behavior which is part of a model with defined concurrency and associated actions. This class encapsulates the behavior in a system modeled by multiple classes. It defines the type of concurrency (synchronous, asynchronous, etc.), the activity to be carried out when triggered by an event, the context within which the behavior operates, and a pool of events it can handle.</p> <p>Attributes:</p> Name Type Description <code>concurrency_kind</code> <code>ClassVar[ConcurrencyKind]</code> <p>A variable indicating the type of concurrency employed by the behavior. This is a class-level variable shared among all instances.</p> <code>activity</code> <code>Callable[[Event], Future]</code> <p>A callable that is invoked when the behavior is triggered by an event. It represents the action or activity undertaken by the behavior and returns a Future object, typically indicating an asynchronous operation.</p> <code>context</code> <code>Union[T, Behavior]</code> <p>A reference that provides the context in which the behavior operates. This can be an instance of a different Behavior or any other type (denoted by T) that provides the necessary context for the behavior.</p> <code>pool</code> <code>Collection[Event]</code> <p>A collection of events that are within the scope of what the behavior can handle. This is where events are pooled and managed by the behavior.</p> <code>Note</code> <code>Collection[Event]</code> <p>The actual types for the attributes <code>concurrency_kind</code>, <code>activity</code>, and <code>context</code> are defined externally and should be supplied during the usage of this class.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Behavior(model.Model):  # , Generic[T]):\n    \"\"\"\n    A class representing a Behavior which is part of a model with defined concurrency and associated actions.\n    This class encapsulates the behavior in a system modeled by multiple classes. It defines the type\n    of concurrency (synchronous, asynchronous, etc.), the activity to be carried out when\n    triggered by an event, the context within which the behavior operates, and a pool of events\n    it can handle.\n\n    Attributes:\n        concurrency_kind (ClassVar[ConcurrencyKind]):\n             A variable indicating the type of concurrency employed by the\n            behavior. This is a class-level variable shared among all instances.\n        activity (Callable[['Event'], Future]):\n             A callable that is invoked when the behavior is triggered by an event.\n            It represents the action or activity undertaken by the behavior and returns a Future object, typically\n            indicating an asynchronous operation.\n        context (Union[T, 'Behavior']):\n             A reference that provides the context in which the behavior operates.\n            This can be an instance of a different Behavior or any other type (denoted by T) that provides\n            the necessary context for the behavior.\n        pool (model.Collection[Event]):\n             A collection of events that are within the scope of what the behavior can handle.\n            This is where events are pooled and managed by the behavior.\n        Note:\n            The actual types for the attributes `concurrency_kind`, `activity`, and `context` are defined\n            externally and should be supplied during the usage of this class.\n\n    \"\"\"\n\n    \"\"\"\n    A class that models a behavior and manages concurrent execution of activities in response to events.\n\n    Attributes:\n        concurrency_kind (ClassVar[ConcurrencyKind]):\n            A class variable that specifies the concurrency mechanism used by the behavior. This might refer to an enumeration that defines whether the behavior is sequential, parallel or any other type of concurrency control.\n            activity (Callable[['Event'], Future]): A callable attribute that represents the action or function to be triggered in response to an event. This callable takes an 'Event' object as an argument and returns a 'Future' object, facilitating asynchronous operation.\n            context (Union[T, 'Behavior']):\n            The context in which the behavior operates. It can either be a generic type 'T' or an instance of 'Behavior', depending on how the behavior is defined and used. This allows the behavior to be adaptable and possibly nested or composed of other behaviors.\n            pool (model.Collection[Event]): A collection attribute that holds 'Event' objects to be processed by the behavior. This can be any collection-type object as defined by the 'model' module that is capable of managing and storing multiple events.\n            Note that concrete subclasses should define the specifics of concurrency control, the actual function of the activity, the relevant context, and the appropriate collection for the pool of events.\n\n    \"\"\"\n    \"\"\"\n    A base class for defining behaviors in a system.\n        Behaviors encapsulate actions that are triggered by events. Each behavior can\n        be associated with its own concurrency mechanism, can target a callable to\n        execute, and can maintain a context for execution. The behavior also\n        manages a collection pool of events it is responsible for.\n\n        Attributes:\n            concurrency_kind (ClassVar[ConcurrencyKind]): A class-level variable that specifies\n                the concurrency behavior (e.g., single-threaded, multi-threaded) that the derived\n                behavior class will adhere to.\n            activity (Callable[['Event'], Future]): A callable activity that the behavior executes\n                when it processes an event. This callable typically returns a Future object that\n                represents a potentially long-running computation.\n            context (Union[T, 'Behavior']): The context in which the behavior's activity is\n                executed. This can be a specific context data type T or another Behavior\n                instance.\n            pool (model.Collection[Event]): A collection that holds the events which the behavior\n                is responsible to handle.\n        Note:\n            This class is intended to be subclassed and is part of a larger framework or\n            system. It is not meant to be instantiated directly.\n\n    \"\"\"\n    concurrency_kind: ClassVar[ConcurrencyKind] = None\n    activity: Callable[[\"Event\"], Future] = None\n    context: Union[T, \"Behavior\"] = None\n    pool: model.Collection[Event] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.PseudostateKind","title":"<code>PseudostateKind</code>","text":"<p>             Bases: <code>Enum</code></p> <p>A class that enumerates the various kinds of pseudostates that can be used within a state machine. Pseudostates are special kinds of states that denote a transition phase rather than an actual state that an entity can reside in. The PseudostateKind class contains enumeration members that represent the different types of pseudostates including <code>initial</code>, <code>choice</code>, <code>join</code>, <code>deep_history</code>, <code>shallow_history</code>, <code>fork</code>, <code>entry_point</code>, <code>exit_point</code>, <code>junction</code>, and <code>terminate</code>. Each of these members correlates to a specific kind of pseudostate behavior.</p> <p>Attributes:</p> Name Type Description <code>initial</code> <code>str</code> <p>Represents the starting pseudostate of a state machine, indicating the default state on creation.</p> <code>choice</code> <code>str</code> <p>Indicates a decision point where multiple outgoing transitions are possible based on guard conditions.</p> <code>join</code> <code>str</code> <p>Represents the merging of parallel transition paths back into a single transition path.</p> <code>deep_history</code> <code>str</code> <p>Indicates that the state machine should enter the most recent active configuration of a composite state.</p> <code>shallow_history</code> <code>str</code> <p>Represents a history pseudostate that only remembers the immediate prior state rather than the complete history.</p> <code>fork</code> <code>str</code> <p>Symbolizes a splitting of one transition path into multiple parallel paths of execution.</p> <code>entry_point</code> <code>str</code> <p>Denotes a predefined point where a transition may cross the boundaries of a composite state.</p> <code>exit_point</code> <code>str</code> <p>Indicates a specific point out of a state or a region where transitions can be made from the inside.</p> <code>junction</code> <code>str</code> <p>Represents a complex branching point where multiple joins and forks can be chained together.</p> <code>terminate</code> <code>str</code> <p>Symbolizes the end of a state machine instance's life, after which no further processing occurs. This enumeration is typically used as part of a framework or library that implements state machine behavior, and serves to ensure that the pseudostate behavior is consistent and standardized across different applications.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class PseudostateKind(Enum):\n    \"\"\"\n    A class that enumerates the various kinds of pseudostates that can be used within a state machine.\n    Pseudostates are special kinds of states that denote a transition phase rather than an actual state that an\n    entity can reside in. The PseudostateKind class contains enumeration members that represent the different types\n    of pseudostates including `initial`, `choice`, `join`, `deep_history`, `shallow_history`, `fork`, `entry_point`,\n    `exit_point`, `junction`, and `terminate`. Each of these members correlates to a specific kind of pseudostate\n    behavior.\n\n    Attributes:\n        initial (str):\n             Represents the starting pseudostate of a state machine, indicating the default state on creation.\n        choice (str):\n             Indicates a decision point where multiple outgoing transitions are possible based on guard\n            conditions.\n        join (str):\n             Represents the merging of parallel transition paths back into a single transition path.\n        deep_history (str):\n             Indicates that the state machine should enter the most recent active configuration of a\n            composite state.\n        shallow_history (str):\n             Represents a history pseudostate that only remembers the immediate prior state rather than\n            the complete history.\n        fork (str):\n             Symbolizes a splitting of one transition path into multiple parallel paths of execution.\n        entry_point (str):\n             Denotes a predefined point where a transition may cross the boundaries of a composite state.\n        exit_point (str):\n             Indicates a specific point out of a state or a region where transitions can be made from the inside.\n        junction (str):\n             Represents a complex branching point where multiple joins and forks can be chained together.\n        terminate (str):\n             Symbolizes the end of a state machine instance's life, after which no further processing occurs.\n            This enumeration is typically used as part of a framework or library that implements state machine behavior,\n            and serves to ensure that the pseudostate behavior is consistent and standardized across different applications.\n\n    \"\"\"\n\n    initial = \"initial\"\n    choice = \"choice\"\n    join = \"join\"\n    deep_history = \"deep_history\"\n    shallow_history = \"shallow_history\"\n    fork = \"fork\"\n    entry_point = \"entry_point\"\n    exit_point = \"exit_point\"\n    junction = \"junction\"\n    terminate = \"terminate\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.TransitionKind","title":"<code>TransitionKind</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration to represent the types of transitions in a state machine.</p> <p>Attributes:</p> Name Type Description <code>internal</code> <code>Enum</code> <p>A transition that occurs within the context of a single state, without causing a state exit or entry.</p> <code>local</code> <code>Enum</code> <p>A transition that is local to a composite state and does not exit the composite state itself.</p> <code>external</code> <code>Enum</code> <p>A transition that causes the state machine to exit the current state and enter a new state.</p> <code>self</code> <code>Enum</code> <p>A special transition that represents a self-transition, where the state exits and re-enters itself.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class TransitionKind(Enum):\n    \"\"\"\n    An enumeration to represent the types of transitions in a state machine.\n\n    Attributes:\n        internal (Enum):\n             A transition that occurs within the context of a single state, without causing a state exit or entry.\n        local (Enum):\n             A transition that is local to a composite state and does not exit the composite state itself.\n        external (Enum):\n             A transition that causes the state machine to exit the current state and enter a new state.\n        self (Enum):\n             A special transition that represents a self-transition, where the state exits and re-enters itself.\n\n    \"\"\"\n\n    internal = \"internal\"\n    local = \"local\"\n    external = \"external\"\n    self = \"self\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.CallEvent","title":"<code>CallEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class that represents an event associated with a call operation, inheriting from the Event class.</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>Union[Future, Future]</code> <p>A placeholder for the future result of the call operation. This can either be an asyncio.Future or concurrent.futures.Future object.</p> <code>operation</code> <code>Callable[P, R]</code> <p>The callable object representing the operation that will be performed when the event is triggered. The callable should take parameters 'P' and return a result 'R'.</p> <code>__call__</code> <code>Callable[P, R]</code> <p>An alias or a proxy to the 'operation' callable, allowing the instance to be directly invoked like a function with the same signature.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class CallEvent(Event):\n    \"\"\"\n    A class that represents an event associated with a call operation, inheriting from the Event class.\n\n    Attributes:\n        results (Union[asyncio.Future, Future]):\n             A placeholder for the future result of the call operation. This can either be an asyncio.Future or concurrent.futures.Future object.\n        operation (Callable[P, R]):\n             The callable object representing the operation that will be performed when the event is triggered. The callable should take parameters 'P' and return a result 'R'.\n        __call__ (Callable[P, R]):\n             An alias or a proxy to the 'operation' callable, allowing the instance to be directly invoked like a function with the same signature.\n\n    \"\"\"\n\n    results: Union[asyncio.Future, Future] = None\n    operation: Callable[P, R] = None\n    __call__: Callable[P, R] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.AnyEvent","title":"<code>AnyEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>An extension of the <code>Event</code> class that represents a generic event without specific properties or restrictions. This class serves as a base class for more specialized event types or can be used directly to create events that do not require additional information beyond what is offered by the <code>Event</code> base class. Subclasses of <code>AnyEvent</code> can add more context-specific attributes and methods as needed.</p> <p>Attributes:</p> <p>Methods:</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class AnyEvent(Event):\n    \"\"\"\n    An extension of the `Event` class that represents a generic event without specific properties or restrictions.\n    This class serves as a base class for more specialized event types or can be used directly to create events that do not require additional information beyond what is offered by the `Event` base class. Subclasses of `AnyEvent` can add more context-specific attributes and methods as needed.\n\n    Attributes:\n\n    Methods:\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.FinalState","title":"<code>FinalState</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A class that represents the final state in a state machine or a similar diagrammatic structure. This class inherits from the Vertex class and signifies the completion of a process or the end state in a finite state machine or workflow.</p> <p>Attributes:</p> <p>Methods:</p> Name Description <code>Note</code> <p>Additional details on how FinalState interacts with other components of the system or any special considerations could be included in this section.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class FinalState(Vertex):\n    \"\"\"\n    A class that represents the final state in a state machine or a similar diagrammatic structure.\n    This class inherits from the Vertex class and signifies the completion of a process or the\n    end state in a finite state machine or workflow.\n\n    Attributes:\n\n    Methods:\n        Note:\n            Additional details on how FinalState interacts with other components of the system\n            or any special considerations could be included in this section.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.CompositeState","title":"<code>CompositeState</code>","text":"<p>             Bases: <code>Element</code></p> <p>Represents a composite state in a state machine model. A composite state is a state that contains one or more regions, which in turn can contain other states, including composite states. This allows for the representation of a hierarchy of states and the possibility of concurrent states within a single composite state.</p> <p>Attributes:</p> Name Type Description <code>regions</code> <code>Collection[Region]</code> <p>A collection of regions that the composite state contains. Each region is an instance of 'Region', allowing the composite state to encapsulate various states and transitions.</p> <code>Inheritance</code> <code>Collection[Region]</code> <p>Inherits from model.Element, which provides base functionality for elements in the state machine model.</p> <code>Note</code> <code>Collection[Region]</code> <p>The regions attribute is initialized as None and should be set with instances of 'Region' to define the structure of the composite state.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class CompositeState(model.Element):\n    \"\"\"\n    Represents a composite state in a state machine model.\n    A composite state is a state that contains one or more regions, which in turn can contain other\n    states, including composite states. This allows for the representation of a hierarchy of states\n    and the possibility of concurrent states within a single composite state.\n\n    Attributes:\n        regions (model.Collection['Region']):\n             A collection of regions that the composite state contains.\n            Each region is an instance of 'Region', allowing the composite state to encapsulate\n            various states and transitions.\n        Inheritance:\n            Inherits from model.Element, which provides base functionality\n            for elements in the state machine model.\n        Note:\n             The regions attribute is initialized as None and should be set with instances of\n            'Region' to define the structure of the composite state.\n\n    \"\"\"\n\n    regions: model.Collection[\"Region\"] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.CompletionEvent","title":"<code>CompletionEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class representing a completion event in a system or application. This class inherits from a base 'Event' class and is specialized to represent an event that signifies the completion of an activity or process. It optionally carries additional data with the 'value' field to provide context or resulting value at the time of completion.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The data or value associated with the completion event. This can be of any type and is meant to represent the result or final state upon completion. Default is 'None'.</p> <code>transition</code> <code>Transition</code> <p>Represents the state transition associated with the event completion. This is a placeholder for a 'Transition' type object which likely defines the movement from one state to another as the event completes. Default is 'None'.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Optional initialization argument for 'value'. The data or result to be associated with this completion event. If not provided, defaults to 'None'.</p> <code>None</code> Source code in <code>stateforward/core/elements.py</code> <pre><code>class CompletionEvent(Event):\n    \"\"\"\n    A class representing a completion event in a system or application.\n    This class inherits from a base 'Event' class and is specialized to represent an event that\n    signifies the completion of an activity or process. It optionally carries additional data\n    with the 'value' field to provide context or resulting value at the time of completion.\n\n    Attributes:\n        value (Any):\n             The data or value associated with the completion event. This can be of any\n            type and is meant to represent the result or final state upon completion. Default is 'None'.\n        transition (Transition):\n             Represents the state transition associated with the event completion.\n            This is a placeholder for a 'Transition' type object which likely defines\n            the movement from one state to another as the event completes. Default is 'None'.\n\n    Args:\n        value (Any, optional):\n             Optional initialization argument for 'value'. The data or\n            result to be associated with this completion event. If not provided,\n            defaults to 'None'.\n\n    \"\"\"\n\n    value: Any = None\n    transition: Transition = None\n\n    def __init__(self, value: Any = None):\n        \"\"\"\n        Initializes a new instance of the class with an optional value.\n\n        Args:\n            value (Any, optional):\n                 The initial value to be stored in the instance. Default is None.\n\n        \"\"\"\n        self.value = value\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.CompletionEvent.__init__","title":"<code>__init__(value=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The initial value to be stored in the instance. Default is None.</p> <code>None</code> Source code in <code>stateforward/core/elements.py</code> <pre><code>def __init__(self, value: Any = None):\n    \"\"\"\n    Initializes a new instance of the class with an optional value.\n\n    Args:\n        value (Any, optional):\n             The initial value to be stored in the instance. Default is None.\n\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Join","title":"<code>Join</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A specialized Pseudostate that represents a join node in a state machine. This class is a specific type of Pseudostate that is used to synchronize multiple concurrent flows. It inherits from the Pseudostate class and is initialized with a kind attribute set to PseudostateKind.join by default. When multiple transitions converge to a join node, they are synchronized, and the state machine continues with a single, unified transition emanating from the join node.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>A default attribute representing the kind of pseudostate, which is set to PseudostateKind.join to indicate a join node behavior.</p> <code>Inherits</code> <code>PseudostateKind</code> <code>Pseudostate</code> <code>PseudostateKind</code> <p>The base class for all pseudostates in a state machine.</p> <code>Note</code> <code>PseudostateKind</code> <p>This class should be used in the context of a state machine where concurrent states need to be synchronized before proceeding further in the workflow.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Join(Pseudostate, kind=PseudostateKind.join):\n    \"\"\"\n    A specialized Pseudostate that represents a join node in a state machine.\n    This class is a specific type of Pseudostate that is used to synchronize multiple\n    concurrent flows. It inherits from the Pseudostate class and is initialized with\n    a kind attribute set to PseudostateKind.join by default. When multiple transitions\n    converge to a join node, they are synchronized, and the state machine continues\n    with a single, unified transition emanating from the join node.\n\n    Attributes:\n        kind (PseudostateKind):\n             A default attribute representing the kind of pseudostate,\n            which is set to PseudostateKind.join to indicate a join node behavior.\n        Inherits:\n        Pseudostate:\n             The base class for all pseudostates in a state machine.\n        Note:\n            This class should be used in the context of a state machine where concurrent\n            states need to be synchronized before proceeding further in the workflow.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Fork","title":"<code>Fork</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A class that represents a Fork Pseudostate in UML state machines. The Fork class is a specialized form of the Pseudostate and is used to model a point in a state machine where a single transition splits into multiple parallel transitions or where multiple parallel states can converge into a single state. It leverages the PseudostateKind enumeration to indicate that the pseudostate is of type 'fork'. Inheritance: Inherits from Pseudostate.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An attribute provided by the Pseudostate class, which is set to PseudostateKind.fork, representing the kind of pseudostate this class models.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Fork(Pseudostate, kind=PseudostateKind.fork):\n    \"\"\"\n    A class that represents a Fork Pseudostate in UML state machines.\n    The Fork class is a specialized form of the Pseudostate and is used to model a point in a state machine where a single transition splits into multiple parallel transitions or where multiple parallel states can converge into a single state. It leverages the PseudostateKind enumeration to indicate that the pseudostate is of type 'fork'.\n    Inheritance:\n    Inherits from Pseudostate.\n\n    Attributes:\n        kind (PseudostateKind):\n             An attribute provided by the Pseudostate class, which is set to PseudostateKind.fork, representing the kind of pseudostate this class models.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.EntryPoint","title":"<code>EntryPoint</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>Represents an entry point definition in a state machine. <code>EntryPoint</code> is a specialized <code>Pseudostate</code> that denotes the starting point of a region in a state machine. It is a pseudo state of kind entry point, meaning it is used to trigger the state machine to begin its execution from this point.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An attribute inherited from <code>Pseudostate</code> that is statically set to <code>PseudostateKind.entry_point</code> to indicate that this pseudo state is an entry point.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class EntryPoint(Pseudostate, kind=PseudostateKind.entry_point):\n    \"\"\"\n    Represents an entry point definition in a state machine.\n    `EntryPoint` is a specialized `Pseudostate` that denotes the starting point of a\n    region in a state machine. It is a pseudo state of kind entry point, meaning\n    it is used to trigger the state machine to begin its execution from this point.\n\n\n    Attributes:\n        kind (PseudostateKind):\n            An attribute inherited from `Pseudostate` that is\n            statically set to `PseudostateKind.entry_point` to indicate that this\n            pseudo state is an entry point.\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.ExitPoint","title":"<code>ExitPoint</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A specialization of Pseudostate that represents an exit point in a StateMachine or composite State in a UML model. ExitPoint is used to denote a point within a composite State or StateMachine from which. transition to a point outside the composite State or StateMachine occurs. An ExitPoint, as a kind of Pseudostate, is used to encapsulate the exit behavior for the State that owns it, providing a modular way of defining how different transitions lead out of a State. Inherits from: Pseudostate -- A generalization for various control points within a StateMachine.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An enumerated value indicating the specific kind of Pseudostate that an instance represents, which in this case is set to PseudostateKind.exit_point by default.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class ExitPoint(Pseudostate, kind=PseudostateKind.exit_point):\n    \"\"\"\n    A specialization of Pseudostate that represents an exit point in a StateMachine or composite State in a UML model.\n    ExitPoint is used to denote a point within a composite State or StateMachine from which.\n    transition to a point outside the composite State or StateMachine occurs. An ExitPoint,\n    as a kind of Pseudostate, is used to encapsulate the exit behavior for the State that owns it,\n    providing a modular way of defining how different transitions lead out of a State.\n    Inherits from:\n    Pseudostate -- A generalization for various control points within a StateMachine.\n\n    Attributes:\n        kind (PseudostateKind):\n             An enumerated value indicating the specific kind of\n            Pseudostate that an instance represents, which in this case is\n            set to PseudostateKind.exit_point by default.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.DeepHistory","title":"<code>DeepHistory</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A DeepHistory class represents a deep history pseudostate within a state machine. It inherits from the Pseudostate class, with the kind attribute defaulted to PseudostateKind.deep_history. A deep history pseudostate is used to remember the most recent active configuration of states within a composite state. When a transition targets a deep history pseudostate, the state machine will re-enter the composite state with the same configuration that was last in place prior to its exit.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>A default attribute provided by the Pseudostate base class, overridden to use PseudostateKind.deep_history for deep history pseudostates.</p> <code>Inherits</code> <code>PseudostateKind</code> <code>Pseudostate</code> <code>PseudostateKind</code> <p>A base class for different types of pseudostates within a state machine.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class DeepHistory(Pseudostate, kind=PseudostateKind.deep_history):\n    \"\"\"\n    A DeepHistory class represents a deep history pseudostate within a state machine. It inherits from the\n    Pseudostate class, with the kind attribute defaulted to PseudostateKind.deep_history.\n    A deep history pseudostate is used to remember the most recent active configuration of states within\n    a composite state. When a transition targets a deep history pseudostate, the state machine will\n    re-enter the composite state with the same configuration that was last in place prior to its exit.\n\n    Attributes:\n        kind (PseudostateKind):\n             A default attribute provided by the Pseudostate base class, overridden\n            to use PseudostateKind.deep_history for deep history pseudostates.\n        Inherits:\n        Pseudostate:\n             A base class for different types of pseudostates within a state machine.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.ShallowHistory","title":"<code>ShallowHistory</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A class representing a shallow history pseudostate in a state machine. ShallowHistory is a specialized pseudostate that remembers the last active substate of its region, but not the history of nested substates. When a transition targets a shallow history pseudostate, the state machine will resume the state configuration just one level deep of the region. Inherits from: Pseudostate: A base class for pseudostates.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>Indicates the kind of pseudostate, which is set to <code>PseudostateKind.shallow_history</code> by default for this class.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class ShallowHistory(Pseudostate, kind=PseudostateKind.shallow_history):\n    \"\"\"\n    A class representing a shallow history pseudostate in a state machine.\n    ShallowHistory is a specialized pseudostate that remembers the last active substate of its region, but not the history of nested substates.\n    When a transition targets a shallow history pseudostate, the state machine will resume the state configuration just one level deep of the region.\n    Inherits from:\n    Pseudostate: A base class for pseudostates.\n\n    Attributes:\n        kind (PseudostateKind):\n             Indicates the kind of pseudostate, which is set to `PseudostateKind.shallow_history` by default for this class.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Junction","title":"<code>Junction</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A class representing a Junction, which is a specialized Pseudostate that is used to merge several transitions into one. Junction is a subclass of Pseudostate and is instantiated with a specific kind that identifies it as a junction kind of pseudostate. Junction pseudostates are used to model complex transitional logic in state machine diagrams, allowing for the convergence of multiple incoming transitions into a single outgoing transition.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An enumeration value of PseudostateKind, specifically set to 'junction' to denote the type of Pseudostate this class represents.</p> <code>Inherits</code> <code>PseudostateKind</code> <code>Pseudostate</code> <code>PseudostateKind</code> <p>The base class for pseudostates, providing core functionality and properties.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Junction(Pseudostate, kind=PseudostateKind.junction):\n    \"\"\"\n    A class representing a Junction, which is a specialized Pseudostate that is used to merge several transitions into one.\n    Junction is a subclass of Pseudostate and is instantiated with a specific kind that identifies it as a junction kind of pseudostate. Junction pseudostates are used to model complex transitional logic in state machine diagrams, allowing for the convergence of multiple incoming transitions into a single outgoing transition.\n\n    Attributes:\n        kind (PseudostateKind):\n             An enumeration value of PseudostateKind, specifically set to 'junction' to denote\n            the type of Pseudostate this class represents.\n        Inherits:\n        Pseudostate:\n             The base class for pseudostates, providing core functionality and properties.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.ChangeEvent","title":"<code>ChangeEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class that represents an event signaling a change based on a specified condition.</p> <p>Attributes:</p> Name Type Description <code>condition</code> <code>ConditionType</code> <p>An optional attribute representing the condition under which the change event is triggered.</p> <code>expr</code> <code>Callable[[Event], bool]</code> <p>An optional callable that takes an 'Event' object as input and returns a boolean value indicating whether the change event condition is met.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class ChangeEvent(Event):\n    \"\"\"\n    A class that represents an event signaling a change based on a specified condition.\n\n    Attributes:\n        condition (ConditionType):\n             An optional attribute representing the condition under which the change event is triggered.\n        expr (Callable[['Event'], bool]):\n             An optional callable that takes an 'Event' object as input and returns a boolean value indicating whether the change event condition is met.\n\n    \"\"\"\n\n    condition: ConditionType = None\n    expr: Callable[[\"Event\"], bool] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.TimeEvent","title":"<code>TimeEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class representing an event that is associated with a specific point in time or a duration of time.</p> <p>Attributes:</p> Name Type Description <code>when</code> <code>Union[datetime, timedelta]</code> <p>A datetime object indicating the specific time when the event occurs or a timedelta object indicating the duration or offset of the event from a certain point in time. The default is None, which means that the time or duration of the event is not set.</p> <code>Inherits</code> <code>from</code> <code>Event</code> <code>from</code> <p>The base class for all event types.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class TimeEvent(Event):\n    \"\"\"\n    A class representing an event that is associated with a specific point in time or a duration of time.\n\n    Attributes:\n        when (Union[datetime, timedelta], optional):\n             A datetime object indicating the specific time when the event occurs or a timedelta object indicating the duration or offset of the event from a certain point in time. The default is None, which means that the time or duration of the event is not set.\n        Inherits from:\n        Event:\n             The base class for all event types.\n\n    \"\"\"\n\n    when: Union[datetime, timedelta] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Choice","title":"<code>Choice</code>","text":"<p>             Bases: <code>Pseudostate</code></p> <p>A Pseudostate subclass that represents a choice pseudostate in a state machine. A choice pseudostate is a decision point where the transition path is chosen based on guards of the transitions. This Pseudostate subclass receives an additional argument <code>kind</code> which should be specifically set to <code>PseudostateKind.choice</code> to indicate that this pseudostate is a choice node.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>PseudostateKind</code> <p>An enumeration value that determines the kind of pseudostate, with the expected value being <code>PseudostateKind.choice</code> for this subclass.</p> <code>Inherits</code> <code>PseudostateKind</code> <code>Pseudostate</code> <code>PseudostateKind</code> <p>The base class for all pseudostates, providing common functionality.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Choice(Pseudostate, kind=PseudostateKind.choice):\n    \"\"\"\n    A Pseudostate subclass that represents a choice pseudostate in a state machine.\n    A choice pseudostate is a decision point where the transition path is chosen based on guards of the\n    transitions. This Pseudostate subclass receives an additional argument `kind` which should be\n    specifically set to `PseudostateKind.choice` to indicate that this pseudostate is a choice node.\n\n    Attributes:\n        kind (PseudostateKind):\n             An enumeration value that determines the kind of pseudostate,\n            with the expected value being `PseudostateKind.choice` for this subclass.\n        Inherits:\n        Pseudostate:\n             The base class for all pseudostates, providing common functionality.\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Constraint","title":"<code>Constraint</code>","text":"<p>             Bases: <code>Element</code></p> <p>A class that represents a constraint condition to be applied on an 'Event' within a modeling framework. This class inherits from 'model.Element' and encapsulates a condition that must be satisfied by an event. The condition is represented as a callable that takes an 'Event' as input and returns either a 'Future' object that resolves to a boolean or a boolean value directly. This allows for asynchronous or synchronous evaluation of the condition depending on the implementation.</p> <p>Attributes:</p> Name Type Description <code>condition</code> <code>Callable[[Event], Union[Future, bool]]</code> <p>A callable object that defines the constraint condition to be checked against 'Event' objects. If the callable returns a 'Future', the result of the future must be a boolean value that represents whether the 'Event' satisfies the constraint condition. If the callable returns a boolean directly, it represents the immediate result of the constraint evaluation.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Constraint(model.Element):\n    \"\"\"\n    A class that represents a constraint condition to be applied on an 'Event' within a modeling framework.\n    This class inherits from 'model.Element' and encapsulates a condition that must be satisfied by an event. The condition is represented as a callable that takes an 'Event' as input and returns either a 'Future' object that resolves to a boolean or a boolean value directly. This allows for asynchronous or synchronous evaluation of the condition depending on the implementation.\n\n    Attributes:\n        condition (Callable[['Event'], Union[Future, bool]]):\n             A callable object that defines the constraint condition to be checked against 'Event' objects. If the callable returns a 'Future', the result of the future must be a boolean value that represents whether the 'Event' satisfies the constraint condition. If the callable returns a boolean directly, it represents the immediate result of the constraint evaluation.\n\n    \"\"\"\n\n    condition: Callable[[\"Event\"], Union[Future, bool]] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.Event","title":"<code>Event</code>","text":"<p>             Bases: <code>Element</code></p> <p>An object that represents an event in a model. Inherits from the <code>model.Element</code> class.</p> <p>Attributes:</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class Event(model.Element):\n    \"\"\"\n    An object that represents an event in a model. Inherits from the `model.Element` class.\n\n    Attributes:\n\n    \"\"\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.TransitionPath","title":"<code>TransitionPath</code>","text":"<p>             Bases: <code>Element</code></p> <p>A class that represents a transition path within a model, which consists of entering and leaving vertices.</p> <p>Attributes:</p> Name Type Description <code>enter</code> <code>Collection[Vertex]</code> <p>A collection of Vertex instances that represent the points where a transition can be entered. If not specified, it defaults to None, indicating that there are no specific enter points designated.</p> <code>leave</code> <code>Collection[Vertex]</code> <p>A collection of Vertex instances that represent the points where a transition can be exited. Similar to <code>enter</code>, it defaults to None, indicating that there are no specific leave points designated. The TransitionPath is a part of the model that tracks the entry and exit points in a transition, which can be particularly useful in state machines or workflow representations where the concept of transitions between states or tasks is essential.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class TransitionPath(model.Element):\n    \"\"\"\n    A class that represents a transition path within a model, which consists of entering and leaving vertices.\n\n    Attributes:\n        enter (model.Collection[Vertex]):\n             A collection of Vertex instances that represent the points where a\n            transition can be entered. If not specified, it defaults to None, indicating that there are no\n            specific enter points designated.\n        leave (model.Collection[Vertex]):\n             A collection of Vertex instances that represent the points where a\n            transition can be exited. Similar to `enter`, it defaults to None, indicating that there are no\n            specific leave points designated.\n            The TransitionPath is a part of the model that tracks the entry and exit points in a transition, which can\n            be particularly useful in state machines or workflow representations where the concept of transitions\n            between states or tasks is essential.\n\n    \"\"\"\n\n    enter: model.Collection[Vertex] = None\n    leave: model.Collection[Vertex] = None\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.ConcurrencyKind","title":"<code>ConcurrencyKind</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>An enumeration representing different concurrency models. This class is a specialized enumeration (derived from <code>str</code> and <code>Enum</code>) that outlines the various concurrency kinds or parallel execution models that can be used within a system or application. The ConcurrencyKind class provides a clear and standardized way to refer to these models with predefined constants.</p> <p>Attributes:</p> Name Type Description <code>threading</code> <code>str</code> <p>Represents a concurrency model that uses threads for concurrent execution. Threads run in the same memory space but execute independently.</p> <code>multiprocessing</code> <code>str</code> <p>Denotes a concurrency model that leverages multiple processes for parallel execution. Processes run in separate memory spaces and communicate via IPC (Inter-Process Communication).</p> <code>asynchronous</code> <code>str</code> <p>Indicates an event-driven concurrency model where the workflow is orchestrated around the availability of tasks to perform operations without necessarily blocking other tasks.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class ConcurrencyKind(str, Enum):\n    \"\"\"\n    An enumeration representing different concurrency models.\n    This class is a specialized enumeration (derived from `str` and `Enum`) that\n    outlines the various concurrency kinds or parallel execution models that can be\n    used within a system or application. The ConcurrencyKind class provides\n    a clear and standardized way to refer to these models with predefined\n    constants.\n\n    Attributes:\n        threading (str):\n             Represents a concurrency model that uses threads for\n            concurrent execution. Threads run in the same memory space but execute\n            independently.\n        multiprocessing (str):\n             Denotes a concurrency model that leverages multiple\n            processes for parallel execution. Processes run in separate memory spaces\n            and communicate via IPC (Inter-Process Communication).\n        asynchronous (str):\n             Indicates an event-driven concurrency model where\n            the workflow is orchestrated around the availability of tasks to\n            perform operations without necessarily blocking other tasks.\n\n    \"\"\"\n\n    threading = \"threaded\"\n    multiprocessing = \"multiprocessing\"\n    asynchronous = \"asynchronous\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.EntryKind","title":"<code>EntryKind</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration to distinguish between different types of entry kinds. This class is a subclass of Enum and provides two types of Entry Kinds: - <code>default</code>: Represents a default entry kind. - <code>explicit</code>: Represents an explicit entry kind.</p> <p>Attributes:</p> Name Type Description <code>default</code> <code>str</code> <p>A class variable for the default entry kind.</p> <code>explicit</code> <code>str</code> <p>A class variable for the explicit entry kind.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class EntryKind(Enum):\n    \"\"\"\n    An enumeration to distinguish between different types of entry kinds.\n    This class is a subclass of Enum and provides two types of Entry Kinds:\n    - `default`: Represents a default entry kind.\n    - `explicit`: Represents an explicit entry kind.\n\n    Attributes:\n        default (str):\n             A class variable for the default entry kind.\n        explicit (str):\n             A class variable for the explicit entry kind.\n\n    \"\"\"\n\n    default = \"default\"\n    explicit = \"explicit\"\n</code></pre>"},{"location":"Python/API/Core/Elements/#stateforward.core.elements.ChangeEvent","title":"<code>ChangeEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class that represents an event signaling a change based on a specified condition.</p> <p>Attributes:</p> Name Type Description <code>condition</code> <code>ConditionType</code> <p>An optional attribute representing the condition under which the change event is triggered.</p> <code>expr</code> <code>Callable[[Event], bool]</code> <p>An optional callable that takes an 'Event' object as input and returns a boolean value indicating whether the change event condition is met.</p> Source code in <code>stateforward/core/elements.py</code> <pre><code>class ChangeEvent(Event):\n    \"\"\"\n    A class that represents an event signaling a change based on a specified condition.\n\n    Attributes:\n        condition (ConditionType):\n             An optional attribute representing the condition under which the change event is triggered.\n        expr (Callable[['Event'], bool]):\n             An optional callable that takes an 'Event' object as input and returns a boolean value indicating whether the change event condition is met.\n\n    \"\"\"\n\n    condition: ConditionType = None\n    expr: Callable[[\"Event\"], bool] = None\n</code></pre>"},{"location":"Python/API/Core/Functional/","title":"Functional","text":"<p>Module <code>functional</code> provides a set of functions to create various state machine components such as initial states, transitions, constraints, behaviors, events, and composite structures like forks, joins, and choices. </p> <p>The module uses a custom model building framework, which applies a functional approach to define the behavior of various elements in a state machine. This approach enables flexible construction and validation of state machine configurations.</p> <p>Each function is designed to construct a specific type of element, such as a state, an event, a transition, etc., and returns an instance of the corresponding element type. These elements can be assembled to form complex state machine behaviors. Optional parameters allow for customization of these elements, such as specifying entry and exit behaviors for states, conditions for transitions, or timing for time-based events.</p> <p>The use of Python's typing module ensures that the functions' arguments and return types are well-documented, enhancing code readability and maintenance.</p> <p>Key functions in the module:</p> <ul> <li><code>initial</code>: Create an initial pseudo-state with an optional effect.</li> <li><code>transition</code>: Create a transition between source and target states, with optional events, guards, and effects.</li> <li><code>constraint</code>: Define a constraint function to act as a guard for transitions.</li> <li><code>behavior</code>: Define a behavior function to be invoked on state entry, exit, or during an activity.</li> <li><code>event</code>: Create an event that can trigger transitions.</li> <li><code>after</code>: Create a time event that triggers after a specified delay.</li> <li><code>at</code>: Create a time event that triggers at a specific datetime.</li> <li><code>when</code>: Create a change event based on a custom expression.</li> <li><code>join</code>: Create a join pseudo-state to merge multiple incoming transitions.</li> <li><code>fork</code>: Create a fork pseudo-state to split behavior into multiple concurrent paths.</li> <li><code>choice</code>: Create a choice pseudo-state to conditionally trigger different transitions.</li> <li><code>simple_state</code>: Define a simple state element with associated entry, exit, or ongoing activity behaviors.</li> <li><code>entry_point</code>: Create a designated start point for a region within a state machine.</li> <li><code>exit_point</code>: Create a designated exit point for a state machine region.</li> <li><code>final_state</code>: Create a final state to represent the completion of the state machine or a region within it.</li> </ul> <p>The module allows for significant customization of state machine elements, making it a powerful tool for modeling a variety of behaviors.</p>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.after","title":"<code>after(hours=0.0, minutes=0.0, seconds=0.0, milliseconds=0.0, microseconds=0.0, days=0.0, when=None)</code>","text":"<p>Creates a new <code>TimeEvent</code> type that triggers after a specified time duration or when a certain condition is met. This function facilitates the creation of time-based events. The event is triggered after the cumulative time specified by hours, minutes, seconds, milliseconds, and microseconds parameters, or on the condition defined by the <code>when</code> callable. If <code>when</code> is provided, it overrides the time-based parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>float</code> <p>The number of hours to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>minutes</code> <code>float</code> <p>The number of minutes to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>seconds</code> <code>float</code> <p>The number of seconds to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>milliseconds</code> <code>float</code> <p>The number of milliseconds to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>microseconds</code> <code>float</code> <p>The number of microseconds to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>days</code> <code>float</code> <p>The number of days to wait before the event triggers. Default is 0.0.</p> <code>0.0</code> <code>when</code> <code>Callable[[TimeEvent], bool]</code> <p>A callable that returns a boolean value. The event is triggered when this callable returns <code>True</code>. If provided, it takes precedence over the time parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>type[TimeEvent]</code> <p>type[core.TimeEvent]:  A new subclass of <code>core.TimeEvent</code> that represents the event configured to trigger after the specified time or when the <code>when</code> condition is met.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def after(\n    hours: float = 0.0,\n    minutes: float = 0.0,\n    seconds: float = 0.0,\n    milliseconds: float = 0.0,\n    microseconds=0.0,\n    days=0.0,\n    when: Callable[[core.TimeEvent], bool] = None,\n) -&gt; type[core.TimeEvent]:\n    \"\"\"\n    Creates a new `TimeEvent` type that triggers after a specified time duration or when a certain condition is met.\n    This function facilitates the creation of time-based events. The event is triggered after the cumulative\n    time specified by hours, minutes, seconds, milliseconds, and microseconds parameters, or on the condition\n    defined by the `when` callable. If `when` is provided, it overrides the time-based parameters.\n\n    Args:\n        hours (float, optional):\n             The number of hours to wait before the event triggers. Default is 0.0.\n        minutes (float, optional):\n             The number of minutes to wait before the event triggers. Default is 0.0.\n        seconds (float, optional):\n             The number of seconds to wait before the event triggers. Default is 0.0.\n        milliseconds (float, optional):\n             The number of milliseconds to wait before the event triggers. Default is 0.0.\n        microseconds (float, optional):\n             The number of microseconds to wait before the event triggers. Default is 0.0.\n        days (float, optional):\n             The number of days to wait before the event triggers. Default is 0.0.\n        when (Callable[[core.TimeEvent], bool], optional):\n             A callable that returns a boolean value. The event\n            is triggered when this callable returns `True`. If provided, it takes precedence over the time\n            parameters.\n\n    Returns:\n        type[core.TimeEvent]:\n             A new subclass of `core.TimeEvent` that represents the event configured\n            to trigger after the specified time or when the `when` condition is met.\n\n    \"\"\"\n    if when is None:\n        when = timedelta(\n            hours=hours,\n            minutes=minutes,\n            seconds=seconds,\n            milliseconds=milliseconds,\n            microseconds=microseconds,\n            days=days,\n        )\n        name = f\"after&lt;{when}&gt;\"\n    else:\n        name = f\"after&lt;{getattr(when, '__name__', repr(when))}&gt;\"\n    return model.element.new(\n        name,\n        (core.TimeEvent,),\n        when=when,\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.at","title":"<code>at(iso_or_year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, when=None)</code>","text":"<p>Creates a new TimeEvent model element with a specific timestamp. This function can take either an ISO-formatted date string or individual date and time components to create the timestamp. An additional 'when' parameter can be used to pass an existing datetime object directly.</p> <p>Parameters:</p> Name Type Description Default <code>iso_or_year</code> <code>Union[str, int]</code> <p>An ISO-formatted date string or the year component of the date.</p> required <code>month</code> <code>int</code> <p>The month component of the date. Required if the first argument is a year.</p> required <code>day</code> <code>int</code> <p>The day component of the date. Required if the first argument is a year.</p> required <code>hour</code> <code>int</code> <p>The hour component of the time. Defaults to 0.</p> <code>0</code> <code>minute</code> <code>int</code> <p>The minute component of the time. Defaults to 0.</p> <code>0</code> <code>second</code> <code>int</code> <p>The second component of the time. Defaults to 0.</p> <code>0</code> <code>microsecond</code> <code>int</code> <p>The microsecond component of the time. Defaults to 0.</p> <code>0</code> <code>tzinfo</code> <code>timezone</code> <p>The timezone information. Defaults to None.</p> <code>None</code> <code>when</code> <code>datetime</code> <p>An existing datetime object. If provided, other parameters are ignored. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>element.Element:  A TimeEvent model element initialized with the specified timestamp.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def at(\n    iso_or_year,\n    month,\n    day,\n    hour=0,\n    minute=0,\n    second=0,\n    microsecond=0,\n    tzinfo=None,\n    when=None,\n):\n    \"\"\"\n    Creates a new TimeEvent model element with a specific timestamp.\n    This function can take either an ISO-formatted date string or individual date and time components to create the timestamp. An additional 'when' parameter can be used to pass an existing datetime object directly.\n\n    Args:\n        iso_or_year (Union[str, int]):\n             An ISO-formatted date string or the year component of the date.\n        month (int):\n             The month component of the date. Required if the first argument is a year.\n        day (int):\n             The day component of the date. Required if the first argument is a year.\n        hour (int, optional):\n             The hour component of the time. Defaults to 0.\n        minute (int, optional):\n             The minute component of the time. Defaults to 0.\n        second (int, optional):\n             The second component of the time. Defaults to 0.\n        microsecond (int, optional):\n             The microsecond component of the time. Defaults to 0.\n        tzinfo (timezone, optional):\n             The timezone information. Defaults to None.\n        when (datetime, optional):\n             An existing datetime object. If provided, other parameters are ignored. Defaults to None.\n\n    Returns:\n        element.Element:\n             A TimeEvent model element initialized with the specified timestamp.\n\n    \"\"\"\n    if when is None:\n        if isinstance(iso_or_year, str):\n            when = datetime.fromisoformat(iso_or_year)\n        else:\n            when = datetime(\n                iso_or_year, month, day, hour, minute, second, microsecond, tzinfo\n            )\n    return model.element.new(\"at\", (core.TimeEvent,), when=when)\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.behavior","title":"<code>behavior(decorated, name=None, type=core.Behavior)</code>","text":"<p>Creates a new <code>core.Constraint</code> subclass that is associated with a specific behavior function. This function creates a new class based on a provided behavior function and optionally a specific name and type. The new class is a subclass of <code>core.Constraint</code> and is constructed using the <code>model.element.new</code> function with additional specifications such as the behavior function and a generated name if not explicitly provided.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[Behavior, Event], bool]</code> <p>The behavior function that is to be associated with the new constraint subclass. It should accept a <code>core.Behavior</code> instance and a <code>core.Event</code> instance, returning a boolean based on the specified condition.</p> required <code>name</code> <code>Optional[str]</code> <p>An optional name for the new constraint subclass. If not given, a name is generated based on the <code>decorated</code> function's name.</p> <code>None</code> <code>type</code> <code>type[Behavior]</code> <p>The type of the behavior that will be the base for the new subclass. Defaults to <code>core.Behavior</code> if not provided.</p> <code>Behavior</code> <p>Returns:</p> Type Description <code>type[Constraint]</code> <p>type[core.Constraint]:  A new subclass of <code>core.Constraint</code> that has been associated with the specified behavior function.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def behavior(\n    decorated: Callable[[core.Behavior, core.Event], bool],\n    name: Optional[str] = None,\n    type: type[core.Behavior] = core.Behavior,\n) -&gt; type[core.Constraint]:\n    \"\"\"\n    Creates a new `core.Constraint` subclass that is associated with a specific behavior function.\n    This function creates a new class based on a provided behavior function and optionally a specific name and type. The new class is a subclass of `core.Constraint` and is constructed using the `model.element.new` function with additional specifications such as the behavior function and a generated name if not explicitly provided.\n\n    Args:\n        decorated (Callable[[core.Behavior, core.Event], bool]):\n             The behavior function that is to be associated with the new constraint subclass.\n            It should accept a `core.Behavior` instance and a `core.Event` instance, returning a boolean based on the specified condition.\n        name (Optional[str]):\n             An optional name for the new constraint subclass. If not given, a name is generated based on the\n            `decorated` function's name.\n        type (type[core.Behavior]):\n             The type of the behavior that will be the base for the new subclass. Defaults to\n            `core.Behavior` if not provided.\n\n    Returns:\n        type[core.Constraint]:\n             A new subclass of `core.Constraint` that has been associated with the specified behavior function.\n\n    \"\"\"\n    return model.element.new(\n        name or f\"behavior_{getattr(decorated, '__name__', repr(decorated))}\",\n        (type,),\n        activity=decorated,\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.choice","title":"<code>choice(*transitions, name=None)</code>","text":"<p>Creates a new Choice model element with optional transitions. This function creates a new Choice model element, which represents a point in the workflow where one among multiple transitions can be taken. It allows for the dynamic specification of transitions as part of the construct, with the option to provide a name for the choice element.</p> <p>Parameters:</p> Name Type Description Default <code>*transitions</code> <code>Sequence[type[Transition]]</code> <p>A variable number of transition sequences that represents outgoing transitions from the choice element.</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>An optional name for the choice element. If not provided, a default name 'choice' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>type[Choice]</code> <p>type['core.Choice']:  A new Choice model element with specified outgoing transitions.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def choice(\n    *transitions: Sequence[type[core.Transition]],\n    name=None,\n) -&gt; type[\"core.Choice\"]:\n    # for enumerate, transition in transitions:\n    #     transiiton.name = f\"choice_{enumerate}\"\n    \"\"\"\n    Creates a new Choice model element with optional transitions.\n    This function creates a new Choice model element, which represents a point in the workflow where\n    one among multiple transitions can be taken. It allows for the dynamic specification of transitions\n    as part of the construct, with the option to provide a name for the choice element.\n\n    Args:\n        *transitions (Sequence[type[core.Transition]]):\n             A variable number of transition sequences that\n            represents outgoing transitions from the choice element.\n        name (Optional[str]):\n             An optional name for the choice element. If not provided, a default name\n            'choice' is used.\n\n    Returns:\n        type['core.Choice']:\n             A new Choice model element with specified outgoing transitions.\n\n    \"\"\"\n    \"\"\"\n    Creates a new 'Choice' element with the given transitions and name.\n\n    Args:\n\n        *transitions (Sequence[type[core.Transition]]):\n             A variable number of transition sequences to be included as outgoing transitions for the choice element.\n\n        name (Optional[str]):\n             An optional name for the choice element. If not provided, 'choice' is used as the default name.\n\n    Returns:\n\n        type['core.Choice']:\n             A new Choice element with the specified outgoing transitions and name.\n\n    \"\"\"\n    \"\"\"\n    Creates a new instance of the 'core.Choice' class with outgoing transitions.\n\n    Args:\n        *transitions (Sequence[type[core.Transition]]):\n            A variable number of sequences where each sequence contains\n            'core.Transition' type elements to be used as outgoing transitions for the choice element.\n            name (Optional[str], None):\n            An optional name for the new choice element. If not provided, 'choice' will be used as the default name.\n            Returns:\n            type['core.Choice']:\n            A new instance of the 'core.Choice' class with the specified outgoing transitions.\n\n    \"\"\"\n    \"\"\"\n    Creates a new Choice element with a given name and a sequence of transitions.\n    This function constructs a new Choice element, which is typically used in state machine models to\n    represent a decision point where the outcome is determined by conditions on the transitions.\n    It allows for the dynamic arrangement of the transitions that can be taken from this choice point.\n\n    Args:\n        *transitions (Sequence[type[core.Transition]]):\n            A sequence of Transition class references that\n            are potential outgoing transitions from the new Choice element.\n            name (Optional[str]):\n            An optional name for the new Choice element. If no name is provided, the\n            default name 'choice' will be used.\n\n    Returns:\n        type['core.Choice']:\n            A new Choice element with the specified outgoing transitions and name.\n\n\n    \"\"\"\n    \"\"\"\n    Creates a new choice element with given transitions.\n\n    The function dynamically creates a new choice element, which is a type of core.Choice. It allows one to specify multiple transition elements that act as outgoing connections from this choice. An optional name can be provided; if not specified, the choice element will have the default name 'choice'.\n\n    Args:\n    *transitions (Sequence[type[core.Transition]]): A variable number of transition elements that will be associated with the choice element as outgoing connections.\n    name (Optional[str]): An optional name for the choice element. If not specified, defaults to 'choice'.\n\n    Returns:\n    type['core.Choice']: A new choice element configured with the given transitions and name.\n\n    \"\"\"\n    \"\"\"\nCreates a new Choice element with the given transitions.\n\nThis function generates a new Choice element, optionally with a specified name, and\n    sets up the outgoing transitions provided. If no name is given, it defaults to 'choice'.\n\nArgs:\n*transitions (Sequence[type[core.Transition]]): A variable number of transition sequences.\nEach transition is of the type specified by core.Transition or a subclass of it.\n        name (Optional[str]): An optional name for the Choice element. If not provided, defaults to 'choice'.\n\nReturns:\ntype['core.Choice']: The newly created Choice element with the specified transitions.\n\n    \"\"\"\n    \"\"\"\n    Creates a new Choice element with specified transitions and an optional name.\n\n    This function constructs a Choice element, which is a part of a state machine model. The Choice element\n    represents a decision point where one of several transition options can be taken based on\n    some condition. The function allows for a variable number of transitions to be passed as\n    arguments, and an optional name to be associated with the Choice element.\n\n    Args:\n    *transitions (Sequence[type[core.Transition]]): A variable number of transition elements\n    indicating the possible paths that can be taken from this choice point.\n    name (Optional[str]): An optional name given to the Choice element for identification. If no\n    name is provided, a default name 'choice' will be used.\n\n    Returns:\n    type['core.Choice']: A new Choice element initialized with the provided transitions and\n    the given or default name.\n\n    \"\"\"\n    \"\"\"\n        Creates a new choice element in a model with given transitions.\n        The function creates a new choice element, which is typically used in\n        modeling decision points with multiple possible outcomes. It can be given\n        a name and a sequence of transitions that serve as outgoing paths from\n        the choice element.\n        Args:\n            *transitions (Sequence[type[core.Transition]]): A sequence of\n                `core.Transition` type elements that will be used as outgoing\n                transitions for the choice element.\n            name (Optional[str]): An optional name for the choice element. If no\n                name is provided, 'choice' will be used as the default name.\n        Returns:\n            type['core.Choice']: A new choice element with the specified outgoing\n                transitions and name.\n    \"\"\"\n    \"\"\"\n    Creates a new core.Choice element with a name and a sequence of transitions.\n        The function constructs a new core.Choice element, which is a model element used to\n        represent a point in a process where one among several transitions can be taken.\n        Args:\n            *transitions (Sequence[type[core.Transition]]): A variable number of Transition objects\n                that can potentially be taken from this choice point.\n            name (Optional[str]): An optional name for the core.Choice element. If no name is provided,\n                a default name 'choice' is used.\n        Returns:\n            type['core.Choice']: A new instance of core.Choice, which is a subclass of\n                the provided transitions, with the specified name and outgoing transitions.\n        Raises:\n            TypeError: If any of the provided transitions are not of type core.Transition.\n    \"\"\"\n    \"\"\"\n    Creates a new Choice model element with specified transitions and an optional name.\n    Args:\n        *transitions (Sequence[type[elements.Transition]]): A variable number of Transition sequences to be associated with the Choice.\n        name (Optional[str], optional): An optional name for the Choice element. If not provided, 'choice' is used as a default name.\n    Returns:\n        type['core.Choice']: A new instance of the core.Choice class with the provided transitions.\n    \"\"\"\n    return model.element.new(\n        name or \"choice\", (core.Choice,), outgoing=model.collection(*transitions)\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.constraint","title":"<code>constraint(decorated, type=core.Constraint)</code>","text":"<p>Creates a new constraint subclass with a specific condition. This function dynamically creates a new subclass of a constraint with a provided condition function. The new subclass is named based on the decorated function's name, and it includes the condition as its key behavior.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[[Constraint, Event], bool]</code> <p>A callable that represents the condition function. This function should accept a <code>core.Constraint</code> object and a <code>core.Event</code> object as parameters and return a boolean value indicating whether the constraint's condition is satisfied.</p> required <code>type</code> <code>type[Constraint]</code> <p>The base class from which the new subclass will inherit. Defaults to 'core.Constraint', indicating that the new subclass will be a direct subclass of 'core.Constraint'.</p> <code>Constraint</code> <p>Returns:</p> Type Description <code>type[Constraint]</code> <p>type[core.Constraint]:  A new subclass of the specified 'type' with the 'decorated' function as a condition.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def constraint(\n    decorated: Callable[[core.Constraint, core.Event], bool],\n    type: type[core.Constraint] = core.Constraint,\n) -&gt; type[core.Constraint]:\n    \"\"\"\n    Creates a new constraint subclass with a specific condition.\n    This function dynamically creates a new subclass of a constraint with a provided condition function. The new subclass\n    is named based on the decorated function's name, and it includes the condition as its key behavior.\n\n    Args:\n        decorated (Callable[[core.Constraint, core.Event], bool]):\n             A callable that represents the condition function.\n            This function should accept a `core.Constraint` object and a `core.Event` object as parameters and return a\n            boolean value indicating whether the constraint's condition is satisfied.\n        type (type[core.Constraint], optional):\n             The base class from which the new subclass will inherit.\n            Defaults to 'core.Constraint', indicating that the new subclass will be a direct subclass of 'core.Constraint'.\n\n    Returns:\n        type[core.Constraint]:\n             A new subclass of the specified 'type' with the 'decorated' function as a condition.\n\n    \"\"\"\n    return model.element.new(\n        f\"constraint_{getattr(decorated, '__name__', repr(decorated))}\",\n        (type,),\n        condition=decorated,\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.entry_point","title":"<code>entry_point(*transitions, name=None)</code>","text":"<p>Creates a new entry point state in a state machine model. This function constructs a new state object that acts as an entry point in the state machine. It aggregates outgoing transitions from the entry point and optionally allows naming the entry point state for identification.</p> <p>Parameters:</p> Name Type Description Default <code>*transitions</code> <code>Sequence[type[Transition]]</code> <p>A sequence of transition types that will originate from the new entry point. These transitions define the possible next states from the entry point.</p> <code>()</code> <code>name</code> <code>str</code> <p>An optional name for the entry point state. If no name is provided, it defaults to the string 'entry_point'.</p> <code>None</code> <p>Returns:</p> Type Description <code>type[State]</code> <p>type[core.State]:  A new state object that represents the entry point in the state machine. It is a subclass of core.State, possibly with additional characteristics inherent to core.EntryPoint class.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def entry_point(\n    *transitions: Sequence[type[core.Transition]],\n    name: str = None,\n) -&gt; type[core.State]:\n    \"\"\"\n    Creates a new entry point state in a state machine model.\n    This function constructs a new state object that acts as an entry point in the state machine. It aggregates outgoing transitions from the entry point and optionally allows naming the entry point state for identification.\n\n    Args:\n        *transitions (Sequence[type[core.Transition]]):\n             A sequence of transition types that will originate from the new entry point. These transitions define the possible next states from the entry point.\n        name (str, optional):\n             An optional name for the entry point state. If no name is provided, it defaults to the string 'entry_point'.\n\n    Returns:\n        type[core.State]:\n             A new state object that represents the entry point in the state machine. It is a subclass of core.State, possibly with additional characteristics inherent to core.EntryPoint class.\n\n    \"\"\"\n    return model.element.new(\n        name or \"entry_point\",\n        (core.EntryPoint,),\n        outgoing=model.collection(*transitions),\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.event","title":"<code>event(name)</code>","text":"<p>Creates a new event type with the given name. This function dynamically generates a new event type derived from the <code>core.Event</code> base class, using the provided name. The type is created using the <code>model.element.new</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the event type to be created.</p> required <p>Returns:</p> Type Description <code>type[Event]</code> <p>type[core.Event]:  A new event type subclassing <code>core.Event</code> with the given name.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def event(name: str) -&gt; type[core.Event]:\n    \"\"\"\n    Creates a new event type with the given name.\n    This function dynamically generates a new event type derived from the `core.Event` base class,\n    using the provided name. The type is created using the `model.element.new` factory function.\n\n    Args:\n        name (str):\n             The name of the event type to be created.\n\n    Returns:\n        type[core.Event]:\n             A new event type subclassing `core.Event` with the given name.\n\n    \"\"\"\n    return model.element.new(name, (core.Event,))\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.exit_point","title":"<code>exit_point(name=None)</code>","text":"<p>Creates a new instance of ExitPoint within the model. The function is intended to create a new element of type ExitPoint in the model, with an optional name provided. If no name is given, it uses 'exit_point' as the default name. The new instance is created as a subtype of core.State.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to be assigned to the new ExitPoint. Defaults to None, and if not provided, 'exit_point' is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>type[State]</code> <p>type[core.State]:  A new instance of ExitPoint which is a subtype of core.State.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def exit_point(\n    name: str = None,\n) -&gt; type[core.State]:\n    \"\"\"\n    Creates a new instance of ExitPoint within the model.\n    The function is intended to create a new element of type ExitPoint in the model, with an optional name provided.\n    If no name is given, it uses 'exit_point' as the default name. The new instance is created as a subtype of core.State.\n\n    Args:\n        name (str, optional):\n             The name to be assigned to the new ExitPoint. Defaults to None, and if not provided, 'exit_point' is used.\n\n    Returns:\n        type[core.State]:\n             A new instance of ExitPoint which is a subtype of core.State.\n\n    \"\"\"\n    return model.element.new(\n        name or \"exit_point\",\n        (core.ExitPoint,),\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.final_state","title":"<code>final_state()</code>","text":"<p>Creates a new 'final' element that is an instance of core.FinalState.</p> <p>Returns:</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def final_state():\n    \"\"\"\n    Creates a new 'final' element that is an instance of core.FinalState.\n\n    Returns:\n\n    \"\"\"\n    return model.element.new(\"final\", (core.FinalState,))\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.fork","title":"<code>fork(*outgoing, name=None)</code>","text":"<p>Creates a new <code>core.Fork</code> element with the specified outgoing transitions and name. This factory function constructs a new <code>core.Fork</code> instance that inherits from a collection of outgoing <code>core.Transition</code> types. If a name is provided, it sets the name of the new <code>core.Fork</code> element; otherwise, it assigns a default name 'fork'.</p> <p>Parameters:</p> Name Type Description Default <code>*outgoing</code> <code>Sequence[type[Transition]]</code> <p>A variable number of <code>core.Transition</code> types that will be the outgoing transitions for the fork.</p> <code>()</code> <code>name</code> <code>str</code> <p>The name to assign to the new <code>core.Fork</code> element. If unspecified, the name defaults to 'fork'.</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[Fork]</code> <p>Type[core.Fork]:  A new <code>core.Fork</code> instance with the specified outgoing transitions and name.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def fork(\n    *outgoing: Sequence[type[core.Transition]], name: str = None\n) -&gt; Type[core.Fork]:\n    \"\"\"\n    Creates a new `core.Fork` element with the specified outgoing transitions and name.\n    This factory function constructs a new `core.Fork` instance that inherits from a\n    collection of outgoing `core.Transition` types. If a name is provided, it sets the\n    name of the new `core.Fork` element; otherwise, it assigns a default name 'fork'.\n\n    Args:\n        *outgoing (Sequence[type[core.Transition]]):\n             A variable number of `core.Transition` types\n            that will be the outgoing transitions for the fork.\n        name (str, optional):\n             The name to assign to the new `core.Fork` element. If unspecified,\n            the name defaults to 'fork'.\n\n    Returns:\n        Type[core.Fork]:\n             A new `core.Fork` instance with the specified outgoing transitions and name.\n\n    \"\"\"\n    return model.element.new(\n        name or \"fork\", (core.Fork,), outgoing=model.collection(*outgoing)\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.initial","title":"<code>initial(target, effect=None)</code>","text":"<p>Creates an initial state element with an optional effect that defines its transition behavior. This function creates an 'initial' element that represents the starting point for state transitions within a state machine model. The 'initial' element is an instance of 'core.Initial'. It may include an optional effect, which can either be a subclass of 'core.Behavior' or a callable that takes a 'core.Behavior' instance and a 'core.Event'. If the effect provided is not a subtype of 'core.Behavior', the function will create a new 'effect' element with the provided callable as its activity. The transition is then defined with the specified target state and effect, and this transition is set as an attribute of the 'initial' element.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type[Vertex]</code> <p>The state to which the transition occurs from this initial element.</p> required <code>effect</code> <code>Optional[Union[type[Behavior], Callable[[Behavior, Event], None]]]</code> <p>An optional behavior or callable that defines the effect of the transition.</p> <code>None</code> <p>Returns:</p> Type Description <code>type[Initial]</code> <p>type[core.Initial]:  A new 'initial' element instance representing the initial state of a state machine with the specified transition behavior.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def initial(\n    target: type[core.Vertex],\n    effect: Optional[\n        Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]]\n    ] = None,\n) -&gt; type[core.Initial]:\n    \"\"\"\n    Creates an initial state element with an optional effect that defines its transition behavior.\n    This function creates an 'initial' element that represents the starting point for state transitions within a state machine model. The 'initial' element is an instance of 'core.Initial'. It may include an optional effect, which can either be a subclass of 'core.Behavior' or a callable that takes a 'core.Behavior' instance and a 'core.Event'. If the effect provided is not a subtype of 'core.Behavior', the function will create a new 'effect' element with the provided callable as its activity. The transition is then defined with the specified target state and effect, and this transition is set as an attribute of the 'initial' element.\n\n    Args:\n        target (type[core.Vertex]):\n             The state to which the transition occurs from this initial element.\n        effect (Optional[Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]]]):\n             An optional behavior or callable that defines the effect of the transition.\n\n    Returns:\n        type[core.Initial]:\n             A new 'initial' element instance representing the initial state of a state machine with the specified transition behavior.\n\n    \"\"\"\n    element = model.element.new(\"initial\", (core.Initial,))\n    if not model.element.is_subtype(effect, core.Behavior):\n        effect = model.element.new(\"effect\", bases=(core.Behavior,), activity=effect)\n    model.set_attribute(\n        element,\n        \"transition\",\n        transition(target=target, effect=effect),\n    )\n    return element\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.join","title":"<code>join(target, effect=None, guard=None)</code>","text":"<p>Generates a new Join element and creates a transition to the specified target Vertex. This function instantiates a new Join element within the model and associates it with a transition. The transition is directed towards the given target Vertex, and can optionally include an effect and a guard. The newly created Join element is then returned.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type[Vertex]</code> <p>The target Vertex for the transition originating from the join.</p> required <code>effect</code> <code>optional</code> <p>The effect to be triggered by the transition. Defaults to None.</p> <code>None</code> <code>guard</code> <code>optional</code> <p>The guard condition that must be true for the transition to trigger. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[Join]</code> <p>Type[core.Join]:  The newly created Join element associated with the modeled transition.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def join(\n    target: type[core.Vertex],\n    effect=None,\n    guard=None,\n) -&gt; Type[core.Join]:\n    \"\"\"\n    Generates a new Join element and creates a transition to the specified target Vertex.\n    This function instantiates a new Join element within the model and associates it with a transition. The transition is\n    directed towards the given target Vertex, and can optionally include an effect and a guard. The newly\n    created Join element is then returned.\n\n    Args:\n        target (type[core.Vertex]):\n             The target Vertex for the transition originating from the join.\n        effect (optional):\n             The effect to be triggered by the transition. Defaults to None.\n        guard (optional):\n             The guard condition that must be true for the transition to trigger. Defaults to None.\n\n    Returns:\n        Type[core.Join]:\n             The newly created Join element associated with the modeled transition.\n\n    \"\"\"\n    join_element = model.element.new(\"join\", (core.Join,))\n    model.add_owned_element_to(\n        join_element,\n        transition(target=target, source=join_element, effect=effect, guard=guard),\n    )\n    return join_element\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.simple_state","title":"<code>simple_state(name, entry=None, exit=None, activity=None)</code>","text":"<p>Creates a simple state with optional entry, exit, and activity behaviors. A convenience function that simplifies the creation of a state object with optional behaviors for entry, exit, and activity. If the provided entry, exit, and activity are not already subtypes of <code>core.Behavior</code>, they are converted using the <code>behavior</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the state.</p> required <code>entry</code> <code>Union[type[Behavior], Callable[[Behavior, Event], None]]</code> <p>The entry behavior for the state. Can be a subclass of <code>core.Behavior</code> or a callable. Defaults to None, indicating no entry behavior.</p> <code>None</code> <code>exit</code> <code>Union[type[Behavior], Callable[[Behavior, Event], None]]</code> <p>The exit behavior for the state. Can be a subclass of <code>core.Behavior</code> or a callable. Defaults to None, indicating no exit behavior.</p> <code>None</code> <code>activity</code> <code>Union[type[Behavior], Callable[[Behavior, Event], None]]</code> <p>The activity behavior for the state. Can be a subclass of <code>core.Behavior</code> or a callable. Defaults to None, indicating no activity behavior.</p> <code>None</code> <p>Returns:</p> Type Description <p>type[core.State]:  A new state object of type <code>core.State</code> with the specified entry, exit, and activity behaviors.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def simple_state(\n    name: str,\n    entry: Union[\n        type[core.Behavior], Callable[[core.Behavior, core.Event], None]\n    ] = None,\n    exit: Union[\n        type[core.Behavior], Callable[[core.Behavior, core.Event], None]\n    ] = None,\n    activity: Union[\n        type[core.Behavior], Callable[[core.Behavior, core.Event], None]\n    ] = None,\n):\n    \"\"\"\n    Creates a simple state with optional entry, exit, and activity behaviors.\n    A convenience function that simplifies the creation of a state object with optional behaviors for entry, exit, and activity. If the provided entry, exit, and activity are not already subtypes of `core.Behavior`, they are converted using the `behavior` function.\n\n    Args:\n        name (str):\n             The name of the state.\n        entry (Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]], optional):\n             The entry behavior for the state. Can be a subclass of `core.Behavior` or a callable.\n            Defaults to None, indicating no entry behavior.\n        exit (Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]], optional):\n             The exit behavior for the state. Can be a subclass of `core.Behavior` or a callable.\n            Defaults to None, indicating no exit behavior.\n        activity (Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]], optional):\n             The activity behavior for the state. Can be a subclass of `core.Behavior` or a callable.\n            Defaults to None, indicating no activity behavior.\n\n    Returns:\n        type[core.State]:\n             A new state object of type `core.State` with the specified entry, exit, and activity behaviors.\n\n    \"\"\"\n    if not model.element.is_subtype(entry, core.Behavior):\n        entry = behavior(entry)\n    if not model.element.is_subtype(exit, core.Behavior):\n        exit = behavior(exit)\n    if not model.element.is_subtype(activity, core.Behavior):\n        activity = behavior(activity)\n    return model.element.new(\n        name,\n        (core.State,),\n        entry=entry,\n        exit=exit,\n        activity=activity,\n    )\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.transition","title":"<code>transition(event=None, target=None, source=None, guard=None, effect=None, type=core.Transition, name=None)</code>","text":"<p>Creates a new Transition element based on the provided parameters. This function generates a transition in a model, which can be defined with or without an event, and with optional guard and effect functions. It is capable of creating multiple transitions if presented with a list or sequence of source vertices.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Union[type[Event], Sequence[type[Event]]]</code> <p>The event or events that trigger the transition.</p> <code>None</code> <code>target</code> <code>type[Vertex]</code> <p>The vertex where the transition leads to.</p> <code>None</code> <code>source</code> <code>Union[Sequence[type[Vertex]], type[Vertex]]</code> <p>The source vertex or vertices from where the transition originates.</p> <code>None</code> <code>guard</code> <code>Union[Callable[[Constraint, Event], bool], type[Constraint]]</code> <p>A callable or Constraint that serves as the condition for the transition to occur.</p> <code>None</code> <code>effect</code> <code>Union[type[Behavior], Callable[[Behavior, Event], None]]</code> <p>A callable or Behavior that represents the action taken when the transition occurs.</p> <code>None</code> <code>type</code> <code>type[Transition]</code> <p>The type of the Transition element to create. Defaults to core.Transition.</p> <code>Transition</code> <code>name</code> <code>str</code> <p>The name of the transition. If not provided, a name is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[type[Transition], Sequence[type[Transition]]]</code> <p>Union[type[core.Transition], Sequence[type[core.Transition]]]:  A new Transition element or a sequence of Transition elements.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both 'source' and 'target' are None, this function raises a ValueError.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def transition(\n    event: Optional[Union[type[core.Event], Sequence[type[core.Event]]]] = None,\n    target: Optional[type[core.Vertex]] = None,\n    source: Union[Sequence[type[core.Vertex]], type[core.Vertex]] = None,\n    guard: Optional[\n        Union[\n            Callable[[core.Constraint, core.Event], bool],\n            type[core.Constraint],\n        ]\n    ] = None,\n    effect: Optional[\n        Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]]\n    ] = None,\n    type: type[core.Transition] = core.Transition,\n    name: str = None,\n) -&gt; Union[type[core.Transition], Sequence[type[core.Transition]]]:\n    \"\"\"\n    Creates a new Transition element based on the provided parameters.\n    This function generates a transition in a model, which can be defined with or without an event, and with optional guard and effect functions. It is capable of creating multiple transitions if presented with a list or sequence of source vertices.\n\n    Args:\n        event (Union[type[core.Event], Sequence[type[core.Event]]], optional):\n             The event or events that trigger the transition.\n        target (type[core.Vertex], optional):\n             The vertex where the transition leads to.\n        source (Union[Sequence[type[core.Vertex]], type[core.Vertex]], optional):\n             The source vertex or vertices from where the transition originates.\n        guard (Union[Callable[[core.Constraint, core.Event], bool], type[core.Constraint]], optional):\n             A callable or Constraint that serves as the condition for the transition to occur.\n        effect (Union[type[core.Behavior], Callable[[core.Behavior, core.Event], None]], optional):\n             A callable or Behavior that represents the action taken when the transition occurs.\n        type (type[core.Transition]):\n             The type of the Transition element to create. Defaults to core.Transition.\n        name (str, optional):\n             The name of the transition. If not provided, a name is generated.\n\n    Returns:\n        Union[type[core.Transition], Sequence[type[core.Transition]]]:\n             A new Transition element or a sequence of Transition elements.\n\n    Raises:\n        ValueError:\n             If both 'source' and 'target' are None, this function raises a ValueError.\n\n    \"\"\"\n    if isinstance(source, (list, tuple)):\n        return model.collection(\n            *(transition(event, target, _source, guard, effect) for _source in source)\n        )\n    elif source is not None and target is not None:\n        # source = model.association(source)\n        # target = model.association(target)\n        if name is None:\n            name = f\"transition_from_{model.name_of(source)}_to_{model.name_of(target)}\"\n    elif target:\n        # target = model.association(target)\n        if name is None:\n            name = f\"transition_to_{model.name_of(target)}\"\n    elif source:\n        # source = model.association(source)\n        if name is None:\n            name = f\"transition_from_{model.name_of(source)}\"\n    else:\n        raise ValueError(\"source and target cannot both be None\")\n    if event is None:\n        events = None\n    else:\n        events = (\n            model.collection(*event)\n            if isinstance(event, (list, tuple))\n            else model.collection(event)\n        )\n    if guard is not None and not model.element.is_subtype(guard, core.Constraint):\n        guard = constraint(guard)\n    if effect is not None and not model.element.is_subtype(effect, core.Behavior):\n        effect = behavior(effect)\n    new_transition = model.element.new(\n        name,\n        (type,),\n        events=events,\n        target=target,  # don't take ownership of the target\n        source=source,  # don't take ownership of the source\n        guard=guard,\n        effect=effect,\n    )\n    return new_transition\n</code></pre>"},{"location":"Python/API/Core/Functional/#stateforward.core.functional.when","title":"<code>when(expr)</code>","text":"<p>Creates a new <code>ChangeEvent</code> subclass which is triggered based on a specified expression. This function dynamically creates a subclass of <code>ChangeEvent</code> with a unique name derived from the expression's name or its string representation if the expression lacks a <code>__name__</code> attribute. The created class is designed to be triggered when the given expression evaluates to true.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Callable[[Element], bool]</code> <p>A callable that takes an instance of <code>model.element.Element</code> as its only argument and returns a boolean value. The expression is used to evaluate whether the <code>ChangeEvent</code> should be triggered.</p> required <p>Returns:</p> Type Description <code>type[ChangeEvent]</code> <p>type[core.ChangeEvent]:  A new subclass of <code>core.ChangeEvent</code> that incorporates the provided expression for its triggering condition.</p> Source code in <code>stateforward/core/functional.py</code> <pre><code>def when(expr: Callable[[model.element.Element], bool]) -&gt; type[core.ChangeEvent]:\n    \"\"\"\n    Creates a new ``ChangeEvent`` subclass which is triggered based on a specified expression.\n    This function dynamically creates a subclass of ``ChangeEvent`` with a unique name derived from the\n    expression's name or its string representation if the expression lacks a ``__name__`` attribute. The\n    created class is designed to be triggered when the given expression evaluates to true.\n\n    Args:\n        expr (Callable[[model.element.Element], bool]):\n             A callable that takes an instance of\n            ``model.element.Element`` as its only argument and returns a boolean value. The expression is used to\n            evaluate whether the ``ChangeEvent`` should be triggered.\n\n    Returns:\n        type[core.ChangeEvent]:\n             A new subclass of ``core.ChangeEvent`` that incorporates the provided\n            expression for its triggering condition.\n\n    \"\"\"\n    name = f\"when&lt;{getattr(expr, '__name__', repr(expr))}&gt;\"\n    return model.element.new(name, (core.ChangeEvent,), expr=expr)\n</code></pre>"},{"location":"Python/API/Modelling/Association/","title":"Association","text":"<p>The <code>association</code> module defines utilities and types for managing associations through proxy mechanisms. The module's central feature is the <code>Association</code> type, which is a union of Annotated types using NewType to represent either a <code>CallableProxyType</code> or a <code>ProxyType</code>. </p> <p>This module also provides the function <code>is_association</code>, which checks if a given value is an instance of either <code>ProxyType</code> or <code>CallableProxyType</code>, and hence can be considered an association according to the module's definition.</p> <p>The <code>association</code> function within the module is responsible for creating an association to the passed element. If the given element is not already an association, it will be wrapped in a proxy using the <code>proxy</code> function from the <code>weakref</code> module. If it is an association, it is returned unchanged. This enables users to maintain and handle associations to objects that should not be strongly referenced while still allowing for the invocation of callable methods if available.</p> <p>The module also includes a <code>__get__</code> method, typically used for extending descriptor classes. This method aids in retrieving the association for a given instance, falling back to the class method's behavior if the instance is <code>None</code>. The use of this method is internally focused and supports the machinery of the association types.</p>"},{"location":"Python/API/Modelling/Association/#stateforward.model.association.Association","title":"<code>Association = Union[Annotated[T, NewType('Association', CallableProxyType)], Annotated[T, NewType('Association', ProxyType)]]</code>  <code>module-attribute</code>","text":""},{"location":"Python/API/Modelling/Association/#stateforward.model.association.association","title":"<code>association(element)</code>","text":"<p>Creates an association proxy object from a given element. If the element is not already an association proxy object, it will create a new proxy for it using the <code>proxy</code> function. If it is already an association proxy object, it simply returns the element as-is.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>T</code> <p>The element to be converted into or verified as an association proxy object.</p> required <p>Returns:</p> Type Description <code>Association[T]</code> <p>Association[T]:  An association proxy object for the given element.</p> Source code in <code>stateforward/model/association.py</code> <pre><code>def association(element: T) -&gt; Association[T]:\n    \"\"\"\n    Creates an association proxy object from a given element.\n    If the element is not already an association proxy object, it will create a new proxy for it using the `proxy` function. If it is already an association proxy object, it simply returns the element as-is.\n\n    Args:\n        element (T):\n             The element to be converted into or verified as an association proxy object.\n\n    Returns:\n        Association[T]:\n             An association proxy object for the given element.\n\n    \"\"\"\n    new_association = proxy(element) if not is_association(element) else element\n    return new_association\n</code></pre>"},{"location":"Python/API/Modelling/Association/#stateforward.model.association.is_association","title":"<code>is_association(value)</code>","text":"<p>Determines whether the provided value is an instance of <code>ProxyType</code> or <code>CallableProxyType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to be checked if it's an association proxy or callable proxy.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is an instance of <code>ProxyType</code> or <code>CallableProxyType</code>, otherwise False.</p> Source code in <code>stateforward/model/association.py</code> <pre><code>def is_association(value: Any) -&gt; bool:\n    \"\"\"\n    Determines whether the provided value is an instance of `ProxyType` or `CallableProxyType`.\n\n    Args:\n        value (Any):\n             The value to be checked if it's an association proxy or callable proxy.\n\n    Returns:\n        bool:\n             True if the value is an instance of `ProxyType` or `CallableProxyType`, otherwise False.\n\n    \"\"\"\n    return isinstance(value, (ProxyType, CallableProxyType))\n</code></pre>"},{"location":"Python/API/Modelling/Collection/","title":"Collection","text":"<p>The collection module is designed to manage collections of <code>Element</code> objects, providing a suite of functions and a base class to allow for the manipulation and iteration of these collections within an object-oriented framework. The module offers functionality to check if a given value is a collection, create collections, iterate over them, sort them, and extend them with new elements. It also defines the custom metaclass <code>CollectionMetaclass</code> and the <code>Collection</code> base class which are the core components that empower the structured management of collection elements.</p> <p>Key Components:</p> <ol> <li> <p><code>is_collection(value: typing.Any) -&gt; bool</code>: A function that checks if the passed value is an instance of a collection.</p> </li> <li> <p><code>collection(*elements: ElementType) -&gt; type['Collection']</code>: A factory function that creates a new collection type from the given elements and returns it.</p> </li> <li> <p><code>iter_collection(element: typing.Union[type['Collection[T]'], 'Collection[T]']) -&gt; typing.Generator[T, None, None]</code>: Creates a generator to iterate over the elements of the collection.</p> </li> <li> <p><code>sort_collection(element: type['Collection'], key=None, reverse=False)</code>: Sorts the elements of a collection in-place according to the specified key function and order.</p> </li> <li> <p><code>extend_collection(collection_element: 'CollectionType', *elements: typing.Collection[ElementType])</code>: Extends the given collection with additional elements.</p> </li> <li> <p><code>CollectionType</code>: A type alias that can represent either a 'Collection' class or instance.</p> </li> <li> <p><code>CollectionMetaclass(type)</code>: A metaclass for creating 'Collection' classes with additional class-level functionality like yielding its length and providing an iterator.</p> </li> <li> <p><code>Collection(Element[T], metaclass=CollectionMetaclass)</code>: A base class representing a collection of elements, which can be iterated over, indexed, and extended while retaining the ordering of elements.</p> </li> </ol> <p>Functionality like retrieving items from a collection, checking the number of items, or iterating through every element is encapsulated within the 'Collection' class and its associated metaclass, making it a versatile tool for managing groups of objects that inherit from Element. Overall, this module aims to provide a robust framework for handling collections with ease and efficiency.</p>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.Collection","title":"<code>Collection</code>","text":"<p>             Bases: <code>Element[T]</code></p> <p>A generic collection class that acts as an iterable container for elements of type T. This class inherits from the 'Element' class with a generic type parameter 'T' and uses a 'CollectionMetaclass'. It supports basic sequence protocols such as length retrieval, iteration, and item access by index. The generic type 'T' specifies the type of elements stored in the collection.</p> <p>Attributes:</p> Name Type Description <code>T</code> <p>A generic type parameter specifying the type of elements in the collection.</p> <p>Methods:</p> Name Description <code>__len__</code> <p>Returns the number of elements in the collection as per the class's 'length' attribute.</p> <code>__iter__</code> <p>Returns an iterator for the elements in the collection, making the class iterable.</p> <code>__getitem__</code> <p>int) -&gt; T: Retrieves an element from the collection by its integer index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the element to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <p>The element at the specified index in the collection.</p> <code>__class_getitem__</code> <code>(cls, item)</code> <p>A class method that allows access to class attributes using subscript notion if the attribute name is numeric. If the attribute name is not numeric, defers to the superclass's 'class_getitem' method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The attribute name or a numeric string representing the attribute to access.</p> required <p>Returns:</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>class Collection(Element[T], metaclass=CollectionMetaclass):\n    \"\"\"\n    A generic collection class that acts as an iterable container for elements of type T.\n    This class inherits from the 'Element' class with a generic type parameter 'T' and uses a 'CollectionMetaclass'. It supports basic\n    sequence protocols such as length retrieval, iteration, and item access by index. The generic type 'T' specifies the type\n    of elements stored in the collection.\n\n    Attributes:\n        T:\n             A generic type parameter specifying the type of elements in the collection.\n\n    Methods:\n        __len__(self) -&gt; int:\n            Returns the number of elements in the collection as per the class's 'length' attribute.\n        __iter__(self) -&gt; typing.Iterator[T]:\n            Returns an iterator for the elements in the collection, making the class iterable.\n        __getitem__(self, index:\n             int) -&gt; T:\n            Retrieves an element from the collection by its integer index.\n\n    Args:\n        index (int):\n             The index of the element to retrieve.\n\n    Returns:\n        T:\n             The element at the specified index in the collection.\n        __class_getitem__(cls, item):\n            A class method that allows access to class attributes using subscript notion if the attribute name is numeric.\n            If the attribute name is not numeric, defers to the superclass's '__class_getitem__' method.\n\n    Args:\n        item:\n             The attribute name or a numeric string representing the attribute to access.\n\n    Returns:\n\n    \"\"\"\n\n    def __len__(self):\n        \"\"\"\n\n        Returns the length of an object.\n\n        Returns:\n            int:\n                 The length of the object.\n\n        \"\"\"\n        return self.__class__.length\n\n    def __iter__(self) -&gt; typing.Iterator[T]:\n        \"\"\"\n        Iterates over a collection instance.\n        This method will return an iterator for the items in the collection by utilizing the `iter_collection` function.\n\n        Returns:\n            typing.Iterator[T]:\n                 An iterator over the items in the collection.\n\n        \"\"\"\n        return iter_collection(self)\n\n    def __getitem__(self, index: int) -&gt; T:\n        \"\"\"\n        __getitem__ method\n        This method overrides the default item-access ([] operator) behavior.\n        The method allows accessing elements of the instance using an integer index like an array. It takes an\n        integer index and returns the attribute of the instance corresponding to that index, converted to a string.\n\n        Args:\n            index (int):\n                 An integer representing the index of the desired attribute within the instance.\n\n        Returns:\n            T:\n                 The value of the attribute corresponding to the passed index cast to type T.\n\n        Raises:\n            AttributeError:\n                 If the attribute corresponding to the provided index does not exist.\n\n        \"\"\"\n        return getattr(self, str(index))\n\n    def __class_getitem__(cls, item):\n        \"\"\"\n        Gets the attribute of the class based on the provided `item`. If `item` can be converted to a number (numeric string), it tries to access the attribute with the numerical name, otherwise, it delegates the lookup to the superclass's `__class_getitem__` method.\n\n        Args:\n            cls (type):\n                 The class on which the method is being called.\n            item (Any):\n                 The identifier for the class attribute, which could be a label or a numeric string that represents an integer attribute name.\n\n        Returns:\n            Any:\n                 The value of the attribute corresponding to `item` if it's a numeric string, otherwise the result from the superclass's `__class_getitem__`.\n\n        Raises:\n            AttributeError:\n                 If an attribute with the given numeric string as a name does not exist within the class.\n            TypeError:\n                 If the superclass's `__class_getitem__` does not support handling the provided `item`.\n\n        \"\"\"\n        if str(item).isnumeric():\n            return getattr(cls, str(item))\n        return super().__class_getitem__(item)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.Collection.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Gets the attribute of the class based on the provided <code>item</code>. If <code>item</code> can be converted to a number (numeric string), it tries to access the attribute with the numerical name, otherwise, it delegates the lookup to the superclass's <code>__class_getitem__</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class on which the method is being called.</p> required <code>item</code> <code>Any</code> <p>The identifier for the class attribute, which could be a label or a numeric string that represents an integer attribute name.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the attribute corresponding to <code>item</code> if it's a numeric string, otherwise the result from the superclass's <code>__class_getitem__</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute with the given numeric string as a name does not exist within the class.</p> <code>TypeError</code> <p>If the superclass's <code>__class_getitem__</code> does not support handling the provided <code>item</code>.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __class_getitem__(cls, item):\n    \"\"\"\n    Gets the attribute of the class based on the provided `item`. If `item` can be converted to a number (numeric string), it tries to access the attribute with the numerical name, otherwise, it delegates the lookup to the superclass's `__class_getitem__` method.\n\n    Args:\n        cls (type):\n             The class on which the method is being called.\n        item (Any):\n             The identifier for the class attribute, which could be a label or a numeric string that represents an integer attribute name.\n\n    Returns:\n        Any:\n             The value of the attribute corresponding to `item` if it's a numeric string, otherwise the result from the superclass's `__class_getitem__`.\n\n    Raises:\n        AttributeError:\n             If an attribute with the given numeric string as a name does not exist within the class.\n        TypeError:\n             If the superclass's `__class_getitem__` does not support handling the provided `item`.\n\n    \"\"\"\n    if str(item).isnumeric():\n        return getattr(cls, str(item))\n    return super().__class_getitem__(item)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.Collection.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>getitem method This method overrides the default item-access ([] operator) behavior. The method allows accessing elements of the instance using an integer index like an array. It takes an integer index and returns the attribute of the instance corresponding to that index, converted to a string.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>An integer representing the index of the desired attribute within the instance.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value of the attribute corresponding to the passed index cast to type T.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute corresponding to the provided index does not exist.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __getitem__(self, index: int) -&gt; T:\n    \"\"\"\n    __getitem__ method\n    This method overrides the default item-access ([] operator) behavior.\n    The method allows accessing elements of the instance using an integer index like an array. It takes an\n    integer index and returns the attribute of the instance corresponding to that index, converted to a string.\n\n    Args:\n        index (int):\n             An integer representing the index of the desired attribute within the instance.\n\n    Returns:\n        T:\n             The value of the attribute corresponding to the passed index cast to type T.\n\n    Raises:\n        AttributeError:\n             If the attribute corresponding to the provided index does not exist.\n\n    \"\"\"\n    return getattr(self, str(index))\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.Collection.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates over a collection instance. This method will return an iterator for the items in the collection by utilizing the <code>iter_collection</code> function.</p> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>typing.Iterator[T]:  An iterator over the items in the collection.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __iter__(self) -&gt; typing.Iterator[T]:\n    \"\"\"\n    Iterates over a collection instance.\n    This method will return an iterator for the items in the collection by utilizing the `iter_collection` function.\n\n    Returns:\n        typing.Iterator[T]:\n             An iterator over the items in the collection.\n\n    \"\"\"\n    return iter_collection(self)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.Collection.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of an object.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the object.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __len__(self):\n    \"\"\"\n\n    Returns the length of an object.\n\n    Returns:\n        int:\n             The length of the object.\n\n    \"\"\"\n    return self.__class__.length\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.CollectionMetaclass","title":"<code>CollectionMetaclass</code>","text":"<p>             Bases: <code>type</code></p> <p>A metaclass for creating collection types with a defined length. This metaclass allows for the creation of collection classes which support the len() function and iteration protocol. It provides a class-level attribute 'length' to denote the size of the collection, which is returned when len() is called. It also makes the collection class itself iterable via the iter() method, which is expected to be defined by instances of collection classes using this metaclass.</p> <p>Attributes:</p> Name Type Description <code>length</code> <code>int</code> <p>Class-level attribute specifying the number of elements in the collection.</p> <p>Methods:</p> Name Description <code>__len__</code> <p>Returns the length of the collection class.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of elements in the collection.</p> <p>iter(cls) -&gt; typing.Iterator[T]: Should return an iterator over the elements of the collection class.</p> <p>Returns:</p> Type Description <p>typing.Iterator[T]:  An iterator over the collection elements.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>class CollectionMetaclass(type):\n    \"\"\"\n    A metaclass for creating collection types with a defined length.\n    This metaclass allows for the creation of collection classes which support\n    the len() function and iteration protocol. It provides a class-level\n    attribute 'length' to denote the size of the collection, which is returned\n    when __len__() is called. It also makes the collection class itself iterable\n    via the __iter__() method, which is expected to be defined by instances of\n    collection classes using this metaclass.\n\n    Attributes:\n        length (int):\n             Class-level attribute specifying the number of elements\n            in the collection.\n\n    Methods:\n        __len__(cls) -&gt; int:\n            Returns the length of the collection class.\n\n    Returns:\n        int:\n             The number of elements in the collection.\n        __iter__(cls) -&gt; typing.Iterator[T]:\n            Should return an iterator over the elements of the collection class.\n\n    Returns:\n        typing.Iterator[T]:\n             An iterator over the collection elements.\n\n    \"\"\"\n\n    length: int = 0\n\n    def __len__(cls):\n        \"\"\"\n        Computes the number of elements in the instance of the class.\n        This method returns the 'length' attribute of the class instance, which should represent the number of elements it contains.\n\n        Returns:\n            int:\n                 The number of elements in the instance.\n\n        \"\"\"\n        return cls.length\n\n    def __iter__(cls) -&gt; typing.Iterator[T]:\n        \"\"\"\n        Iterates over the elements of the collection class.\n        This method enables the class to be iterable, allowing it to be used in for-loops\n        and other contexts where an iterator is expected. It utilizes the 'iter_collection'\n        function to yield elements of the collection.\n\n        Returns:\n            typing.Iterator[T]:\n                 An iterator for the collection class that yields elements\n                of type 'T'.\n\n        \"\"\"\n        return iter_collection(cls)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.CollectionMetaclass.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates over the elements of the collection class. This method enables the class to be iterable, allowing it to be used in for-loops and other contexts where an iterator is expected. It utilizes the 'iter_collection' function to yield elements of the collection.</p> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>typing.Iterator[T]:  An iterator for the collection class that yields elements of type 'T'.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __iter__(cls) -&gt; typing.Iterator[T]:\n    \"\"\"\n    Iterates over the elements of the collection class.\n    This method enables the class to be iterable, allowing it to be used in for-loops\n    and other contexts where an iterator is expected. It utilizes the 'iter_collection'\n    function to yield elements of the collection.\n\n    Returns:\n        typing.Iterator[T]:\n             An iterator for the collection class that yields elements\n            of type 'T'.\n\n    \"\"\"\n    return iter_collection(cls)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.CollectionMetaclass.__len__","title":"<code>__len__()</code>","text":"<p>Computes the number of elements in the instance of the class. This method returns the 'length' attribute of the class instance, which should represent the number of elements it contains.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of elements in the instance.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def __len__(cls):\n    \"\"\"\n    Computes the number of elements in the instance of the class.\n    This method returns the 'length' attribute of the class instance, which should represent the number of elements it contains.\n\n    Returns:\n        int:\n             The number of elements in the instance.\n\n    \"\"\"\n    return cls.length\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.is_collection","title":"<code>is_collection(value)</code>","text":"<p>Checks whether the given value is an instance of a Collection subtype. This function will return True if <code>value</code> is a subtype other than the base Collection type itself. It utilizes the <code>is_subtype</code> function to perform its check.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to be checked.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>value</code> is a subtype of Collection, False otherwise.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def is_collection(value: typing.Any) -&gt; bool:\n    \"\"\"\n    Checks whether the given value is an instance of a Collection subtype.\n    This function will return True if `value` is a subtype other than the base Collection type\n    itself. It utilizes the `is_subtype` function to perform its check.\n\n    Args:\n        value (typing.Any):\n             The value to be checked.\n\n    Returns:\n        bool:\n             True if `value` is a subtype of Collection, False otherwise.\n\n    \"\"\"\n    return is_subtype(value, (Collection,))\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.collection","title":"<code>collection(*elements)</code>","text":"<p>Creates a new collection type with the specified elements. This function dynamically generates a new collection type by subclassing a 'Collection' base class. The new type includes a 'length' class attribute representing the number of elements provided, and each element is added as a class attribute with the index as the key. The generated collection type is cast to 'ElementType' before being returned.</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>ElementType</code> <p>Variable length argument list representing the elements to include in the new collection type.</p> <code>()</code> <p>Returns:</p> Type Description <code>type[Collection]</code> <p>type['Collection']:  A new collection type that includes the provided elements as attributes, along with a 'length' class attribute.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def collection(*elements: ElementType) -&gt; type[\"Collection\"]:\n    \"\"\"\n    Creates a new collection type with the specified elements.\n    This function dynamically generates a new collection type by subclassing a 'Collection' base class. The new type includes a 'length' class attribute representing the number of elements provided, and each element is added as a class attribute with the index as the key.\n    The generated collection type is cast to 'ElementType' before being returned.\n\n    Args:\n        *elements (ElementType):\n             Variable length argument list representing the elements to include in the new collection type.\n\n    Returns:\n        type['Collection']:\n             A new collection type that includes the provided elements as attributes, along with a 'length' class attribute.\n\n    \"\"\"\n    new_collection = type(\n        \"collection\",\n        (Collection,),\n        {\n            \"length\": len(elements),\n            **dict((str(index), element) for index, element in enumerate(elements)),\n        },\n    )\n\n    return typing.cast(ElementType, new_collection)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.iter_collection","title":"<code>iter_collection(element)</code>","text":"<p>Iterates over a collection and yields its elements one by one. This function takes a 'Collection' object or its type and creates an iterator that yields each element of the collection in sequence. The 'Collection' interface is expected to have a 'length' attribute and allow accessing its elements by index, with indices being string representations of integers starting from 0.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Union[type[Collection[T]], Collection[T]]</code> <p>A 'Collection' object or its type, which is expected to fulfill the interface requirements mentioned above.</p> required <p>Yields:</p> <p>Returns:</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the 'Collection' object does not have a 'length' attribute or does not support accessing elements by index.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def iter_collection(\n    element: typing.Union[type[\"Collection[T]\"], \"Collection[T]\"],\n) -&gt; typing.Generator[T, None, None]:\n    \"\"\"\n    Iterates over a collection and yields its elements one by one.\n    This function takes a 'Collection' object or its type and creates an\n    iterator that yields each element of the collection in sequence. The\n    'Collection' interface is expected to have a 'length' attribute and\n    allow accessing its elements by index, with indices being string\n    representations of integers starting from 0.\n\n    Args:\n        element:\n             A 'Collection' object or its type, which is expected to\n            fulfill the interface requirements mentioned above.\n\n    Yields:\n\n    Returns:\n\n    Raises:\n        AttributeError:\n             If the 'Collection' object does not have a 'length'\n            attribute or does not support accessing elements by index.\n\n    \"\"\"\n    for index in range(element.length):\n        yield getattr(element, str(index))\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.sort_collection","title":"<code>sort_collection(element, key=None, reverse=False)</code>","text":"<p>Sorts a given collection in place based on the specified key and order.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Collection]</code> <p>The collection instance to be sorted. The collection should have attributes accessible by string representations of indices.</p> required <code>key</code> <code>callable</code> <p>A function that serves as a key for the sort comparison. Defaults to None, which means that the items are sorted directly without calculating a separate key value.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If set to True, the collection is sorted in reverse (descending) order; if False (default), the collection is sorted in ascending order.</p> <code>False</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the collection does not have attributes corresponding to string representations of indices, or if the attributes can't be set.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def sort_collection(element: type[\"Collection\"], key=None, reverse=False):\n    \"\"\"\n    Sorts a given collection in place based on the specified key and order.\n\n    Args:\n        element (type['Collection']):\n             The collection instance to be sorted. The collection should have attributes accessible by string representations of indices.\n        key (callable, optional):\n             A function that serves as a key for the sort comparison. Defaults to None, which means that the items are sorted directly without calculating a separate key value.\n        reverse (bool, optional):\n             If set to True, the collection is sorted in reverse (descending) order; if False (default), the collection is sorted in ascending order.\n\n    Raises:\n        AttributeError:\n             If the collection does not have attributes corresponding to string representations of indices, or if the attributes can't be set.\n\n    \"\"\"\n    sorted_elements = sorted(\n        (getattr(element, str(x)) for x in range(element.length)),\n        key=key,\n        reverse=reverse,\n    )\n    for index, _element in enumerate(sorted_elements):\n        setattr(element, str(index), _element)\n</code></pre>"},{"location":"Python/API/Modelling/Collection/#stateforward.model.collection.extend_collection","title":"<code>extend_collection(collection_element, *elements)</code>","text":"<p>Extends a collection with additional elements. This function takes a collection element and an arbitrary number of elements to be added to the collection. Each element is associated with the collection element using an identifier as the name of the association. The name of the association is determined by the current length of the collection. After adding each element, the length of the collection is incremented.</p> <p>Parameters:</p> Name Type Description Default <code>collection_element</code> <code>CollectionType</code> <p>The collection to be extended.</p> required <code>*elements</code> <code>Collection[ElementType]</code> <p>A variable number of elements that will be added to the collection.</p> <code>()</code> <p>Raises:</p> <p>Note:</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def extend_collection(\n    collection_element: \"CollectionType\", *elements: typing.Collection[ElementType]\n):\n    \"\"\"\n    Extends a collection with additional elements.\n    This function takes a collection element and an arbitrary number of elements to be added to the collection.\n    Each element is associated with the collection element using an identifier as the name of the association.\n    The name of the association is determined by the current length of the collection. After adding each element,\n    the length of the collection is incremented.\n\n    Args:\n        collection_element (CollectionType):\n             The collection to be extended.\n        *elements (Collection[ElementType]):\n             A variable number of elements that will be added to the collection.\n\n    Raises:\n\n    Note:\n\n    \"\"\"\n    for element in elements:\n        add_association_to(collection_element, element, str(collection_element.length))\n        collection_element.length += 1\n</code></pre>"},{"location":"Python/API/Modelling/Decorators/","title":"Decorators","text":"<p>The <code>decorators</code> module provides a decorator <code>instance_or_classmethod</code> that allows methods to be called on either an instance of a class or the class itself without the need to define the method specifically as an instance method or a class method. This decorator creates a custom descriptor that decides how to handle the method call based on whether <code>instance</code> is <code>None</code> or not.</p> <p>The <code>instance_or_classmethod</code> function takes a <code>decorated</code> function as an argument and returns a callable that acts depending on the context of its call. This function defines a nested <code>__get__</code> function within it that overrides the special <code>__get__</code> method, which is part of the descriptor protocol in Python. This <code>__get__</code> method is used to determine how attributes of objects should be accessed.</p> <p>If <code>instance</code> is <code>None</code>, which implies that the method is being called on the class, the <code>__get__</code> method delegates the call to the <code>__get__</code> method of <code>classmethod</code>, effectively turning the called method into a class method at that moment. If <code>instance</code> is not <code>None</code>, suggesting that the method is called on an instance of the class, the <code>__get__</code> method retrieves the function itself, allowing it to behave as an instance method.</p> <p>This dynamic behavior adds flexibility to class design, especially when a method needs to behave differently depending on whether it is called by an instance or the class itself. It's implemented by creating a custom class type dynamically with the <code>type</code> function and then setting its <code>__get__</code> method to the one defined locally, applied to the <code>decorated</code> method. The module relies on Python's advanced features such as the descriptor protocol, the <code>classmethod</code> built-in decorator, and type creation on the fly with <code>type()</code>.</p>"},{"location":"Python/API/Modelling/Decorators/#stateforward.model.decorators.instance_or_classmethod","title":"<code>instance_or_classmethod(decorated)</code>","text":"<p>Transforms a function into a method that can behave either as a classmethod or an instance method. The function dynamically determines whether it should behave as a classmethod or an instance method upon being accessed. It modifies the 'get' method of a new type, based on the 'classmethod' type, to change its behavior according to whether it is called from an instance or the class itself.</p> <p>Parameters:</p> Name Type Description Default <code>decorated</code> <code>Callable[P, R]</code> <p>The function that is to be converted into a dual-method. This function should be capable of handling both classmethod and instance method calls.</p> required <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>Callable[P, R]:  A callable object that can behave either as a classmethod or an instance method depending on how it is accessed.</p> <p>Raises:</p> Source code in <code>stateforward/model/decorators.py</code> <pre><code>def instance_or_classmethod(decorated: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"\n    Transforms a function into a method that can behave either as a classmethod or an instance method.\n    The function dynamically determines whether it should behave as a classmethod or an instance\n    method upon being accessed. It modifies the '__get__' method of a new type, based on the 'classmethod'\n    type, to change its behavior according to whether it is called from an instance or the class itself.\n\n    Args:\n        decorated (Callable[P, R]):\n             The function that is to be converted into a dual-method. This function\n            should be capable of handling both classmethod and instance method calls.\n\n    Returns:\n        Callable[P, R]:\n             A callable object that can behave either as a classmethod or an instance method\n            depending on how it is accessed.\n\n    Raises:\n\n    \"\"\"\n\n    def __get__(self, instance, owner):\n        \"\"\"\n        Implements the descriptor protocol by returning a bound or unbound method.\n        When '__get__' is invoked, it determines whether the method should behave as a class method or\n        an instance method. If called on an instance, '__get__' returns the result of '__func__.__get__'. If called without an instance, '__get__' treats the method as a class method.\n\n        Args:\n            instance (object):\n                 The instance that the method is accessed through, or 'None' if\n                accessed through the owner.\n            owner (type):\n                 The owner class that this descriptor is a part of.\n\n        Returns:\n\n        Raises:\n            TypeError:\n                 If 'instance' is not an instance of 'owner'.\n\n        \"\"\"\n        if instance is None:\n            return classmethod.__get__(self, instance, owner)\n        return self.__func__.__get__(instance, owner)\n\n    return type(\n        decorated.__name__,\n        (classmethod,),\n        {\"__get__\": __get__},\n    )(decorated)\n</code></pre>"},{"location":"Python/API/Modelling/Element/","title":"Element","text":"<p>The <code>element</code> module presented here provides a comprehensive framework for representing and manipulating a hierarchy of elements, designed to facilitate the creation and management of complex data models within a software application. It includes a rich set of functions to handle relationships and properties among elements, such as ownership and association management, type checking, element searching, and more. The module also defines an <code>Element</code> class, which serves as the base class for all elements within the hierarchy, and it is used to instantiate and define new elements with unique identities, owned elements, and various other attributes.</p> <p>Key Functionalities:</p> <ul> <li>Identities and Types: Utilize <code>id_of</code> and <code>type_of</code> to acquire the unique identifier and type of an element, respectively.</li> <li>Ownership Management: Employ functions like <code>owned_elements_of</code>, <code>add_owned_element_to</code>, <code>remove_owned_element_from</code> to manage which elements are owned by others.</li> <li>Hierarchy Navigation: Use <code>ancestors_of</code>, <code>descendants_of</code>, <code>is_ancestor_of</code>, <code>is_descendant_of</code> to traverse and verify relationships in the hierarchy.</li> <li>Associations Management: Leverage <code>add_association_to</code>, <code>remove_association_from</code>, <code>associations_of</code> to manage named associations between elements.</li> <li>Search and Filter: Functions like <code>find_owned_elements_of</code>, <code>find_ancestors_of</code>, <code>find_descendants_of</code> to find elements based on specified conditions.</li> <li>Redefinition and Specialization: The <code>redefine</code> and <code>specialize</code> functions are provided to create specialized or redefined versions of existing elements.</li> <li>Attribute Handling: <code>set_attribute</code>, <code>attributes_of</code> allow for setting and accessing custom attributes on elements.</li> <li>Utility Functions: Various helper functions such as <code>is_type</code>, <code>is_subtype</code>, <code>is_element</code>, <code>name_of</code>, <code>qualified_name_of</code> support common operations needed for working with elements.</li> </ul> <p>The <code>Element</code> class encapsulates common functionality needed for all elements in the model, including the initialization and management of class variables that track owned elements, associations, and other class-specific information. It also defines special class methods for defining, redefining, and creating instances of element classes.</p> <p>This module offers a robust infrastructure for modeling relationships and hierarchies within complex systems and serves as a foundational tool for developers handling structured data within object-oriented paradigms.</p>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.ElementType","title":"<code>ElementType = typing.TypeVar('ElementType', bound=typing.Union[type['Element'], 'Element'])</code>  <code>module-attribute</code>","text":""},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element","title":"<code>Element</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A generic base class for modeling elements within a custom framework. This class serves as a template for defining various model elements by providing mechanisms to handle attributes, ownership, associations, and element specialization through subclassing. It implements a registry for all elements, associates unique identifiers, and handles element creation, definition, redefinition, and ownership. When a subclass is created, it automatically registers itself, allocates a new ID, and sets up its model, owner, and type information. Subclasses can further define or redefine their structure by providing additional attributes and owned elements via the <code>__define__</code> or <code>__redefine__</code> methods. The <code>__create__</code> and <code>__create_owned_elements__</code> methods are responsible for instance creation, and ensuring that all elements within the namespace of the created element are properly initialized. The constructor 'new' is overridden to integrate this creation process and to manage the initialization flow of the newly created elements.</p> <p>Attributes:</p> Name Type Description <code>__all_elements__</code> <code>dict[int, Element]</code> <p>A class attribute that acts as a registry of all c        reated element instances, mapped by their unique IDs.</p> <code>__id__</code> <code>int</code> <p>A class-level unique identifier for elements.</p> <code>__owned_elements__</code> <code>list[int]</code> <p>A list of IDs representing elements owned by this class.</p> <code>__redefined_element__</code> <code>Optional[Element]</code> <p>An element that this class may redefine.</p> <code>__associations__</code> <code>dict[str, int]</code> <p>A dictionary mapping association names to their respective IDs.</p> <code>__owner__</code> <code>Optional[int]</code> <p>The ID of the owner element, if any.</p> <code>__type__</code> <code>Type[Element]</code> <p>The type of the class, typically set to the subclass itself.</p> <code>__model__</code> <code>Optional[int]</code> <p>The ID of the model element, if any.</p> <code>__init__</code> <code>Callable[..., None]</code> <p>The initialization method for the element, with a default noop implemmentation.</p> <code>model</code> <code>Optional[Element]</code> <p>The model element associated with an instance of this class.</p> <code>Class</code> <code>Methods</code> <code>__init_subclass__(cls,</code> <code>**kwargs</code> <p>Automatically called when a subclass is defined, used to initialize class-level attributes nd register the new element.</p> <code>__define__(cls,</code> <code>**kwargs</code> <p>Handles the definition of new elements by associating owned_elements and configuring the amespace.</p> <code>__redefine__(cls,</code> <code>**kwargs</code> <p>Designed to be overridden in subclasses to handle element redefinition.</p> <code>__create__(cls,</code> <code>**kwargs) -&gt; 'Element'</code> <p>Responsible for creating a new instance of the class, including initializing ownership and ll elements within its namespace.</p> <code>__new__(cls</code> <code>**kwargs) -&gt; 'Element'</code> <p>type['Element'], args: typing.Any, *kwargs) -&gt; Union['Element', Callable[[], 'Element']]: Overrides the default object instantiation process to integrate element creation and nitialization management.</p> <code>__create_owned_elements__(cls,</code> <code>(self, all_elements)</code> <p>dict[int, 'Element']): Instantiates owned elements and ensures they are added to the current element's namespace.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>class Element(typing.Generic[T]):\n    \"\"\"\n    A generic base class for modeling elements within a custom framework.\n    This class serves as a template for defining various model elements by providing mechanisms to handle\n    attributes, ownership, associations, and element specialization through subclassing. It implements a\n    registry for all elements, associates unique identifiers, and handles element creation, definition,\n    redefinition, and ownership.\n    When a subclass is created, it automatically registers itself, allocates a new ID, and sets up its\n    model, owner, and type information. Subclasses can further define or redefine their structure by\n    providing additional attributes and owned elements via the `__define__` or `__redefine__` methods.\n    The `__create__` and `__create_owned_elements__` methods are responsible for instance creation,\n    and ensuring that all elements within the namespace of the created element are properly initialized.\n    The constructor '__new__' is overridden to integrate this creation process and to manage the\n    initialization flow of the newly created elements.\n\n    Attributes:\n        __all_elements__ (dict[int, 'Element']):\n             A class attribute that acts as a registry of all\n            c        reated element instances, mapped by their unique IDs.\n        __id__ (int):\n             A class-level unique identifier for elements.\n        __owned_elements__ (list[int]):\n             A list of IDs representing elements owned by this class.\n        __redefined_element__ (Optional['Element']):\n             An element that this class may redefine.\n        __associations__ (dict[str, int]):\n             A dictionary mapping association names to their respective IDs.\n        __owner__ (Optional[int]):\n             The ID of the owner element, if any.\n        __type__ (Type['Element']):\n             The type of the class, typically set to the subclass itself.\n        __model__ (Optional[int]):\n             The ID of the model element, if any.\n        __init__ (Callable[..., None]):\n             The initialization method for the element, with a default noop\n            implemmentation.\n        model (Optional['Element']):\n             The model element associated with an instance of this class.\n        Class Methods:\n        __init_subclass__(cls, **kwargs):\n            Automatically called when a subclass is defined, used to initialize class-level attributes\n            nd register the new element.\n        __define__(cls, **kwargs):\n            Handles the definition of new elements by associating owned_elements and configuring the\n            amespace.\n        __redefine__(cls, **kwargs):\n            Designed to be overridden in subclasses to handle element redefinition.\n        __create__(cls, **kwargs) -&gt; 'Element':\n            Responsible for creating a new instance of the class, including initializing ownership and\n            ll elements within its namespace.\n        __new__(cls:\n             type['Element'], *args: typing.Any, **kwargs) -&gt; Union['Element', Callable[[], 'Element']]:\n            Overrides the default object instantiation process to integrate element creation and\n            nitialization management.\n        __create_owned_elements__(cls, self, all_elements:\n             dict[int, 'Element']):\n            Instantiates owned elements and ensures they are added to the current element's namespace.\n\n    \"\"\"\n\n    __all_elements__: dict[int, \"ElementType\"] = {}\n    __id__: typing.ClassVar[int] = 0\n    __owned_elements__: list[int] = None\n    __redefined_element__: typing.Optional[\"Element\"] = None\n    __associations__: dict[str, int] = None\n    __owner__: typing.Optional[int] = None\n    __type__: typing.ClassVar[type[\"Element\"]] = None\n    __model__: typing.Optional[int] = None\n    __init__: typing.Callable[P, None] = lambda *args, **kwargs: None\n    model: typing.Optional[\"Element\"] = None\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"\n        Initializes a subclass.\n        This method is called when a new subclass of the `Element` base class is created, and it\n        performs essential setup for the new subclass, including assigning unique identifiers,\n        establishing element relationships, and initializing annotations.\n\n        Attributes for the subclass, such as owned elements, model associations, and type definitions, are\n\n        Args:\n            **kwargs:\n                 Arbitrary keyword arguments. These can include:\n            name (str):\n                 The name to assign to the subclass. If not provided, the default name of the\n                subclass will be used.\n            redefined_element (Element):\n                 An optional argument specifying an element that the subclass\n                is redefining. If not provided, it is assumed this is an original definition rather than\n                a redefinition.\n\n        Raises:\n            TypeError:\n                 If the subclass does not properly specify the base type for an `Element`.\n\n        \"\"\"\n        cls.__owned_elements__ = []\n        cls.__id__ = Element.__id__ = Element.__id__ + 1\n        cls.__model__ = cls.__id__\n        cls.__all_elements__[cls.__id__] = cls\n        cls.__associations__ = {}\n        cls.__type__ = cls\n        cls.__owner__ = None\n        cls.__name__ = kwargs.pop(\"name\", cls.__name__)\n        redefined_element = cls.__redefined_element__ = kwargs.pop(\n            \"redefined_element\", None\n        )\n        if is_subtype(cls.__base__, Element):\n            cls.__annotations__.update(cls.__base__.__annotations__)\n            specialize(cls.__base__, cls)\n        if redefined_element is None:\n            cls.__define__(**kwargs)\n        else:\n            cls.__redefine__(**kwargs)\n\n    @classmethod\n    def __define__(cls, **kwargs):\n        \"\"\"\n        Class method to define extra owned elements and attributes for an Element class based on provided keyword arguments.\n        This method is used to define additional owned elements and set attributes for an Element class by processing\n        keyword arguments passed to the method. Each owned element is added to the class through the\n        `add_owned_element_to` function. Subsequently, the namespace is sorted to distinguish owned elements,\n        orphans, and attributes. Attributes are set using the `set_attribute` function according to their respective sorted order.\n\n        Args:\n            **kwargs:\n                 Arbitrary keyword arguments where the key is the attribute name or owned element, and the value is its corresponding value or owned element instance.\n                The 'owned_elements' keyword argument is expected to be an iterable of owned elements that are to be added to this class.\n                Any other keyword argument corresponds to an attribute or owned element of the class that will be set or added respectively based on the type of the value provided. Attributes are set directly, whereas owned elements are added using pre-defined mechanisms while respecting ownership rules.\n                Sorting of the namespace involves determining the owned elements, orphan elements (elements without an owner), and attributes that need to be set on the class. This is performed by 'sort_namespace' nested function.\n\n        \"\"\"\n        for owned_element in kwargs.get(\"owned_elements\", ()):\n            add_owned_element_to(cls, owned_element)\n\n        def sort_namespace(namespace: dict[str, typing.Any]) -&gt; dict[str, typing.Any]:\n            \"\"\"\n            Sorts the provided namespace dictionary into a consistently ordered mapping.\n            The function segregates keys based on whether they are owned, orphaned, or regular attributes.\n            Elements in the namespace which are considered 'owned' are those where an owner is identifiable.\n            Orphaned elements have no identifiable owner, and attributes include all other elements.\n            The sorting is done based on a calculated identity for each item.\n\n            Args:\n                namespace (dict[str, typing.Any]):\n                     A dictionary representing the namespace to be sorted.\n\n            Returns:\n                dict[str, typing.Any]:\n                     A dictionary with keys sorted into orphans, owned, and attributes in that order.\n                    The resultant dictionary contains all elements from orphans first, followed by owned elements, and then the regular attributes, each sorted by their calculated identities.\n\n            \"\"\"\n            owned = {}\n            orphans = {}\n            attributes = {}\n            for key, item in namespace.items():\n                if key not in Element.__dict__:\n                    item_id = id_of(item)\n                    if is_element(item):\n                        if owner_of(item) is None:\n                            orphans[key] = (item_id, item)\n                        else:\n                            owned[key] = (item_id, item)\n                    else:\n                        attributes[key] = (item_id, item)\n\n            return {**orphans, **owned, **attributes}\n\n        sorted_namespace = sort_namespace(\n            {\n                **cls.__dict__,\n                **dict(\n                    (name, kwargs.get(name, getattr(cls, name, None)))\n                    for name in cls.__annotations__\n                ),\n            },\n        )\n        for name, (item_id, item) in sorted_namespace.items():\n            set_attribute(cls, name, item)\n\n    @classmethod\n    def __redefine__(cls, **kwargs):\n        \"\"\"\n        A class method to redefine properties of the class based on provided keyword arguments.\n        This method allows dynamic modification of class attributes, altering the class' behaviour\n        at runtime. The kwargs dictionary should contain attribute names and their new values.\n\n        Args:\n            **kwargs:\n                 Variable length keyword arguments. Each key corresponds to an attribute\n                name of the class, and each value is the new value to set for that\n                attribute.\n\n        Returns:\n            None:\n                 This method does not return anything.\n\n        \"\"\"\n        for key, item in kwargs.items():\n            set_attribute(cls, key, item)\n        pass\n\n    @classmethod\n    def __create__(cls, **kwargs) -&gt; \"Element\":\n        \"\"\"\n        Creates an instance of the Element class with provided keyword arguments.\n        This method populates the new object's attributes, creating a namespace for the\n        core in the element. The `owner` and `all_elements` attributes are set from keyword\n        arguments if provided, otherwise, default values are assumed. Any elements owned by\n        the instance are initialized in this method.\n\n        Args:\n            **kwargs:\n                 Variable length keyword arguments.\n            - 'owner' (optional):\n                 The owner of the element. Defaults to None.\n            - 'id' (optional):\n                 The identifier for the element. Defaults to the object id.\n            - 'all_elements' (optional):\n                 A dictionary of all element instances keyed by their ids.\n                Defaults to a dictionary with the current class's id_of as the key and `self` as the value.\n\n        Returns:\n            Element:\n                 A new instance of the Element class or its subclass with initialized attributes.\n\n        Raises:\n            TypeError:\n                 If super().__new__(cls) does not return an instance of cls.\n\n        \"\"\"\n        self = super().__new__(cls)\n        owner = self.__owner__ = kwargs.pop(\"owner\", None)\n        self.__owned_elements__ = []\n        self.__id__ = kwargs.pop(\"id\", id(self))\n        self.model = typing.cast(Element, owner).model if owner is not None else self\n        all_elements = self.__all_elements__ = kwargs.pop(\n            \"all_elements\", {id_of(cls): self}\n        )  # create a namespace for the core in the element\n        cls.__create_owned_elements__(self, all_elements)\n        return self\n\n    @staticmethod\n    def __new__(\n        cls: type[\"Element\"], *args: typing.Any, **kwargs\n    ) -&gt; typing.Union[\"Element\", typing.Callable[[], \"Element\"]]:\n        \"\"\"\n        Creates a new instance of the Element class or returns a callable that creates an instance when invoked.\n        This static method is a custom constructor for creating instances of the given `Element` class or its subclasses. It uses the private `__create__` method to construct an instance with the provided keyword arguments. If the created instance does not have an owner, it iterates through all associated elements to set their attributes based on existing associations and initializes them with the corresponding kwargs.\n        For the root element of the element tree, this method finalizes its creation and returns the new instance directly. If the instance being created is not the root element, this method returns a lambda function that, when called, returns the created instance without invoking the `__init__` method.\n\n        Args:\n            cls (type[Element]):\n                 The class of the element to create an instance of.\n            *args (typing.Any):\n                 Variable length argument list, currently not utilized in the method body.\n            **kwargs (typing.Any):\n                 Variable keyword arguments used for initializing the instance attributes.\n\n        Returns:\n            typing.Union[Element, typing.Callable[[], Element]]:\n                 An instance of the `Element` class if it is the root element, or a lambda function that returns the new instance for non-root elements.\n\n        \"\"\"\n        self = cls.__create__(**kwargs)\n        if owner_of(self) is None:\n            for element in reversed(self.__all_elements__.values()):\n                for name, value in associations_of(element).items():\n                    value = self.__all_elements__[id_of(type(value))]\n                    setattr(element, str(name), value)\n                if element is not self:\n                    element.__init__(**kwargs.pop(qualified_name_of(element), {}))\n            # this is the root element of the element, so we can start initializing\n            return self\n        # a hack to prevent __init__ from being called\n        return lambda _self=self: _self\n\n    @classmethod\n    def __create_owned_elements__(cls, self, all_elements: dict[int, \"Element\"]):\n        \"\"\"\n        Class method to instantiate and associate owned elements with a class instance.\n        This method loops through the class-level collection of owned element IDs, retrieves the corresponding element from a shared class-level dictionary, instantiates it by preventing the direct call of its constructor, and finally stores the instance in a provided dictionary. This method modifies the provided dictionary in place by adding the new instances and also appends the element IDs to the instance specific owned elements list.\n\n        Args:\n            cls (type):\n                 The class from which the method is called.\n            self (object):\n                 The instance of the class owning the new elements.\n            all_elements (dict[int, 'Element']):\n                 A dictionary mapping element IDs to their corresponding 'Element' instances.\n\n        Notes:\n\n        \"\"\"\n        for owned_element_id in cls.__owned_elements__:\n            owned_element = cls.__all_elements__[owned_element_id]\n            instance = owned_element(\n                owner=self,\n                all_elements=all_elements,\n            )()  # using the extra function call to prevent __init__ from being called\n            all_elements[owned_element_id] = instance\n            self.__owned_elements__.append(owned_element_id)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__create__","title":"<code>__create__(**kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the Element class with provided keyword arguments. This method populates the new object's attributes, creating a namespace for the core in the element. The <code>owner</code> and <code>all_elements</code> attributes are set from keyword arguments if provided, otherwise, default values are assumed. Any elements owned by the instance are initialized in this method.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Variable length keyword arguments.</p> <code>{}</code> <code>-</code> <code>'owner' (optional</code> <p>The owner of the element. Defaults to None.</p> required <code>-</code> <code>'id' (optional</code> <p>The identifier for the element. Defaults to the object id.</p> required <code>-</code> <code>'all_elements' (optional</code> <p>A dictionary of all element instances keyed by their ids. Defaults to a dictionary with the current class's id_of as the key and <code>self</code> as the value.</p> required <p>Returns:</p> Name Type Description <code>Element</code> <code>Element</code> <p>A new instance of the Element class or its subclass with initialized attributes.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If super().new(cls) does not return an instance of cls.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __create__(cls, **kwargs) -&gt; \"Element\":\n    \"\"\"\n    Creates an instance of the Element class with provided keyword arguments.\n    This method populates the new object's attributes, creating a namespace for the\n    core in the element. The `owner` and `all_elements` attributes are set from keyword\n    arguments if provided, otherwise, default values are assumed. Any elements owned by\n    the instance are initialized in this method.\n\n    Args:\n        **kwargs:\n             Variable length keyword arguments.\n        - 'owner' (optional):\n             The owner of the element. Defaults to None.\n        - 'id' (optional):\n             The identifier for the element. Defaults to the object id.\n        - 'all_elements' (optional):\n             A dictionary of all element instances keyed by their ids.\n            Defaults to a dictionary with the current class's id_of as the key and `self` as the value.\n\n    Returns:\n        Element:\n             A new instance of the Element class or its subclass with initialized attributes.\n\n    Raises:\n        TypeError:\n             If super().__new__(cls) does not return an instance of cls.\n\n    \"\"\"\n    self = super().__new__(cls)\n    owner = self.__owner__ = kwargs.pop(\"owner\", None)\n    self.__owned_elements__ = []\n    self.__id__ = kwargs.pop(\"id\", id(self))\n    self.model = typing.cast(Element, owner).model if owner is not None else self\n    all_elements = self.__all_elements__ = kwargs.pop(\n        \"all_elements\", {id_of(cls): self}\n    )  # create a namespace for the core in the element\n    cls.__create_owned_elements__(self, all_elements)\n    return self\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__create_owned_elements__","title":"<code>__create_owned_elements__(self, all_elements)</code>  <code>classmethod</code>","text":"<p>Class method to instantiate and associate owned elements with a class instance. This method loops through the class-level collection of owned element IDs, retrieves the corresponding element from a shared class-level dictionary, instantiates it by preventing the direct call of its constructor, and finally stores the instance in a provided dictionary. This method modifies the provided dictionary in place by adding the new instances and also appends the element IDs to the instance specific owned elements list.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class from which the method is called.</p> required <code>self</code> <code>object</code> <p>The instance of the class owning the new elements.</p> required <code>all_elements</code> <code>dict[int, Element]</code> <p>A dictionary mapping element IDs to their corresponding 'Element' instances.</p> required <p>Notes:</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __create_owned_elements__(cls, self, all_elements: dict[int, \"Element\"]):\n    \"\"\"\n    Class method to instantiate and associate owned elements with a class instance.\n    This method loops through the class-level collection of owned element IDs, retrieves the corresponding element from a shared class-level dictionary, instantiates it by preventing the direct call of its constructor, and finally stores the instance in a provided dictionary. This method modifies the provided dictionary in place by adding the new instances and also appends the element IDs to the instance specific owned elements list.\n\n    Args:\n        cls (type):\n             The class from which the method is called.\n        self (object):\n             The instance of the class owning the new elements.\n        all_elements (dict[int, 'Element']):\n             A dictionary mapping element IDs to their corresponding 'Element' instances.\n\n    Notes:\n\n    \"\"\"\n    for owned_element_id in cls.__owned_elements__:\n        owned_element = cls.__all_elements__[owned_element_id]\n        instance = owned_element(\n            owner=self,\n            all_elements=all_elements,\n        )()  # using the extra function call to prevent __init__ from being called\n        all_elements[owned_element_id] = instance\n        self.__owned_elements__.append(owned_element_id)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__define__","title":"<code>__define__(**kwargs)</code>  <code>classmethod</code>","text":"<p>Class method to define extra owned elements and attributes for an Element class based on provided keyword arguments. This method is used to define additional owned elements and set attributes for an Element class by processing keyword arguments passed to the method. Each owned element is added to the class through the <code>add_owned_element_to</code> function. Subsequently, the namespace is sorted to distinguish owned elements, orphans, and attributes. Attributes are set using the <code>set_attribute</code> function according to their respective sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments where the key is the attribute name or owned element, and the value is its corresponding value or owned element instance. The 'owned_elements' keyword argument is expected to be an iterable of owned elements that are to be added to this class. Any other keyword argument corresponds to an attribute or owned element of the class that will be set or added respectively based on the type of the value provided. Attributes are set directly, whereas owned elements are added using pre-defined mechanisms while respecting ownership rules. Sorting of the namespace involves determining the owned elements, orphan elements (elements without an owner), and attributes that need to be set on the class. This is performed by 'sort_namespace' nested function.</p> <code>{}</code> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __define__(cls, **kwargs):\n    \"\"\"\n    Class method to define extra owned elements and attributes for an Element class based on provided keyword arguments.\n    This method is used to define additional owned elements and set attributes for an Element class by processing\n    keyword arguments passed to the method. Each owned element is added to the class through the\n    `add_owned_element_to` function. Subsequently, the namespace is sorted to distinguish owned elements,\n    orphans, and attributes. Attributes are set using the `set_attribute` function according to their respective sorted order.\n\n    Args:\n        **kwargs:\n             Arbitrary keyword arguments where the key is the attribute name or owned element, and the value is its corresponding value or owned element instance.\n            The 'owned_elements' keyword argument is expected to be an iterable of owned elements that are to be added to this class.\n            Any other keyword argument corresponds to an attribute or owned element of the class that will be set or added respectively based on the type of the value provided. Attributes are set directly, whereas owned elements are added using pre-defined mechanisms while respecting ownership rules.\n            Sorting of the namespace involves determining the owned elements, orphan elements (elements without an owner), and attributes that need to be set on the class. This is performed by 'sort_namespace' nested function.\n\n    \"\"\"\n    for owned_element in kwargs.get(\"owned_elements\", ()):\n        add_owned_element_to(cls, owned_element)\n\n    def sort_namespace(namespace: dict[str, typing.Any]) -&gt; dict[str, typing.Any]:\n        \"\"\"\n        Sorts the provided namespace dictionary into a consistently ordered mapping.\n        The function segregates keys based on whether they are owned, orphaned, or regular attributes.\n        Elements in the namespace which are considered 'owned' are those where an owner is identifiable.\n        Orphaned elements have no identifiable owner, and attributes include all other elements.\n        The sorting is done based on a calculated identity for each item.\n\n        Args:\n            namespace (dict[str, typing.Any]):\n                 A dictionary representing the namespace to be sorted.\n\n        Returns:\n            dict[str, typing.Any]:\n                 A dictionary with keys sorted into orphans, owned, and attributes in that order.\n                The resultant dictionary contains all elements from orphans first, followed by owned elements, and then the regular attributes, each sorted by their calculated identities.\n\n        \"\"\"\n        owned = {}\n        orphans = {}\n        attributes = {}\n        for key, item in namespace.items():\n            if key not in Element.__dict__:\n                item_id = id_of(item)\n                if is_element(item):\n                    if owner_of(item) is None:\n                        orphans[key] = (item_id, item)\n                    else:\n                        owned[key] = (item_id, item)\n                else:\n                    attributes[key] = (item_id, item)\n\n        return {**orphans, **owned, **attributes}\n\n    sorted_namespace = sort_namespace(\n        {\n            **cls.__dict__,\n            **dict(\n                (name, kwargs.get(name, getattr(cls, name, None)))\n                for name in cls.__annotations__\n            ),\n        },\n    )\n    for name, (item_id, item) in sorted_namespace.items():\n        set_attribute(cls, name, item)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Initializes a subclass. This method is called when a new subclass of the <code>Element</code> base class is created, and it performs essential setup for the new subclass, including assigning unique identifiers, establishing element relationships, and initializing annotations.</p> <p>Attributes for the subclass, such as owned elements, model associations, and type definitions, are</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments. These can include:</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name to assign to the subclass. If not provided, the default name of the subclass will be used.</p> required <code>redefined_element</code> <code>Element</code> <p>An optional argument specifying an element that the subclass is redefining. If not provided, it is assumed this is an original definition rather than a redefinition.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the subclass does not properly specify the base type for an <code>Element</code>.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"\n    Initializes a subclass.\n    This method is called when a new subclass of the `Element` base class is created, and it\n    performs essential setup for the new subclass, including assigning unique identifiers,\n    establishing element relationships, and initializing annotations.\n\n    Attributes for the subclass, such as owned elements, model associations, and type definitions, are\n\n    Args:\n        **kwargs:\n             Arbitrary keyword arguments. These can include:\n        name (str):\n             The name to assign to the subclass. If not provided, the default name of the\n            subclass will be used.\n        redefined_element (Element):\n             An optional argument specifying an element that the subclass\n            is redefining. If not provided, it is assumed this is an original definition rather than\n            a redefinition.\n\n    Raises:\n        TypeError:\n             If the subclass does not properly specify the base type for an `Element`.\n\n    \"\"\"\n    cls.__owned_elements__ = []\n    cls.__id__ = Element.__id__ = Element.__id__ + 1\n    cls.__model__ = cls.__id__\n    cls.__all_elements__[cls.__id__] = cls\n    cls.__associations__ = {}\n    cls.__type__ = cls\n    cls.__owner__ = None\n    cls.__name__ = kwargs.pop(\"name\", cls.__name__)\n    redefined_element = cls.__redefined_element__ = kwargs.pop(\n        \"redefined_element\", None\n    )\n    if is_subtype(cls.__base__, Element):\n        cls.__annotations__.update(cls.__base__.__annotations__)\n        specialize(cls.__base__, cls)\n    if redefined_element is None:\n        cls.__define__(**kwargs)\n    else:\n        cls.__redefine__(**kwargs)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a new instance of the Element class or returns a callable that creates an instance when invoked. This static method is a custom constructor for creating instances of the given <code>Element</code> class or its subclasses. It uses the private <code>__create__</code> method to construct an instance with the provided keyword arguments. If the created instance does not have an owner, it iterates through all associated elements to set their attributes based on existing associations and initializes them with the corresponding kwargs. For the root element of the element tree, this method finalizes its creation and returns the new instance directly. If the instance being created is not the root element, this method returns a lambda function that, when called, returns the created instance without invoking the <code>__init__</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Element]</code> <p>The class of the element to create an instance of.</p> required <code>*args</code> <code>Any</code> <p>Variable length argument list, currently not utilized in the method body.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Variable keyword arguments used for initializing the instance attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Element, Callable[[], Element]]</code> <p>typing.Union[Element, typing.Callable[[], Element]]:  An instance of the <code>Element</code> class if it is the root element, or a lambda function that returns the new instance for non-root elements.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@staticmethod\ndef __new__(\n    cls: type[\"Element\"], *args: typing.Any, **kwargs\n) -&gt; typing.Union[\"Element\", typing.Callable[[], \"Element\"]]:\n    \"\"\"\n    Creates a new instance of the Element class or returns a callable that creates an instance when invoked.\n    This static method is a custom constructor for creating instances of the given `Element` class or its subclasses. It uses the private `__create__` method to construct an instance with the provided keyword arguments. If the created instance does not have an owner, it iterates through all associated elements to set their attributes based on existing associations and initializes them with the corresponding kwargs.\n    For the root element of the element tree, this method finalizes its creation and returns the new instance directly. If the instance being created is not the root element, this method returns a lambda function that, when called, returns the created instance without invoking the `__init__` method.\n\n    Args:\n        cls (type[Element]):\n             The class of the element to create an instance of.\n        *args (typing.Any):\n             Variable length argument list, currently not utilized in the method body.\n        **kwargs (typing.Any):\n             Variable keyword arguments used for initializing the instance attributes.\n\n    Returns:\n        typing.Union[Element, typing.Callable[[], Element]]:\n             An instance of the `Element` class if it is the root element, or a lambda function that returns the new instance for non-root elements.\n\n    \"\"\"\n    self = cls.__create__(**kwargs)\n    if owner_of(self) is None:\n        for element in reversed(self.__all_elements__.values()):\n            for name, value in associations_of(element).items():\n                value = self.__all_elements__[id_of(type(value))]\n                setattr(element, str(name), value)\n            if element is not self:\n                element.__init__(**kwargs.pop(qualified_name_of(element), {}))\n        # this is the root element of the element, so we can start initializing\n        return self\n    # a hack to prevent __init__ from being called\n    return lambda _self=self: _self\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.Element.__redefine__","title":"<code>__redefine__(**kwargs)</code>  <code>classmethod</code>","text":"<p>A class method to redefine properties of the class based on provided keyword arguments. This method allows dynamic modification of class attributes, altering the class' behaviour at runtime. The kwargs dictionary should contain attribute names and their new values.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Variable length keyword arguments. Each key corresponds to an attribute name of the class, and each value is the new value to set for that attribute.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <p>This method does not return anything.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __redefine__(cls, **kwargs):\n    \"\"\"\n    A class method to redefine properties of the class based on provided keyword arguments.\n    This method allows dynamic modification of class attributes, altering the class' behaviour\n    at runtime. The kwargs dictionary should contain attribute names and their new values.\n\n    Args:\n        **kwargs:\n             Variable length keyword arguments. Each key corresponds to an attribute\n            name of the class, and each value is the new value to set for that\n            attribute.\n\n    Returns:\n        None:\n             This method does not return anything.\n\n    \"\"\"\n    for key, item in kwargs.items():\n        set_attribute(cls, key, item)\n    pass\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.id_of","title":"<code>id_of(element)</code>","text":"<p>Gets the unique identifier of a given element. This function retrieves a unique identifier associated with the 'element' parameter. If the 'element' has an 'id' attribute, that value is returned. Otherwise, this function falls back to Python's built-in <code>id()</code> function to return a unique identifier.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which the unique identifier is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The unique identifier for the 'element'. If 'id' attribute exists it is returned; otherwise, the result of <code>id(element)</code> is returned.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def id_of(element: ElementType) -&gt; int:\n    \"\"\"\n    Gets the unique identifier of a given element.\n    This function retrieves a unique identifier associated with the 'element' parameter.\n    If the 'element' has an '__id__' attribute, that value is returned. Otherwise, this function\n    falls back to Python's built-in `id()` function to return a unique identifier.\n\n    Args:\n        element (ElementType):\n             The element for which the unique identifier is to be retrieved.\n\n    Returns:\n        int:\n             The unique identifier for the 'element'. If '__id__' attribute exists it is returned; otherwise, the result of `id(element)` is returned.\n\n    \"\"\"\n    return getattr(element, \"__id__\", id(element))\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.type_of","title":"<code>type_of(element)</code>","text":"<p>Determines the type of a given element. This function takes an element of any type and returns its type.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which to determine the type.</p> required <p>Returns:</p> Type Description <code>type[Element]</code> <p>type[Element]:  The type of the given element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def type_of(element: ElementType) -&gt; type[\"Element\"]:\n    \"\"\"\n    Determines the type of a given element.\n    This function takes an element of any type and returns its type.\n\n    Args:\n        element (ElementType):\n             The element for which to determine the type.\n\n    Returns:\n        type[Element]:\n             The type of the given element.\n\n    \"\"\"\n    return element.__type__\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.owned_elements_of","title":"<code>owned_elements_of(element)</code>","text":"<p>Generates elements owned by a given element. The function iterates over element IDs stored in the <code>__owned_elements__</code> attribute of the provided element and yields the corresponding elements from the <code>__all_elements__</code> mapping.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose owned elements are to be generated.</p> required <p>Returns:</p> Type Description <code>Generator[ElementType, None, None]</code> <p>Generator[ElementType, None, None]:  A generator that yields elements owned by the input element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def owned_elements_of(\n    element: ElementType,\n) -&gt; typing.Generator[ElementType, None, None]:\n    \"\"\"\n    Generates elements owned by a given element.\n    The function iterates over element IDs stored in the `__owned_elements__` attribute of the provided element and yields the corresponding elements from the `__all_elements__` mapping.\n\n    Args:\n        element (ElementType):\n             The element whose owned elements are to be generated.\n\n    Returns:\n        Generator[ElementType, None, None]:\n             A generator that yields elements owned by the input element.\n\n    \"\"\"\n    for owned_element_id in element.__owned_elements__:\n        yield element.__all_elements__[owned_element_id]\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.descendants_of","title":"<code>descendants_of(element)</code>","text":"<p>Generates all descendants of a given element in a hierarchy. This generator function recursively yields all the descendants of the specified element. A descendant is defined as any element that is a direct or indirect child of the given element, at any depth level in the hierarchy. Each descendant element is yielded exactly once.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose descendants are to be generated.</p> required <p>Yields:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>The next descendant element in the hierarchy.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def descendants_of(element: ElementType) -&gt; typing.Generator[ElementType, None, None]:\n    \"\"\"\n    Generates all descendants of a given element in a hierarchy.\n    This generator function recursively yields all the descendants of the specified element. A descendant is defined as any element that is a direct or indirect child of the given element, at any depth level in the hierarchy. Each descendant element is yielded exactly once.\n\n    Args:\n        element (ElementType):\n             The element whose descendants are to be generated.\n\n    Yields:\n        ElementType:\n             The next descendant element in the hierarchy.\n\n    \"\"\"\n    for owned_element in owned_elements_of(element):\n        yield owned_element\n        yield from descendants_of(owned_element)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_descendant_of","title":"<code>is_descendant_of(ancestor, descendant)</code>","text":"<p>Determines whether a specified element is a descendant of a given ancestor element.</p> <p>Parameters:</p> Name Type Description Default <code>ancestor</code> <code>ElementType</code> <p>The element to be considered as the ancestor.</p> required <code>descendant</code> <code>ElementType</code> <p>The element to check for being a descendant.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the descendant is indeed a descendant of the ancestor, otherwise False.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_descendant_of(ancestor: ElementType, descendant: ElementType) -&gt; bool:\n    \"\"\"\n    Determines whether a specified element is a descendant of a given ancestor element.\n\n    Args:\n        ancestor (ElementType):\n             The element to be considered as the ancestor.\n        descendant (ElementType):\n             The element to check for being a descendant.\n\n    Returns:\n        bool:\n             True if the descendant is indeed a descendant of the ancestor, otherwise False.\n\n    \"\"\"\n    return (\n        next(\n            (element for element in descendants_of(ancestor) if element == descendant),\n            None,\n        )\n        is not None\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.ancestors_of","title":"<code>ancestors_of(element)</code>","text":"<p>Retrieves a generator of the ancestors of a given element. The function yields the owner of the provided element, followed recursively by the owner of that owner, and so on. It continues to traverse the ownership hierarchy until it reaches an element that does not have an owner.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which to determine the ancestry.</p> required <p>Returns:</p> Type Description <code>Generator[ElementType, None, None]</code> <p>typing.Generator[ElementType, None, None]:  A generator yielding the ancestors of the given element, in the order from the direct owner to the most distant ancestor found.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def ancestors_of(element: ElementType) -&gt; typing.Generator[ElementType, None, None]:\n    \"\"\"\n    Retrieves a generator of the ancestors of a given element.\n    The function yields the owner of the provided element, followed recursively by the owner of that owner, and so on. It continues to traverse the ownership hierarchy until it reaches an element that does not have an owner.\n\n    Args:\n        element (ElementType):\n             The element for which to determine the ancestry.\n\n    Returns:\n        typing.Generator[ElementType, None, None]:\n             A generator yielding the ancestors of the given element, in the order from the direct owner to the most distant ancestor found.\n\n    \"\"\"\n    owner = owner_of(element)\n    if owner is not None:\n        yield owner\n        yield from ancestors_of(owner)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_ancestor_of","title":"<code>is_ancestor_of(descendant, ancestor)</code>","text":"<p>Determines if the provided ancestor element is an ancestor of the specified descendant element.</p> <p>Parameters:</p> Name Type Description Default <code>descendant</code> <code>ElementType</code> <p>The element that is potentially a descendant.</p> required <code>ancestor</code> <code>ElementType</code> <p>The element that is potentially an ancestor.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the ancestor is an ancestor of the descendant, otherwise False.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_ancestor_of(descendant: ElementType, ancestor: ElementType) -&gt; bool:\n    \"\"\"\n    Determines if the provided ancestor element is an ancestor of the specified descendant element.\n\n    Args:\n        descendant (ElementType):\n             The element that is potentially a descendant.\n        ancestor (ElementType):\n             The element that is potentially an ancestor.\n\n    Returns:\n        bool:\n             True if the ancestor is an ancestor of the descendant, otherwise False.\n\n    \"\"\"\n    return is_descendant_of(ancestor, descendant)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.set_model","title":"<code>set_model(element, model)</code>","text":"<p>Sets the model attribute for a given element and propagates this setting to all elements owned by it. Recursively sets the 'model' attribute of the given 'element' to the integer ID of the 'model'. It also applies the same setting to all elements that are considered owned by the 'element'. The 'owned_elements_of' generator is used to iterate over these owned elements.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which the model is being set.</p> required <code>model</code> <code>ElementType</code> <p>The model element whose ID will be used to set the 'model' attribute.</p> required Source code in <code>stateforward/model/element.py</code> <pre><code>def set_model(element: ElementType, model: ElementType):\n    \"\"\"\n    Sets the model attribute for a given element and propagates this setting to all elements owned by it.\n    Recursively sets the '__model__' attribute of the given 'element' to the integer ID of the 'model'. It also\n    applies the same setting to all elements that are considered owned by the 'element'. The 'owned_elements_of' generator is used to iterate over these owned elements.\n\n    Args:\n        element (ElementType):\n             The element for which the model is being set.\n        model (ElementType):\n             The model element whose ID will be used to set the '__model__' attribute.\n\n    \"\"\"\n    element.__model__ = id_of(model)\n    for owned_element in owned_elements_of(element):\n        set_model(owned_element, model)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.set_owner","title":"<code>set_owner(element, owner)</code>","text":"<p>Sets the owner of an element and all its owned elements to a specified owner element, then updates their model references to the model of the new owner. This function recursively assigns the owner's ID to the element and all of its owned sub-elements. It also updates the model reference for each element to match the model reference of the new owner. This procedure ensures a consistent ownership hierarchy and proper linkage to the corresponding model for each element within a given context.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose owner and model are to be updated.</p> required <code>owner</code> <code>ElementType</code> <p>The element that will be set as the new owner.</p> required <p>Returns:</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def set_owner(element: ElementType, owner: ElementType):\n    \"\"\"\n    Sets the owner of an element and all its owned elements to a specified owner element, then updates their model references to the model of the new owner.\n    This function recursively assigns the owner's ID to the element and all of its owned\n    sub-elements. It also updates the model reference for each element to match the model\n    reference of the new owner. This procedure ensures a consistent ownership hierarchy and\n    proper linkage to the corresponding model for each element within a given context.\n\n    Args:\n        element (ElementType):\n             The element whose owner and model are to be updated.\n        owner (ElementType):\n             The element that will be set as the new owner.\n\n    Returns:\n\n    \"\"\"\n    element.__owner__ = id_of(owner)\n    for owned_element in owned_elements_of(element):\n        set_owner(owned_element, element)\n    set_model(element, element.__all_elements__[owner.__model__])\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.add_owned_element_to","title":"<code>add_owned_element_to(owner, element, *, change_ownership=False)</code>","text":"<p>Adds an owned element to the specified owner, optionally changing the current ownership. This function is responsible for taking an element and adding it to the ownership structure of the given owner. If the element already has an owner and <code>change_ownership</code> is <code>False</code>, a <code>ValueError</code> is raised. If <code>True</code>, the current owner is disassociated before proceeding. The function sets the element's ownership to the given owner and appends its identifier to the owner's list of owned elements.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>ElementType</code> <p>The entity that will own the element after the operation.</p> required <code>element</code> <code>ElementType</code> <p>The element to be added to the ownership structure of the owner.</p> required <code>change_ownership</code> <code>bool</code> <p>A flag to indicate if the ownership should be changed if the element already has an owner. Defaults to <code>False</code>.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element already has an owner and <code>change_ownership</code> is <code>False</code>.</p> <p>Returns:</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def add_owned_element_to(\n    owner: ElementType,\n    element: ElementType,\n    *,\n    change_ownership: bool = False,\n):\n    \"\"\"\n    Adds an owned element to the specified owner, optionally changing the current ownership.\n    This function is responsible for taking an element and adding it to the ownership structure of the given owner.\n    If the element already has an owner and `change_ownership` is `False`, a `ValueError` is raised. If `True`, the current owner is disassociated before proceeding.\n    The function sets the element's ownership to the given owner and appends its identifier to the owner's list of owned elements.\n\n    Args:\n        owner (ElementType):\n             The entity that will own the element after the operation.\n        element (ElementType):\n             The element to be added to the ownership structure of the owner.\n        change_ownership (bool, optional):\n             A flag to indicate if the ownership should be changed if the element already has an owner. Defaults to `False`.\n\n    Raises:\n        ValueError:\n             If the element already has an owner and `change_ownership` is `False`.\n\n    Returns:\n\n    \"\"\"\n    element_owner = owner_of(element)\n    if element_owner is not None:\n        if not change_ownership:\n            raise ValueError(f\"element {element.__name__} already has an owner\")\n        remove_owned_element_from(element_owner, element)\n    set_owner(element, owner)\n    owner.__owned_elements__.append(id_of(element))\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.remove_owned_element_from","title":"<code>remove_owned_element_from(owner, element, *, disassociate=False)</code>","text":"<p>Removes an owned element from its owner and optionally disassociates related elements.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>ElementType</code> <p>The owner object from which to remove the element.</p> required <code>element</code> <code>ElementType</code> <p>The element to be removed from the owner.</p> required <code>disassociate</code> <code>bool</code> <p>Flag that indicates whether to disassociate the element from related elements. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>The element that was removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element is not owned by the given owner.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def remove_owned_element_from(\n    owner: ElementType, element: ElementType, *, disassociate: bool = False\n) -&gt; ElementType:\n    \"\"\"\n    Removes an owned element from its owner and optionally disassociates related elements.\n\n    Args:\n        owner (ElementType):\n             The owner object from which to remove the element.\n        element (ElementType):\n             The element to be removed from the owner.\n        disassociate (bool, optional):\n             Flag that indicates whether to disassociate the\n            element from related elements. Defaults to False.\n\n    Returns:\n        ElementType:\n             The element that was removed.\n\n    Raises:\n        ValueError:\n             If the element is not owned by the given owner.\n\n    \"\"\"\n    element_id = id_of(element)\n    if owner_of(element) != owner:\n        raise ValueError(f\"element {element.__name__} is not owned by {owner.__name__}\")\n    if disassociate:\n        for name, element in associations_of(element).items():\n            remove_association_from(owner, element)\n    owner.__owned_elements__.remove(element_id)\n    element.__owner__ = None\n    return element\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.add_association_to","title":"<code>add_association_to(owner, element, name=None)</code>","text":"<p>Adds an association to an owner element with a reference to another element by its unique identifier. The association is recorded in the owner's <code>__associations__</code> dictionary, with the name as the key and the unique identifier of the element as the value.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>ElementType</code> <p>The element that will hold the association.</p> required <code>element</code> <code>ElementType</code> <p>The element to which the owner element will be associated.</p> required <code>name</code> <code>str</code> <p>The key under which the association is stored. If not provided, a default or an implicit name should be determined in other parts of the codebase.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the owner does not have an <code>__associations__</code> attribute.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def add_association_to(owner: ElementType, element: ElementType, name: str = None):\n    \"\"\"\n    Adds an association to an owner element with a reference to another element by its unique identifier.\n    The association is recorded in the owner's `__associations__` dictionary, with the\n    name as the key and the unique identifier of the element as the value.\n\n    Args:\n        owner (ElementType):\n             The element that will hold the association.\n        element (ElementType):\n             The element to which the owner element will be associated.\n        name (str, optional):\n             The key under which the association is stored. If not provided,\n            a default or an implicit name should be determined in other parts of the codebase.\n\n    Raises:\n        AttributeError:\n             If the owner does not have an `__associations__` attribute.\n\n    \"\"\"\n    owner.__associations__[name] = id_of(element)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.remove_association_from","title":"<code>remove_association_from(owner, element)</code>","text":"<p>Removes the association between two ElementType objects. This function iterates over the associations of the 'owner' ElementType, comparing each associated element to the 'element' argument. If a match is found, the association is removed from the 'owner' by deleting the association entry.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>ElementType</code> <p>The ElementType object from which the association is to be removed.</p> required <code>element</code> <code>ElementType</code> <p>The ElementType object which is to be disassociated from the owner.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>The function doesn't return anything.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def remove_association_from(owner: ElementType, element: ElementType):\n    \"\"\"\n    Removes the association between two ElementType objects.\n    This function iterates over the associations of the 'owner' ElementType,\n    comparing each associated element to the 'element' argument. If a match is found,\n    the association is removed from the 'owner' by deleting the association entry.\n\n    Args:\n        owner (ElementType):\n             The ElementType object from which the association is to be removed.\n        element (ElementType):\n             The ElementType object which is to be disassociated from the owner.\n\n    Returns:\n        None:\n             The function doesn't return anything.\n\n    \"\"\"\n    for name, element in associations_of(owner).items():\n        if element == element:\n            del owner.__associations__[name]\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.associations_of","title":"<code>associations_of(element)</code>","text":"<p>Retrieves the associations of a given ElementType object. This function takes an ElementType object and returns a dictionary where the keys are the names of the associated elements, and the values are the associated ElementType instances. It works by iterating over the element's <code>__associations__</code> attribute which contains a mapping of names to element IDs, and uses the <code>__all_elements__</code> mapping attribute of the element to obtain the actual ElementType instances.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The ElementType object whose associations are to be retrieved.</p> required <p>Returns:</p> Type Description <code>dict[str, ElementType]</code> <p>dict[str, ElementType]:  A dictionary mapping names to ElementType instances representing the associations of the provided element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def associations_of(element: ElementType) -&gt; dict[str, ElementType]:\n    \"\"\"\n    Retrieves the associations of a given ElementType object.\n    This function takes an ElementType object and returns a dictionary where the keys are the names of the associated elements, and the values are the associated ElementType instances. It works by iterating over the element's `__associations__` attribute which contains a mapping of names to element IDs, and uses the `__all_elements__` mapping attribute of the element to obtain the actual ElementType instances.\n\n    Args:\n        element (ElementType):\n             The ElementType object whose associations are to be retrieved.\n\n    Returns:\n        dict[str, ElementType]:\n             A dictionary mapping names to ElementType instances representing the associations of the provided element.\n\n    \"\"\"\n    return dict(\n        (name, element.__all_elements__[element_id])\n        for name, element_id in element.__associations__.items()\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.associations_for","title":"<code>associations_for(element, associated)</code>","text":"<p>Retrieves a dictionary of associations between two elements of specified types. This function searches within the given 'element's associations, identifying and returning associations where the associated element has the same id as the 'associated' element. Each matching association is stored in the dictionary with the association name as the key and the corresponding element as the value.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element from which associations will be searched.</p> required <code>associated</code> <code>ElementType</code> <p>The element whose id is used to find matching associations.</p> required <p>Returns:</p> Type Description <code>dict[str, ElementType]</code> <p>dict[str, ElementType]:  A dictionary where each key is the name of the association, and each value is the <code>ElementType</code> instance associated with the 'associated' element's id.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def associations_for(\n    element: ElementType, associated: ElementType\n) -&gt; dict[str, ElementType]:\n    \"\"\"\n    Retrieves a dictionary of associations between two elements of specified types.\n    This function searches within the given 'element's associations, identifying and\n    returning associations where the associated element has the same id as\n    the 'associated' element. Each matching association is stored in the dictionary\n    with the association name as the key and the corresponding element as the value.\n\n    Args:\n        element (ElementType):\n             The element from which associations will be searched.\n        associated (ElementType):\n             The element whose id is used to find matching associations.\n\n    Returns:\n        dict[str, ElementType]:\n             A dictionary where each key is the name of the\n            association, and each value is the `ElementType` instance associated with\n            the 'associated' element's id.\n\n    \"\"\"\n    return dict(\n        (name, element.__all_elements__[element_id])\n        for name, element_id in element.__associations__.items()\n        if element_id == id_of(associated)\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.name_of","title":"<code>name_of(element)</code>","text":"<p>Gets the name of a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose name is to be retrieved. This can be an instance or a class.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the element. If 'element' is a class, it returns the name of the class. If 'element' is an instance of a class, it returns the name of the instance's class.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def name_of(element: ElementType) -&gt; str:\n    \"\"\"\n    Gets the name of a given element.\n\n    Args:\n        element (ElementType):\n             The element whose name is to be retrieved. This can be an instance or a class.\n\n    Returns:\n        str:\n             The name of the element. If 'element' is a class, it returns the name of the class. If 'element' is an instance of a class, it returns the name of the instance's class.\n\n    \"\"\"\n    return element.__name__ if isinstance(element, type) else element.__class__.__name__\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.attributes_of","title":"<code>attributes_of(element)</code>","text":"<p>Retrieves the annotations of the attributes from a given ElementType object.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The object whose attribute annotations we want to obtain.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, typing.Any]:  A dictionary where the keys are the names of the attributes and the values are the corresponding annotations.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def attributes_of(element: ElementType) -&gt; dict[str, typing.Any]:\n    \"\"\"\n    Retrieves the annotations of the attributes from a given ElementType object.\n\n    Args:\n        element (ElementType):\n             The object whose attribute annotations we want to obtain.\n\n    Returns:\n        dict[str, typing.Any]:\n             A dictionary where the keys are the names of the attributes and the values are the corresponding annotations.\n\n    \"\"\"\n    return element.__annotations__\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.qualified_name_of","title":"<code>qualified_name_of(element)</code>","text":"<p>Determines the fully qualified name of the provided <code>element</code> by traversing its ownership hierarchy. This function ascertains the complete dotted path name of the element starting from the top-level owner down to the element itself. This is useful for identifying elements within a nested structure with their full context.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which to determine the qualified name. The ElementType is a type that is assumed to have <code>__name__</code> and <code>__owner__</code> attributes or a way to identify its owner and its container.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representing the fully qualified name of the element. The function first identifies the owner of the element, then recursively constructs the qualified name by prepending the name of the owner (if any) followed by a dot and then the name of the element itself. If the element does not have an owner, the function simply returns the name of the element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def qualified_name_of(element: ElementType) -&gt; str:\n    \"\"\"\n    Determines the fully qualified name of the provided `element` by traversing its ownership hierarchy.\n    This function ascertains the complete dotted path name of the element starting from the top-level owner down to the element itself. This is useful for identifying elements within a nested structure with their full context.\n\n    Args:\n        element (ElementType):\n             The element for which to determine the qualified name. The ElementType is\n            a type that is assumed to have `__name__` and `__owner__` attributes or a way to identify its\n            owner and its container.\n\n    Returns:\n        str:\n             A string representing the fully qualified name of the element.\n            The function first identifies the owner of the element, then recursively constructs the qualified name\n            by prepending the name of the owner (if any) followed by a dot and then the name of the element itself.\n            If the element does not have an owner, the function simply returns the name of the element.\n\n    \"\"\"\n    owner = owner_of(element)\n    if owner is None:\n        return name_of(element)\n    return f\"{qualified_name_of(owner)}.{name_of(element)}\"\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_type","title":"<code>is_type(element, types)</code>","text":"<p>Determines if an element is of a given type or types. This function checks if the provided element is either an instance of, or a subclass of, the given type or types. It supports checking against a single type or a collection of types. If multiple types are provided, the function will return True if the element matches any one of the types.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element to check.</p> required <code>types</code> <code>Union[type, Collection[type]]</code> <p>A single type or a collection of types against which to check the element.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the element is an instance of one of the types or is a subclass of one of the types, otherwise False.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_type(\n    element: ElementType, types: typing.Union[type, typing.Collection[type]]\n) -&gt; bool:\n    \"\"\"\n    Determines if an element is of a given type or types.\n    This function checks if the provided element is either an instance of, or a subclass of,\n    the given type or types. It supports checking against a single type or a collection\n    of types. If multiple types are provided, the function will return True if the element\n    matches any one of the types.\n\n    Args:\n        element (ElementType):\n             The element to check.\n        types (typing.Union[type, typing.Collection[type]]):\n             A single type or a collection of types\n            against which to check the element.\n\n    Returns:\n        bool:\n             True if the element is an instance of one of the types or is a subclass of one\n            of the types, otherwise False.\n\n    \"\"\"\n    return (\n        issubclass(element, types)\n        if isinstance(element, type)\n        else isinstance(element, types)\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_subtype","title":"<code>is_subtype(element, types)</code>","text":"<p>Determines if a given element type is a subtype of specified types. This function checks if the provided <code>element</code> is not exactly one of the <code>types</code> and subsequently verifies if it is a subclass or an instance of the given <code>types</code>.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element or type to check.</p> required <code>types</code> <code>Union[type, Collection[type]]</code> <p>A single type or a collection of types to compare with the <code>element</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>element</code> is a subtype of any of the given <code>types</code>, otherwise False.</p> <p>Note:</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_subtype(\n    element: ElementType, types: typing.Union[type, typing.Collection[type]]\n) -&gt; bool:\n    \"\"\"\n    Determines if a given element type is a subtype of specified types.\n    This function checks if the provided `element` is not exactly one of the `types` and subsequently verifies if it is a subclass or an instance of the given `types`.\n\n    Args:\n        element (ElementType):\n             The element or type to check.\n        types (Union[type, Collection[type]]):\n             A single type or a collection of types to compare with the `element`.\n\n    Returns:\n        bool:\n             True if `element` is a subtype of any of the given `types`, otherwise False.\n\n    Note:\n\n    \"\"\"\n    if is_element(types):\n        types = (types,)\n    return element not in types and is_type(element, types)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_element","title":"<code>is_element(value)</code>","text":"<p>Determines whether a given value is an instance of the Element type or a subtype thereof. This function checks if the provided value is an instance of Element or any class derived from Element.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to be checked.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if 'value' is an instance of Element or a derived class, otherwise False.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_element(value: typing.Any) -&gt; bool:\n    \"\"\"\n    Determines whether a given value is an instance of the Element type or a subtype thereof.\n    This function checks if the provided value is an instance of Element or any class derived from Element.\n\n    Args:\n        value (typing.Any):\n             The value to be checked.\n\n    Returns:\n        bool:\n             True if 'value' is an instance of Element or a derived class, otherwise False.\n\n    \"\"\"\n    return is_type(value, Element)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.owner_of","title":"<code>owner_of(element)</code>","text":"<p>Determines the owner of a given element. The function checks if the provided 'element' is an instance of the Element type and retrieves its owner attribute. If the element is not an instance of Element, it attempts to look up the owner in the element's 'all_elements' dictionary using the element's 'owner' attribute as the key. The function then returns the owner of the element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element for which the owner is to be determined.</p> required <p>Returns:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>The owner of the provided element. If the element is an instance of the Element type, returns the value of its owner attribute. If not, returns the corresponding value from the element's 'all_elements' dictionary for the key 'owner'.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If 'owner' or 'all_elements' attributes do not exist on the provided element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def owner_of(element: ElementType) -&gt; ElementType:\n    \"\"\"\n    Determines the owner of a given element.\n    The function checks if the provided 'element' is an instance of the Element type and retrieves its owner attribute. If the element is not an instance of Element, it attempts to look up the owner in the element's '__all_elements__' dictionary using the element's '__owner__' attribute as the key. The function then returns the owner of the element.\n\n    Args:\n        element (ElementType):\n             The element for which the owner is to be determined.\n\n    Returns:\n        ElementType:\n             The owner of the provided element. If the element is an instance of the Element type, returns the value of its __owner__ attribute. If not, returns the corresponding value from the element's '__all_elements__' dictionary for the key '__owner__'.\n\n    Raises:\n        AttributeError:\n             If '__owner__' or '__all_elements__' attributes do not exist on the provided element.\n\n    \"\"\"\n    return (\n        element.__owner__\n        if isinstance(element, Element)\n        else element.__all_elements__.get(element.__owner__, None)\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.redefined_element_of","title":"<code>redefined_element_of(element)</code>","text":"<p>Retrieves the redefined element from the given element object. This function fetches the 'redefined_element' attribute from the element passed to it. It expects a predefined attribute 'redefined_element' to be present on the 'element' which is the redefined version of the element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element from which the redefined version will be retrieved.</p> required <p>Returns:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>The redefined version of the element.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the element does not have 'redefined_element' attribute.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def redefined_element_of(element: ElementType) -&gt; ElementType:\n    \"\"\"\n    Retrieves the redefined element from the given element object.\n    This function fetches the '__redefined_element__' attribute from the element passed to it. It expects a\n    predefined attribute '__redefined_element__' to be present on the 'element' which is the redefined version of the element.\n\n    Args:\n        element (ElementType):\n             The element from which the redefined version will be retrieved.\n\n    Returns:\n        ElementType:\n             The redefined version of the element.\n\n    Raises:\n        AttributeError:\n             If the element does not have '__redefined_element__' attribute.\n\n    \"\"\"\n    return element.__redefined_element__\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_owner_of","title":"<code>is_owner_of(owner, element)</code>","text":"<p>Determines if the provided 'owner' is the owner of the 'element'.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>ElementType</code> <p>The potential owner whose ownership is being checked.</p> required <code>element</code> <code>ElementType</code> <p>The element for which ownership is being verified.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if 'owner' is the owner of 'element', otherwise False.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_owner_of(owner: ElementType, element: ElementType) -&gt; bool:\n    \"\"\"\n    Determines if the provided 'owner' is the owner of the 'element'.\n\n    Args:\n        owner (ElementType):\n             The potential owner whose ownership is being checked.\n        element (ElementType):\n             The element for which ownership is being verified.\n\n    Returns:\n        bool:\n             True if 'owner' is the owner of 'element', otherwise False.\n\n    \"\"\"\n    return owner_of(element) == owner\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.specialize","title":"<code>specialize(base, derived, **kwargs)</code>","text":"<p>Specializes the given base ElementType by deriving a new ElementType with properties and associations of the base type adjusted for the derived type. This function works by iterating through the owned elements of the base ElementType and creating a new owned element for each of them within the derived ElementType with redefinitions as needed. Associations within the base ElementType are also remapped to corresponding elements within the derived ElementType. If the base ElementType has no owner, a mapping is established between the base elements and the new elements, and associations are adapted accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>ElementType</code> <p>The base element type from which the new derived type will be created.</p> required <code>derived</code> <code>ElementType</code> <p>The new element type that will inherit and specialize from the base type.</p> required <code>**kwargs</code> <p>Additional keyword arguments (unused).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <p>The function performs in-place specialization and does not return any value.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def specialize(base: ElementType, derived: ElementType, **kwargs):\n    \"\"\"\n    Specializes the given base ElementType by deriving a new ElementType with properties and associations of the base type adjusted for the derived type.\n    This function works by iterating through the owned elements of the base ElementType and creating a new owned element for each of them within the derived ElementType with redefinitions as needed. Associations within the base ElementType are also remapped to corresponding elements within the derived ElementType. If the base ElementType has no owner, a mapping is established between the base elements and the new elements, and associations are adapted accordingly.\n\n    Args:\n        base (ElementType):\n             The base element type from which the new derived type will be created.\n        derived (ElementType):\n             The new element type that will inherit and specialize from the base type.\n        **kwargs:\n             Additional keyword arguments (unused).\n\n    Returns:\n        None:\n             The function performs in-place specialization and does not return any value.\n\n    \"\"\"\n    # we have to create copies of the base core during inheritance\n    # loop through base owned element mapping\n    for owned_element_id in base.__owned_elements__:\n        # get the owned element\n        owned_element = base.__all_elements__[owned_element_id]\n        # create a new owned element\n        new_owned_element = typing.cast(\n            ElementType,\n            types.new_class(\n                owned_element.__name__,\n                (owned_element,),\n                {\n                    \"redefined_element\": base,\n                },\n            ),\n        )\n        add_owned_element_to(derived, new_owned_element)\n\n    if owner_of(base) is None:\n        base_elements = (base, *descendants_of(base))\n        new_elements = (derived, *descendants_of(derived))\n        element_map = dict(\n            (id_of(base), id_of(derived))\n            for base, derived in zip(base_elements, new_elements)\n        )\n\n        for index, element in enumerate(base_elements):\n            new_element = new_elements[index]\n            for name, element_id in element.__associations__.items():\n                associated_id = new_element.__associations__[name] = element_map[\n                    element_id\n                ]\n                setattr(new_element, name, new_element.__all_elements__[associated_id])\n    return None\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.is_redefined","title":"<code>is_redefined(element)</code>","text":"<p>Determines if the provided element has been redefined. This function checks whether the element passed to it has a redefined counterpart by calling the 'redefined_element_of' function and inspecting if the returned value is not None.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element to check for a redefinition.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the element has been redefined, False otherwise.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def is_redefined(element: ElementType) -&gt; bool:\n    \"\"\"\n    Determines if the provided element has been redefined.\n    This function checks whether the element passed to it has a redefined counterpart by calling the 'redefined_element_of' function and\n    inspecting if the returned value is not None.\n\n    Args:\n        element (ElementType):\n             The element to check for a redefinition.\n\n    Returns:\n        bool:\n             True if the element has been redefined, False otherwise.\n\n    \"\"\"\n    return redefined_element_of(element) is not None\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.redefine","title":"<code>redefine(element, **kwargs)</code>","text":"<p>Redefines an existing element by creating a new subclass with additional properties. The <code>redefine</code> function takes an existing class or type (referred to as <code>element</code>) and returns a new class that is a subclass of the given <code>element</code>. This subclass can incorporate additional properties that are passed to the function as keyword arguments (<code>**kwargs</code>). The original class/type is also stored as an attribute <code>redefined_element</code> in the newly created subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The original class or type that is to be redefined into a new subclass.</p> required <code>**kwargs</code> <p>Arbitrary keyword arguments that represent additional properties to be included in the new subclass.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ElementType</code> <p>A new subclass of the provided <code>element</code>, with added keyword arguments as attributes.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def redefine(element: ElementType, **kwargs):\n    \"\"\"\n    Redefines an existing element by creating a new subclass with additional properties.\n    The `redefine` function takes an existing class or type (referred to as `element`) and returns a new class that is a subclass of the given `element`. This subclass can incorporate additional properties that are passed to the function as keyword arguments (`**kwargs`). The original class/type is also stored as an attribute `redefined_element` in the newly created subclass.\n\n    Args:\n        element (ElementType):\n             The original class or type that is to be redefined into a new subclass.\n        **kwargs:\n             Arbitrary keyword arguments that represent additional properties to be included in the new subclass.\n\n    Returns:\n        ElementType:\n             A new subclass of the provided `element`, with added keyword arguments as attributes.\n\n    \"\"\"\n    return typing.cast(\n        ElementType,\n        types.new_class(\n            name_of(element),\n            kwargs.pop(\"bases\", (element,)),\n            {\n                \"redefined_element\": element,\n                **kwargs,\n            },\n        ),\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.find_owned_elements_of","title":"<code>find_owned_elements_of(element, condition)</code>","text":"<p>Generates elements owned by a given element that meet a specified condition. This generator function iterates through elements owned by the provided <code>element</code> and yields each owned element that satisfies the <code>condition</code> function. The <code>condition</code> function should take an <code>ElementType</code> as its argument and return a boolean indicating whether the element meets the desired criteria.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose owned elements are to be examined.</p> required <code>condition</code> <code>Callable[[ElementType], bool]</code> <p>A function that takes an <code>ElementType</code> as an argument and returns True if the element satisfies the condition; otherwise, False.</p> required <p>Returns:</p> Type Description <code>Generator[ElementType, None, None]</code> <p>Generator[ElementType, None, None]:  A generator yielding owned elements of the provided <code>element</code> that satisfy the <code>condition</code>.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def find_owned_elements_of(\n    element: \"ElementType\", condition: typing.Callable[[\"ElementType\"], bool]\n) -&gt; typing.Generator[\"ElementType\", None, None]:\n    \"\"\"\n    Generates elements owned by a given element that meet a specified condition.\n    This generator function iterates through elements owned by the provided `element` and yields each owned element that satisfies the `condition` function. The `condition` function should take an `ElementType` as its argument and return a boolean indicating whether the element meets the desired criteria.\n\n    Args:\n        element (ElementType):\n             The element whose owned elements are to be examined.\n        condition (Callable[[ElementType], bool]):\n             A function that takes an `ElementType` as an argument and returns True if the element satisfies the condition; otherwise, False.\n\n    Returns:\n        Generator[ElementType, None, None]:\n             A generator yielding owned elements of the provided `element` that satisfy the `condition`.\n\n    \"\"\"\n    for owned_element in owned_elements_of(element):\n        if condition(owned_element):\n            yield owned_element\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.find_owned_element_of","title":"<code>find_owned_element_of(element, condition)</code>","text":"<p>Finds the first element within a given element's ownership hierarchy that satisfies a specified condition. This function traverses the ownership structure of the provided element to locate the first child or descendant that meets the criteria defined by the <code>condition</code> callable. If such an element is found, it is returned; otherwise, the function returns <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element from which the search for owned elements should begin.</p> required <code>condition</code> <code>Callable[[ElementType], bool]</code> <p>A function that takes an element of type <code>ElementType</code> as a single argument and returns a boolean value. The function should return <code>True</code> for an element that fulfills the search criteria and <code>False</code> otherwise.</p> required <p>Returns:</p> Type Description <code>Optional[ElementType]</code> <p>Optional[ElementType]:  The first element that satisfies the condition, or <code>None</code> if no matching element is found.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def find_owned_element_of(\n    element: \"ElementType\", condition: typing.Callable[[\"ElementType\"], bool]\n) -&gt; typing.Optional[\"ElementType\"]:\n    \"\"\"\n    Finds the first element within a given element's ownership hierarchy that satisfies a specified condition.\n    This function traverses the ownership structure of the provided element to locate the first child or descendant\n    that meets the criteria defined by the `condition` callable. If such an element is found, it is returned;\n    otherwise, the function returns `None`.\n\n    Args:\n        element (ElementType):\n             The element from which the search for owned elements should begin.\n        condition (Callable[[ElementType], bool]):\n             A function that takes an element of type `ElementType` as a single argument\n            and returns a boolean value. The function should return `True` for an element that fulfills the\n            search criteria and `False` otherwise.\n\n    Returns:\n        Optional[ElementType]:\n             The first element that satisfies the condition, or `None` if no matching element is found.\n\n    \"\"\"\n    return next(find_owned_elements_of(element, condition), None)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.find_ancestors_of","title":"<code>find_ancestors_of(element, condition)</code>","text":"<p>Generates a sequence of ancestor elements of a given element that satisfy a specified condition. This generator function traverses the ancestor hierarchy of the provided element, testing each ancestor against a condition function. It yields each ancestor element that meets the criteria defined by the condition function. The traversal continues until the root of the hierarchy is reached or the generator is exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose ancestors are to be found.</p> required <code>condition</code> <code>Callable[[ElementType], bool]</code> <p>A callable that takes an element as its single argument and returns a boolean indicating whether the element meets the desired condition.</p> required <p>Yields:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>Ancestors of the initial element that satisfy the condition.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def find_ancestors_of(\n    element: \"ElementType\", condition: typing.Callable[[\"ElementType\"], bool]\n) -&gt; typing.Generator[\"ElementType\", None, None]:\n    \"\"\"\n    Generates a sequence of ancestor elements of a given element that satisfy a specified condition.\n    This generator function traverses the ancestor hierarchy of the provided element, testing each ancestor against a condition function.\n    It yields each ancestor element that meets the criteria defined by the condition function. The traversal continues until the root of the hierarchy is reached or the generator is exhausted.\n\n    Args:\n        element (ElementType):\n             The element whose ancestors are to be found.\n        condition (typing.Callable[[ElementType], bool]):\n             A callable that takes an element as its single argument\n            and returns a boolean indicating whether the element meets the desired condition.\n\n    Yields:\n        ElementType:\n             Ancestors of the initial element that satisfy the condition.\n\n    \"\"\"\n    for element in ancestors_of(element):\n        if condition(element):\n            yield element\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.find_ancestor_of","title":"<code>find_ancestor_of(element, expr)</code>","text":"<p>Finds the first ancestor of a specified element that matches a given condition.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element from which to begin the search for an ancestor.</p> required <code>expr</code> <code>Callable[[ElementType], bool]</code> <p>A function that takes an element as an argument and returns True if the element matches the condition, False otherwise.</p> required <p>Returns:</p> Type Description <code>Optional[ElementType]</code> <p>typing.Optional['ElementType']:  The first ancestor element that matches the condition specified by expr. If no matching ancestor is found, returns None.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def find_ancestor_of(\n    element: \"ElementType\", expr: typing.Callable[[\"ElementType\"], bool]\n) -&gt; typing.Optional[\"ElementType\"]:\n    \"\"\"\n    Finds the first ancestor of a specified element that matches a given condition.\n\n    Args:\n        element (ElementType):\n             The element from which to begin the search for an ancestor.\n        expr (typing.Callable[['ElementType'], bool]):\n             A function that takes an element as an argument and returns True if the element matches the condition, False otherwise.\n\n    Returns:\n        typing.Optional['ElementType']:\n             The first ancestor element that matches the condition specified by expr. If no matching ancestor is found, returns None.\n\n    \"\"\"\n    return next(find_ancestors_of(element, expr), None)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.find_descendants_of","title":"<code>find_descendants_of(element, condition)</code>","text":"<p>Finds and yields descendants of a given element that satisfy a specified condition. This generator function traverses through the descendants of the provided element, checking each one against the given condition function. If a descendant meets the condition, it is yielded.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The element whose descendants will be checked.</p> required <code>condition</code> <code>Callable[[ElementType], bool]</code> <p>A function that takes an element as its argument and returns True if the element satisfies the condition, otherwise False.</p> required <p>Yields:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>The next descendant of 'element' that satisfies the 'condition'.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def find_descendants_of(\n    element: \"ElementType\",\n    condition: typing.Callable[[\"ElementType\"], bool],\n) -&gt; typing.Generator[\"ElementType\", None, None]:\n    \"\"\"\n    Finds and yields descendants of a given element that satisfy a specified condition.\n    This generator function traverses through the descendants of the provided element, checking each one\n    against the given condition function. If a descendant meets the condition, it is yielded.\n\n    Args:\n        element (ElementType):\n             The element whose descendants will be checked.\n        condition (Callable[[ElementType], bool]):\n             A function that takes an element as its argument\n            and returns True if the element satisfies the condition, otherwise False.\n\n    Yields:\n        ElementType:\n             The next descendant of 'element' that satisfies the 'condition'.\n\n    \"\"\"\n    for element in descendants_of(element):\n        if condition(element):\n            yield element\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.set_attribute","title":"<code>set_attribute(element, name, value)</code>","text":"<p>Sets an attribute for an ElementType object with special handling for Element objects. This method sets an attribute on an ElementType object with the given name and value. If the value is an Element, additional steps are taken to manage ownership and associations. If the Element is not owned by any ElementType, or if it's a descendant of 'element' and it doesn't belong to a different model, it will be added to 'element's owned elements. Furthermore, an association between 'element' and the value is established using the name as the key. If the provided value is not an Element, the attribute is simply set on 'element' with the provided name and value.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>The ElementType object to which the attribute should be set.</p> required <code>name</code> <code>str</code> <p>The name of the attribute to be set.</p> required <code>value</code> <code>Any</code> <p>The value to be assigned to the attribute. If an Element, ownership and association logic applies.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Element value is owned by a different model and is not a descendant of 'element', or if any ownership related issues are encountered.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def set_attribute(\n    element: ElementType,\n    name: str,\n    value: typing.Any,\n):\n    \"\"\"\n    Sets an attribute for an ElementType object with special handling for Element objects.\n    This method sets an attribute on an ElementType object with the given name and value. If the value is an Element,\n    additional steps are taken to manage ownership and associations. If the Element is not owned by any ElementType, or if\n    it's a descendant of 'element' and it doesn't belong to a different model, it will be added to 'element's owned\n    elements. Furthermore, an association between 'element' and the value is established using the name as the key.\n    If the provided value is not an Element, the attribute is simply set on 'element' with the provided name and value.\n\n    Args:\n        element (ElementType):\n             The ElementType object to which the attribute should be set.\n        name (str):\n             The name of the attribute to be set.\n        value (typing.Any):\n             The value to be assigned to the attribute. If an Element, ownership and\n            association logic applies.\n\n    Raises:\n        ValueError:\n             If the Element value is owned by a different model and is not a descendant\n            of 'element', or if any ownership related issues are encountered.\n\n    \"\"\"\n    if is_element(value):\n        value_id = id_of(value)\n        if value_id not in element.__owned_elements__:\n            owner = owner_of(value)\n            change_ownership = (\n                owner is None or is_descendant_of(element, owner)\n            ) and element.__model__ != id_of(value)\n            if change_ownership:\n                add_owned_element_to(element, value, change_ownership=change_ownership)\n        add_association_to(element, value, name)\n    setattr(element, name, value)\n</code></pre>"},{"location":"Python/API/Modelling/Element/#stateforward.model.element.new","title":"<code>new(name, bases=None, **kwargs)</code>","text":"<p>Creates a new class with the given name, optional base classes, and any additional keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new class.</p> required <code>bases</code> <code>Collection[type]</code> <p>An optional collection of base classes for the new class. Defaults to a tuple only containing Element.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that will be included as class attributes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>type[T]</code> <p>type[T]:  A new class of type T that is derived from the specified base classes and includes the provided keyword arguments as class attributes.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def new(name: str, bases: typing.Collection[type] = None, **kwargs) -&gt; type[T]:\n    \"\"\"\n    Creates a new class with the given name, optional base classes, and any additional keyword arguments.\n\n    Args:\n        name (str):\n             The name of the new class.\n        bases (typing.Collection[type], optional):\n             An optional collection of base classes for the new class. Defaults to a tuple only containing Element.\n        **kwargs:\n             Arbitrary keyword arguments that will be included as class attributes.\n\n    Returns:\n        type[T]:\n             A new class of type T that is derived from the specified base classes and includes the provided keyword arguments as class attributes.\n\n    \"\"\"\n    return typing.cast(\n        type[T],\n        types.new_class(\n            name,\n            bases or (Element,),\n            {\n                **kwargs,\n            },\n        ),\n    )\n</code></pre>"},{"location":"Python/API/Modelling/Model/","title":"Model","text":""},{"location":"Python/API/Modelling/Model/#stateforward.model.model","title":"<code>model</code>","text":"<p>The <code>model</code> module defines the structure and behavior of a <code>Model</code> class which is an extension of the <code>Element</code> class. This module also provides utility functions to interact with model instances and to perform various operations such as model creation and instance retrieval.</p>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model--model-class","title":"Model class","text":"<p>The <code>Model</code> class is an abstract base class that represents a generic model in the system. It is designed to be subclassed to create specific types of models. It includes special methods for model initialization (<code>__init_subclass__</code>) and instance creation (<code>__create__</code>). The <code>Model</code> class keeps track of all instances of itself and derived classes using a class attribute <code>__all_instances__</code>, which is a dictionary of model instances indexed by their unique identifiers.</p>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model--class-variables","title":"Class Variables","text":"<ul> <li><code>__all_instances__</code>: A dictionary that keeps track of all created model instances.</li> <li><code>preprocessor</code>: A variable that should be assigned a <code>Preprocessor</code> class. This preprocessor is applied to the model class during subclass initialization.</li> <li><code>validator</code>: A variable that should be assigned a <code>Validator</code> class. This validator is applied during subclass initialization for the purpose of validating the model class.</li> <li><code>interpreter</code>: An instance of the <code>Interpreter</code> protocol that is intended to be used with the model.</li> </ul>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model--special-methods","title":"Special Methods","text":"<ul> <li><code>__init_subclass__</code>: This method is automatically called when a subclass of <code>Model</code> is created. It is responsible for running the associated preprocessor and validator, if they are provided.</li> <li><code>__create__</code>: This protected class method creates an instance of the model and registers it in <code>__all_instances__</code>.</li> </ul>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model--utility-functions","title":"Utility Functions","text":"<ul> <li><code>of</code>: A function that takes an <code>ElementType</code> and returns either the <code>Model</code> class or an instance of Model associated with that element, if one exists.</li> <li><code>all_instances</code>: A function that returns a dictionary of all model instances tracked by <code>Model.__all_instances__</code>.</li> <li><code>dump</code>: A function used for debugging, which prints out a representation of the model elements hierarchy. It takes an <code>Element</code> object, an optional level of indentation, and an optional associated name. The output shows the model elements' types or object instances, qualified names, and associations.</li> </ul>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model--typing-imports","title":"Typing Imports","text":"<p>The module includes relevant imports from the <code>typing</code> module and other components from within the stateforward package that are used for type annotations. These imports also make use of conditional import statements to prevent circular dependencies when types are used for annotations only (<code>typing.TYPE_CHECKING</code>).</p>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.Model","title":"<code>Model</code>","text":"<p>             Bases: <code>Element</code></p> <p>A base class for creating model elements with built-in pre-processing and validation capabilities. This class is designed to be subclassed for creating different types of model elements that require initial pre-processing and validation steps upon creation. It maintains a registry dictionary of all instances of its subclasses.</p> <p>Attributes:</p> Name Type Description <code>__all_instances__</code> <code>dict[str, Model]</code> <p>A class-level dictionary mapping unique identifiers to instances of Model subclasses.</p> <code>preprocessor</code> <code>ClassVar[type[Preprocessor]]</code> <p>A class attribute that should be overridden with a specific Preprocessor subclass if pre-processing is needed.</p> <code>validator</code> <code>ClassVar[type[Validator]]</code> <p>A class attribute that should be overridden with a specific Validator subclass if validation is needed.</p> <code>interpreter</code> <code>Interpreter</code> <p>An instance attribute that can be set to an Interpreter object if needed.</p> <p>Methods:</p> Name Description <code>__init_subclass__</code> <p>type['Model'], **kwargs): A class method automatically called when a subclass is created. This method applies pre-processing and validation to the subclass using its preprocessor and validator class attributes.</p> <code>__create__</code> <p>A class method that is used to create instances of the subclass. It registers the instance in the all_instances dictionary using its unique identifier and then returns the instance. Subclasses should define their own preprocessor and validator if specific actions should be taken during instantiation.</p> Source code in <code>stateforward/model/model.py</code> <pre><code>class Model(Element):\n    \"\"\"\n    A base class for creating model elements with built-in pre-processing and validation capabilities.\n    This class is designed to be subclassed for creating different types of model elements that require\n    initial pre-processing and validation steps upon creation. It maintains a registry dictionary\n    of all instances of its subclasses.\n\n    Attributes:\n        __all_instances__ (dict[str, 'Model']):\n             A class-level dictionary mapping unique identifiers to instances of Model subclasses.\n        preprocessor (typing.ClassVar[type['Preprocessor']]):\n             A class attribute that should be overridden with a specific Preprocessor subclass if pre-processing is needed.\n        validator (typing.ClassVar[type['Validator']]):\n             A class attribute that should be overridden with a specific Validator subclass if validation is needed.\n        interpreter ('Interpreter'):\n             An instance attribute that can be set to an Interpreter object if needed.\n\n    Methods:\n        __init_subclass__(cls:\n             type['Model'], **kwargs):\n            A class method automatically called when a subclass is created. This method applies\n            pre-processing and validation to the subclass using its preprocessor and validator class attributes.\n        __create__(cls, **kwargs):\n            A class method that is used to create instances of the subclass. It registers the instance in\n            the __all_instances__ dictionary using its unique identifier and then returns the instance.\n            Subclasses should define their own preprocessor and validator if specific actions should be taken during instantiation.\n\n    \"\"\"\n\n    __all_instances__: dict[str, \"Model\"] = {}\n    preprocessor: typing.ClassVar[type[\"Preprocessor\"]] = None\n    validator: typing.ClassVar[type[\"Validator\"]] = None\n    interpreter: \"Interpreter\" = None\n\n    def __init_subclass__(\n        cls: type[\"Model\"],\n        **kwargs,\n    ):\n        \"\"\"\n        Initializes the subclass of a `Model` class.\n        This method is automatically invoked during the creation of a subclass of `Model`. It starts by invoking the same method in the superclass (if there is one) to ensure that any higher-level initialization occurs as usual. Following this, it checks if the subclass has defined either a `preprocessor` or a `validator`. If a `preprocessor` is defined, it creates an instance of this preprocessor and calls its `preprocess` method, passing in the subclass itself as an argument. Similarly, if a `validator` is defined, this method creates an instance of the validator and calls its `validate` method with the subclass.\n\n        Args:\n            cls (type[Model]):\n                 The subclass of `Model` that is currently being initialized.\n            Keyword Args:\n            **kwargs:\n                 Variable length keyword arguments that are passed to the superclass's `__init_subclass__` method.\n\n        Raises:\n            TypeError:\n                 If any mandatory base class initializations are omitted or incorrect arguments are provided.\n\n        \"\"\"\n        preprocessor = cls.preprocessor\n        validator = cls.validator\n        super().__init_subclass__(**kwargs)\n        if not is_redefined(cls):\n            if preprocessor is not None:\n                preprocessor().preprocess(cls)\n            if validator is not None:\n                validator().validate(cls)\n\n    @classmethod\n    def __create__(cls, **kwargs):\n        \"\"\"\n        Creates a new instance of a model and registers it in the model's instance dictionary.\n        This method is a class method that creates a new instance of the class using\n        the provided keyword arguments. It utilizes the built-in __create__ method\n        to initialize the instance and then stores it in a class-level dictionary\n        identified by the instance's unique identifier. This allows for easy access to\n        all instances of the model.\n\n        Args:\n            **kwargs:\n                 Arbitrary keyword arguments passed to the model's constructor\n                during instance creation.\n\n        Returns:\n\n        Raises:\n\n        \"\"\"\n        self = super().__create__(**kwargs)\n        Model.__all_instances__[self.__id__] = self\n        return self\n</code></pre>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.Model.__create__","title":"<code>__create__(**kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a new instance of a model and registers it in the model's instance dictionary. This method is a class method that creates a new instance of the class using the provided keyword arguments. It utilizes the built-in create method to initialize the instance and then stores it in a class-level dictionary identified by the instance's unique identifier. This allows for easy access to all instances of the model.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments passed to the model's constructor during instance creation.</p> <code>{}</code> <p>Returns:</p> <p>Raises:</p> Source code in <code>stateforward/model/model.py</code> <pre><code>@classmethod\ndef __create__(cls, **kwargs):\n    \"\"\"\n    Creates a new instance of a model and registers it in the model's instance dictionary.\n    This method is a class method that creates a new instance of the class using\n    the provided keyword arguments. It utilizes the built-in __create__ method\n    to initialize the instance and then stores it in a class-level dictionary\n    identified by the instance's unique identifier. This allows for easy access to\n    all instances of the model.\n\n    Args:\n        **kwargs:\n             Arbitrary keyword arguments passed to the model's constructor\n            during instance creation.\n\n    Returns:\n\n    Raises:\n\n    \"\"\"\n    self = super().__create__(**kwargs)\n    Model.__all_instances__[self.__id__] = self\n    return self\n</code></pre>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.Model.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Initializes the subclass of a <code>Model</code> class. This method is automatically invoked during the creation of a subclass of <code>Model</code>. It starts by invoking the same method in the superclass (if there is one) to ensure that any higher-level initialization occurs as usual. Following this, it checks if the subclass has defined either a <code>preprocessor</code> or a <code>validator</code>. If a <code>preprocessor</code> is defined, it creates an instance of this preprocessor and calls its <code>preprocess</code> method, passing in the subclass itself as an argument. Similarly, if a <code>validator</code> is defined, this method creates an instance of the validator and calls its <code>validate</code> method with the subclass.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Model]</code> <p>The subclass of <code>Model</code> that is currently being initialized.</p> required <code>Keyword</code> <code>Args</code> required <code>**kwargs</code> <p>Variable length keyword arguments that are passed to the superclass's <code>__init_subclass__</code> method.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any mandatory base class initializations are omitted or incorrect arguments are provided.</p> Source code in <code>stateforward/model/model.py</code> <pre><code>def __init_subclass__(\n    cls: type[\"Model\"],\n    **kwargs,\n):\n    \"\"\"\n    Initializes the subclass of a `Model` class.\n    This method is automatically invoked during the creation of a subclass of `Model`. It starts by invoking the same method in the superclass (if there is one) to ensure that any higher-level initialization occurs as usual. Following this, it checks if the subclass has defined either a `preprocessor` or a `validator`. If a `preprocessor` is defined, it creates an instance of this preprocessor and calls its `preprocess` method, passing in the subclass itself as an argument. Similarly, if a `validator` is defined, this method creates an instance of the validator and calls its `validate` method with the subclass.\n\n    Args:\n        cls (type[Model]):\n             The subclass of `Model` that is currently being initialized.\n        Keyword Args:\n        **kwargs:\n             Variable length keyword arguments that are passed to the superclass's `__init_subclass__` method.\n\n    Raises:\n        TypeError:\n             If any mandatory base class initializations are omitted or incorrect arguments are provided.\n\n    \"\"\"\n    preprocessor = cls.preprocessor\n    validator = cls.validator\n    super().__init_subclass__(**kwargs)\n    if not is_redefined(cls):\n        if preprocessor is not None:\n            preprocessor().preprocess(cls)\n        if validator is not None:\n            validator().validate(cls)\n</code></pre>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.of","title":"<code>of(element)</code>","text":"<p>Retrieves a corresponding model instance or class associated with a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>ElementType</code> <p>An instance or subclass of ElementType for which to retrieve the associated model.</p> required <p>Returns:</p> Type Description <code>Optional[Union[type[Model], Model]]</code> <p>Optional[Union[type[Model], Model]]:  The model class or model instance associated with the provided element if it exists, otherwise None.</p> Source code in <code>stateforward/model/model.py</code> <pre><code>def of(element: ElementType) -&gt; typing.Optional[typing.Union[type[Model], Model]]:\n    \"\"\"\n    Retrieves a corresponding model instance or class associated with a given element.\n\n    Args:\n        element (ElementType):\n             An instance or subclass of ElementType for which to retrieve the associated model.\n\n    Returns:\n        Optional[Union[type[Model], Model]]:\n             The model class or model instance associated with the provided element if it\n            exists, otherwise None.\n\n    \"\"\"\n    return element.__all_elements__.get(element.__model__, None)\n</code></pre>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.all_instances","title":"<code>all_instances()</code>","text":"<p>Returns a dictionary containing all instances of the Model class.</p> <p>Returns:</p> Type Description <code>dict[str, Model]</code> <p>dict[str, Model]:  A dictionary where keys are strings and values are instances of the Model class.</p> Source code in <code>stateforward/model/model.py</code> <pre><code>def all_instances() -&gt; dict[str, Model]:\n    \"\"\"\n\n    Returns a dictionary containing all instances of the Model class.\n\n    Returns:\n        dict[str, Model]:\n             A dictionary where keys are strings and values are instances\n            of the Model class.\n\n    \"\"\"\n    return Model.__all_instances__\n</code></pre>"},{"location":"Python/API/Modelling/Model/#stateforward.model.model.dump","title":"<code>dump(element, level=0, associated_name=None)</code>","text":"<p>Generates a hierarchical representation of an element and its associated elements, printing out the hierarchy to the console. The function traverses the element's owned elements and any associated elements that are not owned, recursively printing out their details, including the element's qualified name, type, base type information, and memory address. The hierarchy is presented in an indented format to illustrate the relationships between elements. If 'associated_name' is provided, the printed information will reflect the associated relationship rather than the element's actual qualified name.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <p>The ElementType instance to be dumped.</p> required <code>level</code> <code>int</code> <p>The current level in the hierarchy, used for indentation. Defaults to 0.</p> <code>0</code> <code>associated_name</code> <code>Optional[str]</code> <p>An optional name to describe the association relationship of 'element'. Defaults to None. The function does not return any value; it outputs directly to the console.</p> <code>None</code> Source code in <code>stateforward/model/model.py</code> <pre><code>def dump(\n    element,\n    level=0,\n    associated_name=None,\n):\n    \"\"\"\n    Generates a hierarchical representation of an element and its associated elements, printing out the hierarchy to the console.\n    The function traverses the element's owned elements and any associated elements that are not owned, recursively printing\n    out their details, including the element's qualified name, type, base type information, and memory address. The hierarchy\n    is presented in an indented format to illustrate the relationships between elements.\n    If 'associated_name' is provided, the printed information will reflect the associated relationship rather than the element's\n    actual qualified name.\n\n    Args:\n        element:\n             The ElementType instance to be dumped.\n        level (int):\n             The current level in the hierarchy, used for indentation. Defaults to 0.\n        associated_name (Optional[str]):\n             An optional name to describe the association relationship of 'element'. Defaults to None.\n            The function does not return any value; it outputs directly to the console.\n\n    \"\"\"\n    type_or_object = \"type\" if isinstance(element, type) else \"object\"\n    if associated_name is None:\n        base = (\n            element.__base__.__name__\n            if type_or_object == \"type\"\n            else element.__class__.__base__.__name__\n        )\n        type_name = f\"{type_or_object}[{base}]\"\n    else:\n        type_name = f\"{type_or_object}[Association&lt;{qualified_name_of(type_of(element))} @ {id_of(type_of(element))}&gt;]\"\n    address = id_of(element)\n    print(\n        f\"{level * ' '}{level} -&gt; {associated_name if associated_name is not None else qualified_name_of(element)} {type_name} @ {address}\"\n    )\n    if associated_name is None:\n        for owned_element in owned_elements_of(element):\n            dump(owned_element, level + 1)\n        for name, associated in associations_of(element).items():\n            if id_of(associated) not in element.__owned_elements__:\n                dump(\n                    associated,\n                    level + 1,\n                    f\"{qualified_name_of(element)}.{name}\",\n                )\n</code></pre>"},{"location":"Python/API/Modelling/Overview/","title":"Overview","text":"<p>The <code>__init__</code> module is the entry point for a package that provides functionality related to handling and structuring model elements, collections of elements, and their associations. It includes components that allow users to define, manipulate, and validate structured data models, as well as traverse and manipulate these models efficiently. This module imports and exposes all the necessary classes, functions, and types needed for these purposes.</p>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--main-components","title":"Main Components:","text":"<ul> <li><code>Element</code>: A generic base class that defines a model element.</li> <li><code>Collection</code>: Extends <code>Element</code> to represent a collection of model elements.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--element-manipulation","title":"Element Manipulation:","text":"<ul> <li><code>redefine</code>: Function to create a new class by redefining an existing element.</li> <li>Functions like <code>find_owned_elements_of</code>, <code>owned_elements_of</code>, <code>remove_owned_elements_from</code>, <code>add_owned_element_to</code>, etc., provide ways to manipulate ownership and structure of model elements.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--traversal-helpers","title":"Traversal Helpers:","text":"<ul> <li><code>ancestors_of</code>, <code>descendants_of</code>, <code>find_ancestor_of</code>, <code>find_descendants_of</code> are utility functions for traversing relationships between elements.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--association-handling","title":"Association Handling:","text":"<ul> <li>Includes utility functions and classes for managing associations between elements, like <code>associations_of</code>, <code>is_association</code>, <code>association</code>.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--validation-and-preprocessing","title":"Validation and Preprocessing:","text":"<ul> <li><code>Preprocessor</code> and <code>Validator</code> classes help in validating and preprocessing model elements, ensuring correctness and consistency.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--model-serialization","title":"Model Serialization:","text":"<ul> <li>The module provides a <code>dump</code> function for serializing elements and debugging.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--miscellaneous-utilities","title":"Miscellaneous Utilities:","text":"<ul> <li>Utility functions like <code>name_of</code>, <code>qualified_name_of</code>, <code>id_of</code>, <code>owner_of</code>, <code>type_of</code>, <code>is_descendant_of</code>, for retrieving various attributes and relationships of model elements.</li> <li><code>of</code> function to get the model an element belongs to.</li> </ul>"},{"location":"Python/API/Modelling/Overview/#stateforward.model--visitor-pattern-implementation","title":"Visitor Pattern Implementation:","text":"<ul> <li><code>Visitor</code> class that implements the visitor pattern to traverse and operate on a structure of elements.</li> </ul> <p>Note that the details like the method names and definitions of classes are abstracted and only the purpose and interaction model are mentioned in this overview.</p>"},{"location":"Python/API/Modelling/Preprocessor/","title":"Preprocessor","text":"<p>A module that defines the <code>Preprocessor</code> class, which inherits from the <code>Visitor</code> class.</p> <p>The <code>Preprocessor</code> class serves as a base class for creating preprocessors that can visit different nodes in a data structure, such as a syntax tree or a graph. It extends the functionality provided by the <code>Visitor</code> class by allowing for preprocessing of these nodes. The preprocessors are expected to implement methods with a prefix 'preprocess' which corresponds to the type of node they will visit and operate on.</p> <p>The <code>__all__</code> definition specifies that the only symbol that should be publicly available when importing this module is 'Preprocessor'.</p> <p>The module also contains a special function <code>__get__</code> within an unspecified class. This function seems to be associated with a descriptor object for handling method retrieval. When the <code>instance</code> parameter is <code>None</code>, it treats the method as a classmethod and redirects the call to the classmethod's <code>__get__</code> function. Otherwise, it accesses the function associated with the instance through the <code>__func__</code> attribute and returns it bound to the <code>instance</code> and <code>owner</code>.</p>"},{"location":"Python/API/Modelling/Preprocessor/#stateforward.model.preprocessor.Preprocessor","title":"<code>Preprocessor</code>","text":"<p>             Bases: <code>Visitor</code></p> <p>A class that extends the functionality of the Visitor class, designated for preprocessing tasks. The Preprocessor class inherits from the Visitor class and provides an interface for preprocessing-related visitation methods. It uses a specific method prefix 'preprocess' to differentiate its methods from those in the Visitor class. This class serves as a base class and is typically subclassed to implement specific preprocessing logic required for various tasks.</p> <p>Attributes:</p> Name Type Description <code>visit_method_prefix</code> <code>str</code> <p>A string prefix used to identify preprocessing methods distinct from those in the base Visitor class.</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>class Preprocessor(Visitor, visit_method_prefix=\"preprocess\"):\n    \"\"\"\n    A class that extends the functionality of the Visitor class, designated for preprocessing tasks.\n    The Preprocessor class inherits from the Visitor class and provides an interface for preprocessing-related visitation methods. It uses a specific method prefix 'preprocess' to differentiate its methods from those in the Visitor class. This class serves as a base class and is typically subclassed to implement specific preprocessing logic required for various tasks.\n\n    Attributes:\n        visit_method_prefix (str):\n             A string prefix used to identify preprocessing methods distinct from those in the base Visitor class.\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"Python/API/Modelling/Validator/","title":"Validator","text":"<p>The <code>validator</code> module is designed as an extension of a <code>Visitor</code> pattern implementation, aptly named <code>Visitor</code>. It introduces a specialized class <code>Validator</code> that inherits from the <code>Visitor</code> base class. The primary purpose of this module is to provide a mechanism for validating objects or data structures, leveraging the visitor pattern to apply validation logic selectively based on the type of element being visited.</p> <p>In the context of the <code>Validator</code> class, a notable feature is the <code>visit_method_prefix</code> which is set to 'validate'. This indicates that the methods responsible for performing the validation on the visited elements should have names prefixed with 'validate'. Doing so allows the <code>Validator</code> to dynamically determine the correct validation method to invoke based on the type of the element encountered during the traversal process.</p> <p>The <code>__get__</code> special method within the module is overridden to enhance descriptors for class methods. When <code>instance</code> is <code>None</code>, it redirects the call to the <code>classmethod.__get__</code> thereby enabling the <code>__get__</code> method to be utilized as a class method. Otherwise, it invokes the <code>__func__.__get__</code> for the instance, facilitating the use of the descriptor protocol to properly bind functions to instances.</p> <p>Overall, the <code>validator</code> module and its <code>Validator</code> class are instrumental in creating structured, type-specific validation logic in a manner that is consistent with the visitor design pattern. It is suitable for scenarios where diverse objects or data structures require a set of validation rules applied contextually, depending on their types.</p>"},{"location":"Python/API/Modelling/Validator/#stateforward.model.validator.Validator","title":"<code>Validator</code>","text":"<p>             Bases: <code>Visitor</code></p> <p>A class that represents a Validator which is a type of Visitor specifically designed for validation purposes. This class inherits from the base <code>Visitor</code> class and utilizes a specific method prefix 'validate' for its visit methods. The <code>Validator</code> class serves as a framework for creating concrete validator classes that can perform validations on different components or objects by implementing the respective <code>validate</code> prefixed methods.</p> <p>Attributes:</p> Name Type Description <code>visit_method_prefix</code> <code>str</code> <p>A class-level attribute that defines the prefix for the visit methods used in validation. The default prefix is set to 'validate'. This class does not have its own constructor and relies on the initialization process of the <code>Visitor</code> class. It is intended to be subclassed by other classes that implement the actual validation logic for specific objects or components. The <code>Validator</code> class itself does not define any methods. Subclasses are responsible for providing implementations for the various <code>validate</code> methods that correspond to the particular elements or constructs they are designed to validate. In a typical usage scenario, an instance of a subclass of <code>Validator</code> would be passed around in a context where various objects are to be validated. As each object is encountered, the corresponding <code>validate_</code> method of the <code>Validator</code> subclass would be invoked to perform the necessary validation checks.</p> Source code in <code>stateforward/model/validator.py</code> <pre><code>class Validator(Visitor, visit_method_prefix=\"validate\"):\n    \"\"\"\n    A class that represents a Validator which is a type of Visitor specifically designed for validation purposes.\n    This class inherits from the base `Visitor` class and utilizes a specific method prefix 'validate' for its visit methods. The `Validator` class serves as a framework for creating concrete validator classes that can perform validations on different components or objects by implementing the respective `validate` prefixed methods.\n\n    Attributes:\n        visit_method_prefix (str):\n             A class-level attribute that defines the prefix for the visit methods used in validation. The default prefix is set to 'validate'.\n            This class does not have its own constructor and relies on the initialization process of the `Visitor` class. It is intended to be subclassed by other classes that implement the actual validation logic for specific objects or components.\n            The `Validator` class itself does not define any methods. Subclasses are responsible for providing implementations for the various `validate` methods that correspond to the particular elements or constructs they are designed to validate.\n            In a typical usage scenario, an instance of a subclass of `Validator` would be passed around in a context where various objects are to be validated. As each object is encountered, the corresponding `validate_` method of the `Validator` subclass would be invoked to perform the necessary validation checks.\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/","title":"Visitor","text":"<p>The <code>visitor</code> module provides a flexible framework for navigating and processing various elements within a structured model. It uses the Visitor design pattern to separate the algorithm from the elements on which it operates, allowing different kinds of operations to be performed on the elements of a model seamlessly without changing the classes of the elements themselves. Here's a detailed overview of the components within the <code>visitor</code> module:</p>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor--classes","title":"Classes","text":""},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor--visitor","title":"<code>Visitor</code>","text":"<p>The central class in the <code>visitor</code> module is <code>Visitor</code>, which serves as a base class for creating specific visitor classes that can walk through a model's structure and perform custom operations.</p> <ul> <li><code>visit_method_prefix</code>: A class attribute that stores the prefix for visit methods. It defaults to <code>'visit'</code>, but subclasses can override it.</li> <li><code>visited</code>: A set that keeps track of the ids of visited elements to avoid processing them multiple times.</li> </ul>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor--methods","title":"Methods","text":"<ul> <li><code>__init_subclass__(cls, visit_method_prefix: Optional[str]=None)</code>: A class method that ensures the subclass adopts a custom prefix for visiting methods. It also dynamically creates visit methods if they are not already defined in the subclass.</li> <li><code>__init__(self)</code>: Initializes the visitor instance and the set to track visited elements.</li> <li><code>visit_element(self, element: Type[model.Element], *args, **kwargs)</code>: Visits an element and prevents revisiting already processed elements. It also dynamically dispatches to more specific visit methods based on the class of the element.</li> <li><code>visit_owned_elements(self, element: Type[model.Element], *args, **kwargs)</code>: Iterates over and visits all elements owned by the given element.</li> <li><code>visit(self, element: Type[model.Model])</code>: Starts the visitation process from the top-level model element.</li> </ul>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor--constants","title":"Constants","text":"<ul> <li><code>TITLE_CASE_PATTERN</code>: A regular expression pattern used to identify title-cased names within a string.</li> <li> <p><code>UNDERSCORE_REPLACE_PATTERN</code>: A pattern used for replacing characters in a string to facilitate method name generation.</p> </li> <li> <p><code>__all__</code>: A list containing the names of objects intended for export from the module.</p> </li> </ul>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor--helper-functions","title":"Helper Functions","text":"<ul> <li><code>__get__</code>: An internal function facilitating the retrieval of the visitor instance in a descriptor context.</li> </ul> <p>Overall, this module provides a generic mechanism for traversing and acting upon different elements within a model by using visitor classes that can be tailored to perform specific operations while maintaining loose coupling between the visitor logic and the model's structure.</p>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor","title":"<code>Visitor</code>","text":"<p>A base class for implementing visitor pattern logic for traversing and processing elements in a model hierarchy. This class defines the basic mechanics of a visitor pattern, where subclasses can override specific visit methods to implement custom behaviors while traversing model elements. It uses a dynamic method resolution based on element types and their inheritance hierarchy to determine the appropriate visit methods to invoke. Subclasses can define their own visit methods with a customizable prefix by specifying the 'visit_method_prefix' attribute during subclassing. If the subclass does not define a certain prefixed visit method that exists in the base class, it will be automatically populated with a default implementation based on the Visitor's corresponding method. The visitor keeps track of visited elements by their unique IDs to avoid redundant processing, especially when traversing complex model structures with potential redefinitions or cyclic references.</p> <p>Attributes:</p> Name Type Description <code>visit_method_prefix</code> <code>str</code> <p>The prefix used for visitor methods, defaulting to 'visit' for the base class. Subclasses may override.</p> <code>visited</code> <code>set[int]</code> <p>A set that keeps track of the IDs of elements that have been visited to prevent redundant visits.</p> <p>Methods:</p> Name Description <code>__init_subclass__</code> <p>Class method to handle subclass initialization by assigning a method prefix and populating missing prefixed visit methods with default logic from the base class.</p> <code>__init__</code> <p>Initializes a new instance of Visitor, primarily responsible for initializing the 'visited' attribute.</p> <code>visit_element</code> <p>Processes an individual element and its hierarchy, marking it as visited, and calling the specific visit methods based on the element's type.</p> <code>visit_owned_elements</code> <p>Iterates over and processes all owned elements of a given element using 'visit_element'.</p> <code>visit</code> <p>The entry point for visiting a model, invoking 'visit_element' on the top-level element.</p> Source code in <code>stateforward/model/visitor.py</code> <pre><code>class Visitor:\n    \"\"\"\n    A base class for implementing visitor pattern logic for traversing and processing elements in a model hierarchy.\n    This class defines the basic mechanics of a visitor pattern, where subclasses can override specific visit methods to implement custom behaviors while traversing model elements. It uses a dynamic method resolution based on element types and their inheritance hierarchy to determine the appropriate visit methods to invoke.\n    Subclasses can define their own visit methods with a customizable prefix by specifying the 'visit_method_prefix' attribute during subclassing. If the subclass does not define a certain prefixed visit method that exists in the base class, it will be automatically populated with a default implementation based on the Visitor's corresponding method.\n    The visitor keeps track of visited elements by their unique IDs to avoid redundant processing, especially when traversing complex model structures with potential redefinitions or cyclic references.\n\n    Attributes:\n        visit_method_prefix (str):\n             The prefix used for visitor methods, defaulting to 'visit' for the base class. Subclasses may override.\n        visited (set[int]):\n             A set that keeps track of the IDs of elements that have been visited to prevent redundant visits.\n\n    Methods:\n        __init_subclass__(cls, visit_method_prefix=None):\n             Class method to handle subclass initialization by assigning a method prefix and populating missing prefixed visit methods with default logic from the base class.\n        __init__():\n             Initializes a new instance of Visitor, primarily responsible for initializing the 'visited' attribute.\n        visit_element(element, *args, **kwargs):\n             Processes an individual element and its hierarchy, marking it as visited, and calling the specific visit methods based on the element's type.\n        visit_owned_elements(element, *args, **kwargs):\n             Iterates over and processes all owned elements of a given element using 'visit_element'.\n        visit(element):\n             The entry point for visiting a model, invoking 'visit_element' on the top-level element.\n\n    \"\"\"\n\n    visit_method_prefix: str = \"visit\"\n    visited: set[int]\n\n    def __init_subclass__(cls, visit_method_prefix: Optional[str] = None):\n        \"\"\"\n        Customizes the subclass initialization process by setting a visit method prefix and providing default implementations for visitor methods if they are not already defined in the subclass.\n        This modification allows different subclasses to utilize custom prefixes for their own visitor methods. During the subclass initialization, it checks whether the subclass has defined the necessary visitor methods according to a specified prefix. If such methods are not found, it dynamically creates and assigns default visitor method implementations that delegate the calls to the parent visitor methods.\n        The method specifically targets visitor methods with or without '_element' and '_owned_elements' postfixes. This dynamic method creation aims to maintain consistency across various visitor implementations, ensuring that all necessary visitor interface methods are present in the subclass, regardless of the prefix chosen.\n\n        Args:\n            cls (type):\n                 The class being initialized as a subclass.\n            visit_method_prefix (Optional[str]):\n                 An optional string to specify the prefix for the visit methods in the subclass. If not provided, it defaults to the prefix used in the base Visitor class.\n\n        Raises:\n            TypeError:\n                 If the cls argument is provided, but it is not a type.\n\n        \"\"\"\n        cls.visit_method_prefix = visit_method_prefix or cls.visit_method_prefix\n        if cls.visit_method_prefix != Visitor.visit_method_prefix:\n            for postfix in (\"\", \"_element\", \"_owned_elements\"):\n                method_name = f\"{cls.visit_method_prefix}{postfix}\"\n                if not hasattr(cls, method_name):\n\n                    def visitor(\n                        *args,\n                        __visit__=getattr(\n                            Visitor, f\"{Visitor.visit_method_prefix}{postfix}\"\n                        ),\n                        **kwargs,\n                    ):\n                        \"\"\"\n                        Handles the visitation of a node or structure using a dynamically determined visitor method.\n                        This function dynamically retrieves a visitor method based on the postfix supplied, which is appended to the visit_method_prefix defined in the Visitor class. The retrieved method is then called with the provided arguments and keyword arguments.\n\n                        Args:\n                            *args:\n                                 Variable length argument list to pass to the __visit__ method.\n                            __visit__:\n                                 The visitor method to execute, dynamically determined by appending the postfix to 'visit_method_prefix' of the Visitor class.\n                            **kwargs:\n                                 Arbitrary keyword arguments to pass to the __visit__ method.\n\n                        Returns:\n\n                        \"\"\"\n                        return __visit__(*args, **kwargs)\n\n                    setattr(cls, method_name, visitor)\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the class.\n        This constructor initializes an empty set that is used to store visited elements or items.\n\n        \"\"\"\n        self.visited = set()\n\n    def visit_element(self, element: Type[model.Element], *args, **kwargs):\n        \"\"\"\n        Visits a given element and processes it according to the visiting rules defined in the visitor.\n\n        Args:\n            element (Type[model.Element]):\n                 The element to visit.\n            *args:\n                 Variable length argument list.\n            **kwargs:\n                 Arbitrary keyword arguments.\n                This method processes an element by first checking if it has been redefined and if it hasn't been visited already, provided that the element has a unique identifier. It then iterates over the Method Resolution Order (MRO) of the element. For each class in the MRO, it attempts to find a corresponding method on the visitor with a name that matches the naming convention 'visit_' followed by the class name in lowercase with spaces replaced by underscores. If such a method is found and it is not the base 'visit_element' method, it invokes the method with the element and any additional arguments passed to 'visit_element'. If the method returns a truthy value, the traversal is short-circuited. Lastly, if no truthy value is returned, 'visit_owned_elements' is called to continue processing any owned elements of the current element.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(element)\n        element_id = model.id_of(element)\n        if element_id not in self.visited:\n            self.visited.add(element_id)\n            for base in element.__mro__:\n                method = getattr(\n                    self,\n                    f\"{self.visit_method_prefix}_{TITLE_CASE_PATTERN.sub(UNDERSCORE_REPLACE_PATTERN, base.__name__).lower()}\",\n                    None,\n                )\n                if method not in (None, Visitor.visit_element):\n                    if method(element, *args, **kwargs):\n                        return\n                    break\n            self.visit_owned_elements(element, *args, **kwargs)\n\n    def visit_owned_elements(self, element: Type[model.Element], *args, **kwargs):\n        \"\"\"\n        Visits all owned elements of a given model element.\n        This method iterates over all elements owned by the specified element and applies the visit_element method to each.\n        It is intended to be used for traversing a hierarchy of model elements and performing operations on each owned element.\n        The visit_element method called by this function should be defined elsewhere and is responsible for the actual operation performed on each element.\n\n        Args:\n            element (Type[model.Element]):\n                 The root element from which owned elements will be visited.\n            *args:\n                 Variable length argument list for arguments to pass to visit_element method.\n            **kwargs:\n                 Arbitrary keyword arguments for arguments to pass to visit_element method.\n\n        \"\"\"\n        for owned_element in model.owned_elements_of(element):\n            self.visit_element(owned_element, *args, **kwargs)\n\n    def visit(self, element: Type[model.Model]):\n        \"\"\"\n        Visits a model element to perform operations on it.\n        This method delegates the operation to the 'visit_element' method which needs to be implemented to perform actual actions on the model element passed to this 'visit' method.\n\n        Args:\n            element (Type[model.Model]):\n                 The model element that needs to be visited. It should be an instance of a class from the 'model' module.\n\n        \"\"\"\n        self.visit_element(element)\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor.__init__","title":"<code>__init__()</code>","text":"Source code in <code>stateforward/model/visitor.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of the class.\n    This constructor initializes an empty set that is used to store visited elements or items.\n\n    \"\"\"\n    self.visited = set()\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor.__init_subclass__","title":"<code>__init_subclass__(visit_method_prefix=None)</code>","text":"<p>Customizes the subclass initialization process by setting a visit method prefix and providing default implementations for visitor methods if they are not already defined in the subclass. This modification allows different subclasses to utilize custom prefixes for their own visitor methods. During the subclass initialization, it checks whether the subclass has defined the necessary visitor methods according to a specified prefix. If such methods are not found, it dynamically creates and assigns default visitor method implementations that delegate the calls to the parent visitor methods. The method specifically targets visitor methods with or without '_element' and '_owned_elements' postfixes. This dynamic method creation aims to maintain consistency across various visitor implementations, ensuring that all necessary visitor interface methods are present in the subclass, regardless of the prefix chosen.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class being initialized as a subclass.</p> required <code>visit_method_prefix</code> <code>Optional[str]</code> <p>An optional string to specify the prefix for the visit methods in the subclass. If not provided, it defaults to the prefix used in the base Visitor class.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the cls argument is provided, but it is not a type.</p> Source code in <code>stateforward/model/visitor.py</code> <pre><code>def __init_subclass__(cls, visit_method_prefix: Optional[str] = None):\n    \"\"\"\n    Customizes the subclass initialization process by setting a visit method prefix and providing default implementations for visitor methods if they are not already defined in the subclass.\n    This modification allows different subclasses to utilize custom prefixes for their own visitor methods. During the subclass initialization, it checks whether the subclass has defined the necessary visitor methods according to a specified prefix. If such methods are not found, it dynamically creates and assigns default visitor method implementations that delegate the calls to the parent visitor methods.\n    The method specifically targets visitor methods with or without '_element' and '_owned_elements' postfixes. This dynamic method creation aims to maintain consistency across various visitor implementations, ensuring that all necessary visitor interface methods are present in the subclass, regardless of the prefix chosen.\n\n    Args:\n        cls (type):\n             The class being initialized as a subclass.\n        visit_method_prefix (Optional[str]):\n             An optional string to specify the prefix for the visit methods in the subclass. If not provided, it defaults to the prefix used in the base Visitor class.\n\n    Raises:\n        TypeError:\n             If the cls argument is provided, but it is not a type.\n\n    \"\"\"\n    cls.visit_method_prefix = visit_method_prefix or cls.visit_method_prefix\n    if cls.visit_method_prefix != Visitor.visit_method_prefix:\n        for postfix in (\"\", \"_element\", \"_owned_elements\"):\n            method_name = f\"{cls.visit_method_prefix}{postfix}\"\n            if not hasattr(cls, method_name):\n\n                def visitor(\n                    *args,\n                    __visit__=getattr(\n                        Visitor, f\"{Visitor.visit_method_prefix}{postfix}\"\n                    ),\n                    **kwargs,\n                ):\n                    \"\"\"\n                    Handles the visitation of a node or structure using a dynamically determined visitor method.\n                    This function dynamically retrieves a visitor method based on the postfix supplied, which is appended to the visit_method_prefix defined in the Visitor class. The retrieved method is then called with the provided arguments and keyword arguments.\n\n                    Args:\n                        *args:\n                             Variable length argument list to pass to the __visit__ method.\n                        __visit__:\n                             The visitor method to execute, dynamically determined by appending the postfix to 'visit_method_prefix' of the Visitor class.\n                        **kwargs:\n                             Arbitrary keyword arguments to pass to the __visit__ method.\n\n                    Returns:\n\n                    \"\"\"\n                    return __visit__(*args, **kwargs)\n\n                setattr(cls, method_name, visitor)\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor.visit","title":"<code>visit(element)</code>","text":"<p>Visits a model element to perform operations on it. This method delegates the operation to the 'visit_element' method which needs to be implemented to perform actual actions on the model element passed to this 'visit' method.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Model]</code> <p>The model element that needs to be visited. It should be an instance of a class from the 'model' module.</p> required Source code in <code>stateforward/model/visitor.py</code> <pre><code>def visit(self, element: Type[model.Model]):\n    \"\"\"\n    Visits a model element to perform operations on it.\n    This method delegates the operation to the 'visit_element' method which needs to be implemented to perform actual actions on the model element passed to this 'visit' method.\n\n    Args:\n        element (Type[model.Model]):\n             The model element that needs to be visited. It should be an instance of a class from the 'model' module.\n\n    \"\"\"\n    self.visit_element(element)\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor.visit_element","title":"<code>visit_element(element, *args, **kwargs)</code>","text":"<p>Visits a given element and processes it according to the visiting rules defined in the visitor.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Element]</code> <p>The element to visit.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments. This method processes an element by first checking if it has been redefined and if it hasn't been visited already, provided that the element has a unique identifier. It then iterates over the Method Resolution Order (MRO) of the element. For each class in the MRO, it attempts to find a corresponding method on the visitor with a name that matches the naming convention 'visit_' followed by the class name in lowercase with spaces replaced by underscores. If such a method is found and it is not the base 'visit_element' method, it invokes the method with the element and any additional arguments passed to 'visit_element'. If the method returns a truthy value, the traversal is short-circuited. Lastly, if no truthy value is returned, 'visit_owned_elements' is called to continue processing any owned elements of the current element.</p> <code>{}</code> Source code in <code>stateforward/model/visitor.py</code> <pre><code>def visit_element(self, element: Type[model.Element], *args, **kwargs):\n    \"\"\"\n    Visits a given element and processes it according to the visiting rules defined in the visitor.\n\n    Args:\n        element (Type[model.Element]):\n             The element to visit.\n        *args:\n             Variable length argument list.\n        **kwargs:\n             Arbitrary keyword arguments.\n            This method processes an element by first checking if it has been redefined and if it hasn't been visited already, provided that the element has a unique identifier. It then iterates over the Method Resolution Order (MRO) of the element. For each class in the MRO, it attempts to find a corresponding method on the visitor with a name that matches the naming convention 'visit_' followed by the class name in lowercase with spaces replaced by underscores. If such a method is found and it is not the base 'visit_element' method, it invokes the method with the element and any additional arguments passed to 'visit_element'. If the method returns a truthy value, the traversal is short-circuited. Lastly, if no truthy value is returned, 'visit_owned_elements' is called to continue processing any owned elements of the current element.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(element)\n    element_id = model.id_of(element)\n    if element_id not in self.visited:\n        self.visited.add(element_id)\n        for base in element.__mro__:\n            method = getattr(\n                self,\n                f\"{self.visit_method_prefix}_{TITLE_CASE_PATTERN.sub(UNDERSCORE_REPLACE_PATTERN, base.__name__).lower()}\",\n                None,\n            )\n            if method not in (None, Visitor.visit_element):\n                if method(element, *args, **kwargs):\n                    return\n                break\n        self.visit_owned_elements(element, *args, **kwargs)\n</code></pre>"},{"location":"Python/API/Modelling/Visitor/#stateforward.model.visitor.Visitor.visit_owned_elements","title":"<code>visit_owned_elements(element, *args, **kwargs)</code>","text":"<p>Visits all owned elements of a given model element. This method iterates over all elements owned by the specified element and applies the visit_element method to each. It is intended to be used for traversing a hierarchy of model elements and performing operations on each owned element. The visit_element method called by this function should be defined elsewhere and is responsible for the actual operation performed on each element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Element]</code> <p>The root element from which owned elements will be visited.</p> required <code>*args</code> <p>Variable length argument list for arguments to pass to visit_element method.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for arguments to pass to visit_element method.</p> <code>{}</code> Source code in <code>stateforward/model/visitor.py</code> <pre><code>def visit_owned_elements(self, element: Type[model.Element], *args, **kwargs):\n    \"\"\"\n    Visits all owned elements of a given model element.\n    This method iterates over all elements owned by the specified element and applies the visit_element method to each.\n    It is intended to be used for traversing a hierarchy of model elements and performing operations on each owned element.\n    The visit_element method called by this function should be defined elsewhere and is responsible for the actual operation performed on each element.\n\n    Args:\n        element (Type[model.Element]):\n             The root element from which owned elements will be visited.\n        *args:\n             Variable length argument list for arguments to pass to visit_element method.\n        **kwargs:\n             Arbitrary keyword arguments for arguments to pass to visit_element method.\n\n    \"\"\"\n    for owned_element in model.owned_elements_of(element):\n        self.visit_element(owned_element, *args, **kwargs)\n</code></pre>"},{"location":"Python/API/Protocols/Clock/","title":"Clock","text":"<p>The \"Clock\" module provides an interface for working with time within an application.</p> <p>This module defines a \"Clock\" class that follows Python's typing.Protocol, which outlines methods expected to be implemented by concrete classes. The purpose of the protocol is to define a common interface for time operations, allowing for different implementations that can interoperate within the application's ecosystem.</p> <p>The \"Clock\" class has a single class attribute, \"multiplier\", which is set to a default value of 0.001. This implies that the class is dealing with time at a millisecond granularity by default, but this can be overridden in concrete implementations if needed.</p> <p>The \"Clock\" class defines one method, \"now\", which is expected to return the current datetime. Concrete classes that implement the \"Clock\" protocol should provide their own mechanism to return the current time, potentially with their own internal logic or time source (e.g., system time, a remote time server, or a simulated clock for testing purposes).</p> <p>Consumers of this module and the \"Clock\" class should ensure that any concrete implementation respects the interface outlined by the protocol, especially the \"now\" method signature, to ensure compatibility and interchangeability among different time systems.</p>"},{"location":"Python/API/Protocols/Clock/#stateforward.protocols.clock.Clock","title":"<code>Clock</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol defining the structure of a Clock-like object. This protocol specifies that any Clock-like object should have a class attribute named <code>multiplier</code>, with a default value of 0.001, indicating that the basic time unit of this Clock is milliseconds. It also requires the implementation of an instance method <code>now()</code>, which should return the current time as a <code>datetime</code> object.</p> <p>Attributes:</p> Name Type Description <code>multiplier</code> <code>float</code> <p>A class-level constant defining the time unit. The default value of 0.001 indicates that time is measured in milliseconds.</p> <p>Methods:</p> Name Description <code>now</code> <p>Should be implemented by classes that follow this protocol to provide the current time.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <p>The current time as a <code>datetime</code> object.</p> Source code in <code>stateforward/protocols/clock.py</code> <pre><code>class Clock(typing.Protocol):\n    \"\"\"\n    A protocol defining the structure of a Clock-like object.\n    This protocol specifies that any Clock-like object should have a class attribute named\n    `multiplier`, with a default value of 0.001, indicating that the basic time unit of this\n    Clock is milliseconds. It also requires the implementation of an instance method\n    `now()`, which should return the current time as a `datetime` object.\n\n    Attributes:\n        multiplier (float):\n             A class-level constant defining the time unit. The default\n            value of 0.001 indicates that time is measured in milliseconds.\n\n    Methods:\n        now:\n            Should be implemented by classes that follow this protocol to provide\n            the current time.\n\n    Returns:\n        datetime:\n             The current time as a `datetime` object.\n\n    \"\"\"\n    multiplier: float = 0.001  # 1ms\n\n    def now(self) -&gt; datetime:\n        \"\"\"\n\n        Returns the current date and time as a datetime object.\n\n        Returns:\n            datetime:\n                 The current date and time.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Python/API/Protocols/Clock/#stateforward.protocols.clock.Clock.now","title":"<code>now()</code>","text":"<p>Returns the current date and time as a datetime object.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current date and time.</p> Source code in <code>stateforward/protocols/clock.py</code> <pre><code>def now(self) -&gt; datetime:\n    \"\"\"\n\n    Returns the current date and time as a datetime object.\n\n    Returns:\n        datetime:\n             The current date and time.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/","title":"Future","text":"<p>This module provides the <code>Future</code> class which implements a Pythonic way of handling asynchronous operations by encapsulating the result of a computation that may not be immediately available. Futures are a core component of asynchronous programming in Python, representing an abstract concept of an operation that provides a result at some point in the future.</p> <p>The <code>Future</code> class provided in this module comes with various methods that allow for managing the lifecycle of a future. Here's a brief description of these methods:</p> <ul> <li><code>cancel</code>: Attempts to cancel the future. If the future is already done or cancelled, it returns <code>False</code>; otherwise, it cancels the future and returns <code>True</code>.</li> <li><code>cancelled</code>: Returns <code>True</code> if the future has been cancelled.</li> <li><code>running</code>: Returns <code>True</code> if the future is currently being executed and has not been cancelled or finished yet.</li> <li><code>done</code>: Returns <code>True</code> if the future is done executing (either the result is set, an exception has been set, or it has been cancelled).</li> <li><code>add_done_callback</code>: Adds a callback to be run when the future is done.</li> <li><code>result</code>: Retrieves the result of the future. If the future is not yet done, it will raise an exception or wait until the result is available or a timeout occurs.</li> <li><code>exception</code>: Retrieves the exception set into the future, if any.</li> <li><code>set_result</code>: Sets the result of the future. This method is typically used by the party that created the future.</li> <li><code>set_exception</code>: Sets an exception as the result of the future. This indicates that the future has finished with an error.</li> </ul> <p>The <code>Future</code> class also provides a <code>__await__</code> method, making it compatible with the <code>await</code> expression in async functions.</p> <p>Furthermore, the module includes the <code>results</code> static method, which wraps a given value in a <code>Future</code> object. If the provided value is already a <code>Future</code>, it is simply cast to the module's <code>Future</code> type and returned. If it is not, a new <code>Future</code> object is created with the result already set, mimicking a completed future.</p> <p>The <code>Future</code> class is a <code>Protocol</code> that describes the necessary methods and behaviors futures must implement, making it a useful tool for type hinting and ensuring that user-defined future-like classes adhere to a standard interface.</p>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future","title":"<code>Future</code>","text":"<p>             Bases: <code>Protocol[T]</code></p> <p>A Future represents an eventual result of an asynchronous operation. It is a placeholder for a value that will be available in the future. Instance methods: cancel(self) -&gt; bool: Attempt to cancel the future. If the future is already done or cannot be cancelled, returns False; otherwise, the future is cancelled and returns True. cancelled(self) -&gt; bool: Return True if the future has been cancelled. running(self) -&gt; bool: Return True if the future is currently executing. done(self) -&gt; bool: Return True if the future has finished executing. add_done_callback(self, callback: typing.Callable[['Future'], None]): Attach a callable that will be called when the future is done. result(self, timeout: typing.Optional[float]=None) -&gt; T: Return the result of the future, if available. If the future is not done yet, wait up to a timeout and block until it is done or the timeout expires. exception(self, timeout: typing.Optional[float]=None): Return the exception raised by the call that the future represents, if any. set_result(self, result: T): Mark the future as done and set its result. set_exception(self, exception: Exception): Mark the future as done and set an exception. await(self, args, *kwargs): Enable the future to be used with the await expression. Class methods: @staticmethod results(value: T) -&gt; 'Future': Create a Future object from a given value. If the value is a future, it is cast to a Future object and returned. Otherwise, a new Future object is created, marked as done, and set to the given result.</p> <p>Attributes:</p> Name Type Description <code>remove_done_callback</code> <code>Optional[Callable[[Callable[[Future], None]], None]]</code> <p>typing.Optional[typing.Callable[[typing.Callable[['Future'], None]], None]] Attribute or function that, when present, defines how to detach a callback previously added using add_done_callback.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>class Future(typing.Protocol[T]):\n    \"\"\"\n    A Future represents an eventual result of an asynchronous operation. It is a placeholder for a value that will be available in the future.\n    Instance methods:\n    cancel(self) -&gt; bool:\n    Attempt to cancel the future. If the future is already done or cannot be cancelled, returns False; otherwise, the future is cancelled and returns True.\n    cancelled(self) -&gt; bool:\n    Return True if the future has been cancelled.\n    running(self) -&gt; bool:\n    Return True if the future is currently executing.\n    done(self) -&gt; bool:\n    Return True if the future has finished executing.\n    add_done_callback(self, callback: typing.Callable[['Future'], None]):\n    Attach a callable that will be called when the future is done.\n    result(self, timeout: typing.Optional[float]=None) -&gt; T:\n    Return the result of the future, if available. If the future is not done yet, wait up to a timeout and block until it is done or the timeout expires.\n    exception(self, timeout: typing.Optional[float]=None):\n    Return the exception raised by the call that the future represents, if any.\n    set_result(self, result: T):\n    Mark the future as done and set its result.\n    set_exception(self, exception: Exception):\n    Mark the future as done and set an exception.\n    __await__(self, *args, **kwargs):\n    Enable the future to be used with the await expression.\n    Class methods:\n    @staticmethod\n    results(value: T) -&gt; 'Future':\n    Create a Future object from a given value. If the value is a future, it is cast to a Future object and returned. Otherwise, a new Future object is created, marked as done, and set to the given result.\n\n    Attributes:\n        remove_done_callback:\n             typing.Optional[typing.Callable[[typing.Callable[['Future'], None]], None]]\n            Attribute or function that, when present, defines how to detach a callback previously added using add_done_callback.\n\n    \"\"\"\n\n    remove_done_callback: typing.Optional[\n        typing.Callable[[typing.Callable[[\"Future\"], None]], None]\n    ]\n\n    def cancel(self) -&gt; bool:\n        \"\"\"\n        Cancels an ongoing operation or process.\n\n        Returns:\n            bool:\n                 True if the operation was successfully cancelled, False otherwise.\n\n        \"\"\"\n        ...\n\n    def cancelled(self) -&gt; bool:\n        \"\"\"\n        Checks if a given operation has been cancelled.\n\n        Returns:\n            bool:\n                 True if the operation has been cancelled, otherwise False.\n\n        \"\"\"\n        ...\n\n    def running(self) -&gt; bool:\n        \"\"\"\n        Checks if the current object is in a running state.\n\n        Returns:\n            bool:\n                 True if the object is running, False otherwise.\n\n        \"\"\"\n        ...\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        Checks if the task is complete.\n\n        Returns:\n            bool:\n                 True if the task is complete, False otherwise.\n\n        \"\"\"\n        ...\n\n    def add_done_callback(self, callback: typing.Callable[[\"Future\"], None]):\n        \"\"\"\n        Adds a callback function that will be called when the future is done.\n        The callback provided should have a signature accepting a single argument, which will\n        be the future instance itself. The callback will be invoked by the event loop or\n        executor when the future is complete, and will be passed the future as its single\n        argument. Note that the callbacks are not called in any specific order and should\n        not make assumptions about the execution order of multiple callbacks added to the\n        same future.\n\n        Args:\n            callback (Callable[['Future'], None]):\n                 A callable that takes a future as its\n                only parameter and returns None.\n\n        Raises:\n            Exception:\n                 If adding the callback fails due to reasons such as\n                future already being done or other internal errors.\n\n        \"\"\"\n        ...\n\n    def result(self, timeout: typing.Optional[float] = None) -&gt; T:\n        \"\"\"\n\n        Returns the result of an asynchronous operation after ensuring it has completed within an optional timeout period.\n\n        Args:\n            timeout (typing.Optional[float], optional):\n                 Maximum time in seconds to wait for the operation to complete. If not provided, the wait is indefinite.\n\n        Returns:\n            T:\n                 The result of the operation once it has completed.\n\n        Raises:\n            TimeoutError:\n                 If the operation does not complete within the specified 'timeout' period.\n\n        \"\"\"\n        ...\n\n    def exception(self, timeout: typing.Optional[float] = None):\n        \"\"\"\n\n        Raises an exception after a specified timeout period has elapsed.\n\n        Args:\n            timeout (typing.Optional[float], optional):\n                 The number of seconds to wait before\n                raising the exception. If None, the function will raise an exception\n                immediately. Defaults to None.\n\n        Raises:\n            Exception:\n                 An error indicating that the timeout period has elapsed.\n\n        \"\"\"\n        ...\n\n    def set_result(self, result: T):\n        \"\"\"\n        Sets the result property of the current instance to the provided value.\n\n        Args:\n            result (T):\n                 The result value to set for the current instance. The type 'T' is a\n                generic placeholder indicating that the function is type-agnostic.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def set_exception(self, exception: Exception):\n        \"\"\"\n        Sets an exception to be the current object's state.\n        This method is typically used to indicate that an error has occurred during the execution of a task represented by the object. Once the exception is set, it can be raised or handled accordingly by the object's consumers.\n\n        Args:\n            exception (Exception):\n                 The exception instance to set as the current state.\n\n        Raises:\n            TypeError:\n                 If the provided argument is not an instance of the Exception class.\n\n        \"\"\"\n        ...\n\n    def __await__(self, *args, **kwargs):\n        \"\"\"\n        __await__(self, *args, **kwargs)\n        This special method is used to make an object awaitable. It should return an iterator which is then used by the\n        'await' syntax in async functions. This method is typically implemented by classes that represent asynchronous operations,\n        and it must return an iterator that has a '__next__' method which should stop the iteration via 'StopIteration' once the\n        asynchronous operation is complete.\n\n        Args:\n            *args:\n                 Variable length argument list that may be used by implementations that require additional parameters.\n            **kwargs:\n                 Arbitrary keyword arguments that may be used by implementations that require additional parameters.\n\n        Raises:\n            TypeError:\n                 If the returned value is not an iterator.\n\n\n        \"\"\"\n        ...\n\n    @staticmethod\n    def results(value: T) -&gt; \"Future\":\n        \"\"\"\n        Creates a completed Future object from a given value or Future.\n        This static method takes any value, and if the value is already an asyncio.Future or a concurrent.futures.Future, it simply casts and returns it. If the value is not a Future instance, the method creates a new `futures.Future`, sets the provided value as the result of this Future, and returns it.\n\n        Args:\n            value (T):\n                 The value to be used to create a Future object. This can be any type that can be set as the result of the Future.\n\n        Returns:\n            Future:\n                 A Future object which is either cast from the input value if it was already a Future, or a new Future with the supplied value set as its result.\n\n        \"\"\"\n        if asyncio.isfuture(value) or isinstance(value, futures.Future):\n            return typing.cast(Future, value)\n        future = futures.Future()\n        future.set_result(value)\n        return typing.cast(Future, future)\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.__await__","title":"<code>__await__(*args, **kwargs)</code>","text":"<p>await(self, args, *kwargs) This special method is used to make an object awaitable. It should return an iterator which is then used by the 'await' syntax in async functions. This method is typically implemented by classes that represent asynchronous operations, and it must return an iterator that has a 'next' method which should stop the iteration via 'StopIteration' once the asynchronous operation is complete.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list that may be used by implementations that require additional parameters.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that may be used by implementations that require additional parameters.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the returned value is not an iterator.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def __await__(self, *args, **kwargs):\n    \"\"\"\n    __await__(self, *args, **kwargs)\n    This special method is used to make an object awaitable. It should return an iterator which is then used by the\n    'await' syntax in async functions. This method is typically implemented by classes that represent asynchronous operations,\n    and it must return an iterator that has a '__next__' method which should stop the iteration via 'StopIteration' once the\n    asynchronous operation is complete.\n\n    Args:\n        *args:\n             Variable length argument list that may be used by implementations that require additional parameters.\n        **kwargs:\n             Arbitrary keyword arguments that may be used by implementations that require additional parameters.\n\n    Raises:\n        TypeError:\n             If the returned value is not an iterator.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.add_done_callback","title":"<code>add_done_callback(callback)</code>","text":"<p>Adds a callback function that will be called when the future is done. The callback provided should have a signature accepting a single argument, which will be the future instance itself. The callback will be invoked by the event loop or executor when the future is complete, and will be passed the future as its single argument. Note that the callbacks are not called in any specific order and should not make assumptions about the execution order of multiple callbacks added to the same future.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Future], None]</code> <p>A callable that takes a future as its only parameter and returns None.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If adding the callback fails due to reasons such as future already being done or other internal errors.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def add_done_callback(self, callback: typing.Callable[[\"Future\"], None]):\n    \"\"\"\n    Adds a callback function that will be called when the future is done.\n    The callback provided should have a signature accepting a single argument, which will\n    be the future instance itself. The callback will be invoked by the event loop or\n    executor when the future is complete, and will be passed the future as its single\n    argument. Note that the callbacks are not called in any specific order and should\n    not make assumptions about the execution order of multiple callbacks added to the\n    same future.\n\n    Args:\n        callback (Callable[['Future'], None]):\n             A callable that takes a future as its\n            only parameter and returns None.\n\n    Raises:\n        Exception:\n             If adding the callback fails due to reasons such as\n            future already being done or other internal errors.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.cancel","title":"<code>cancel()</code>","text":"<p>Cancels an ongoing operation or process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was successfully cancelled, False otherwise.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def cancel(self) -&gt; bool:\n    \"\"\"\n    Cancels an ongoing operation or process.\n\n    Returns:\n        bool:\n             True if the operation was successfully cancelled, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.cancelled","title":"<code>cancelled()</code>","text":"<p>Checks if a given operation has been cancelled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation has been cancelled, otherwise False.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"\n    Checks if a given operation has been cancelled.\n\n    Returns:\n        bool:\n             True if the operation has been cancelled, otherwise False.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.done","title":"<code>done()</code>","text":"<p>Checks if the task is complete.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the task is complete, False otherwise.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Checks if the task is complete.\n\n    Returns:\n        bool:\n             True if the task is complete, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.exception","title":"<code>exception(timeout=None)</code>","text":"<p>Raises an exception after a specified timeout period has elapsed.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait before raising the exception. If None, the function will raise an exception immediately. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>An error indicating that the timeout period has elapsed.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def exception(self, timeout: typing.Optional[float] = None):\n    \"\"\"\n\n    Raises an exception after a specified timeout period has elapsed.\n\n    Args:\n        timeout (typing.Optional[float], optional):\n             The number of seconds to wait before\n            raising the exception. If None, the function will raise an exception\n            immediately. Defaults to None.\n\n    Raises:\n        Exception:\n             An error indicating that the timeout period has elapsed.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.result","title":"<code>result(timeout=None)</code>","text":"<p>Returns the result of an asynchronous operation after ensuring it has completed within an optional timeout period.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Maximum time in seconds to wait for the operation to complete. If not provided, the wait is indefinite.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The result of the operation once it has completed.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the operation does not complete within the specified 'timeout' period.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def result(self, timeout: typing.Optional[float] = None) -&gt; T:\n    \"\"\"\n\n    Returns the result of an asynchronous operation after ensuring it has completed within an optional timeout period.\n\n    Args:\n        timeout (typing.Optional[float], optional):\n             Maximum time in seconds to wait for the operation to complete. If not provided, the wait is indefinite.\n\n    Returns:\n        T:\n             The result of the operation once it has completed.\n\n    Raises:\n        TimeoutError:\n             If the operation does not complete within the specified 'timeout' period.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.results","title":"<code>results(value)</code>  <code>staticmethod</code>","text":"<p>Creates a completed Future object from a given value or Future. This static method takes any value, and if the value is already an asyncio.Future or a concurrent.futures.Future, it simply casts and returns it. If the value is not a Future instance, the method creates a new <code>futures.Future</code>, sets the provided value as the result of this Future, and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to be used to create a Future object. This can be any type that can be set as the result of the Future.</p> required <p>Returns:</p> Name Type Description <code>Future</code> <code>Future</code> <p>A Future object which is either cast from the input value if it was already a Future, or a new Future with the supplied value set as its result.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>@staticmethod\ndef results(value: T) -&gt; \"Future\":\n    \"\"\"\n    Creates a completed Future object from a given value or Future.\n    This static method takes any value, and if the value is already an asyncio.Future or a concurrent.futures.Future, it simply casts and returns it. If the value is not a Future instance, the method creates a new `futures.Future`, sets the provided value as the result of this Future, and returns it.\n\n    Args:\n        value (T):\n             The value to be used to create a Future object. This can be any type that can be set as the result of the Future.\n\n    Returns:\n        Future:\n             A Future object which is either cast from the input value if it was already a Future, or a new Future with the supplied value set as its result.\n\n    \"\"\"\n    if asyncio.isfuture(value) or isinstance(value, futures.Future):\n        return typing.cast(Future, value)\n    future = futures.Future()\n    future.set_result(value)\n    return typing.cast(Future, future)\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.running","title":"<code>running()</code>","text":"<p>Checks if the current object is in a running state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the object is running, False otherwise.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def running(self) -&gt; bool:\n    \"\"\"\n    Checks if the current object is in a running state.\n\n    Returns:\n        bool:\n             True if the object is running, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.set_exception","title":"<code>set_exception(exception)</code>","text":"<p>Sets an exception to be the current object's state. This method is typically used to indicate that an error has occurred during the execution of a task represented by the object. Once the exception is set, it can be raised or handled accordingly by the object's consumers.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception instance to set as the current state.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided argument is not an instance of the Exception class.</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def set_exception(self, exception: Exception):\n    \"\"\"\n    Sets an exception to be the current object's state.\n    This method is typically used to indicate that an error has occurred during the execution of a task represented by the object. Once the exception is set, it can be raised or handled accordingly by the object's consumers.\n\n    Args:\n        exception (Exception):\n             The exception instance to set as the current state.\n\n    Raises:\n        TypeError:\n             If the provided argument is not an instance of the Exception class.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Future/#stateforward.protocols.future.Future.set_result","title":"<code>set_result(result)</code>","text":"<p>Sets the result property of the current instance to the provided value.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>T</code> <p>The result value to set for the current instance. The type 'T' is a generic placeholder indicating that the function is type-agnostic.</p> required <p>Returns:</p> Source code in <code>stateforward/protocols/future.py</code> <pre><code>def set_result(self, result: T):\n    \"\"\"\n    Sets the result property of the current instance to the provided value.\n\n    Args:\n        result (T):\n             The result value to set for the current instance. The type 'T' is a\n            generic placeholder indicating that the function is type-agnostic.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/","title":"Interpreter","text":""},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter--module-interpreter","title":"Module <code>interpreter</code>","text":"<p>This module contains the implementation of the <code>Interpreter</code> protocol, which is responsible for processing state-forwarding models and handling their execution flow. It uses asynchronous I/O for its operations, leveraging Python's <code>asyncio</code> library. The module depends on several other components like <code>Queue</code>, <code>Clock</code>, and <code>Future</code> to manage the scheduling of tasks and the progression of time within the simulation.</p>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter--classes","title":"Classes","text":"<ul> <li> <p><code>InterpreterStep</code>: An <code>Enum</code> representing the state of a step within the <code>Interpreter</code>. Possible values are <code>complete</code>, <code>incomplete</code>, and <code>deferred</code>.</p> </li> <li> <p><code>Interpreter</code>: A protocol that defines the interface for an interpreter instance. These instances are responsible for orchestrating elements of the state-forwarding model. They manage a queue, a clock, a stack of futures, and a logging instance.</p> </li> </ul>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter--interpreter-protocol-methods","title":"Interpreter Protocol Methods","text":"<ul> <li> <p><code>__init__</code>: Constructor for the interpreter. It takes a <code>Queue</code> instance and an optional <code>logging.Logger</code> instance as parameters.</p> </li> <li> <p><code>send</code>: Takes an event of type <code>model.Element</code> and schedules it for processing, returning a <code>Future</code> representing the eventual result of processing this event.</p> </li> <li> <p><code>start</code>: Initiates the interpreter loop which can be provided through the <code>loop</code> parameter; if <code>None</code>, the default event loop is used.</p> </li> <li> <p><code>wait</code>: Waits on a collection of <code>tasks</code>, which can be either <code>asyncio.Task</code> or <code>asyncio.Future</code> objects. It accepts an optional <code>name</code> to identify the wait operation and a <code>return_when</code> strategy that governs when the wait should return.</p> </li> <li> <p><code>run</code>: An asynchronous method that runs the interpreter to completion.</p> </li> <li> <p><code>step</code>: An abstract asynchronous method that should be implemented to perform a single step of the interpreter's operation.</p> </li> <li> <p><code>is_active</code>: Checks whether the provided <code>elements</code> are active within the current state model context.</p> </li> <li> <p><code>push</code>: Associates an <code>element</code> with a <code>future</code> object, pushing it onto the interpreter's stack.</p> </li> <li> <p><code>pop</code>: Removes an <code>element</code> from the interpreter's stack, providing a <code>result</code> to the associated future.</p> </li> <li> <p><code>terminate</code>: Cleans up and terminates the interpreter's operation.</p> </li> </ul>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter--attributes","title":"Attributes","text":"<ul> <li><code>model</code>: An attribute of the generic type <code>T</code>, which is bound to <code>model.Model</code> and represents the model instance that the interpreter is operating on.</li> </ul>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter","title":"<code>Interpreter</code>","text":"<p>             Bases: <code>Protocol[T]</code></p> <p>A protocol class that defines the interface for an interpreter capable of handling events, managing an event loop, and interacting with a queue and a clock system.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <code>Queue</code> <p>An instance of Queue where the interpreter manages scheduled events.</p> <code>clock</code> <code>Clock</code> <p>An instance of Clock that provides timing functionality.</p> <code>stack</code> <code>dict[Element, Future]</code> <p>A dictionary mapping model components to their corresponding futures.</p> <code>log</code> <code>Logger</code> <p>A Logger instance where the interpreter can log messages.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor that initializes the interpreter with a given queue and an optional logger.</p> <code>send</code> <p>Sends an event to the interpreter for processing and returns a Future.</p> <code>start</code> <p>Initiates the event loop for the interpreter with an optional loop argument.</p> <code>wait</code> <p>Waits for the completion of the given tasks or futures and returns a collected Task.</p> <code>run</code> <p>Asynchronous method that starts running the interpreter event loop.</p> <code>step</code> <p>Asynchronous method that performs a single step in the interpreter processing.</p> <code>is_active</code> <p>Checks if any of the provided elements are currently active within the interpreter.</p> <code>push</code> <p>Associates an element with a future or task in the interpreter's stack.</p> <code>pop</code> <p>Removes an element from the stack and handles its corresponding result.</p> <code>terminate</code> <p>Ends the interpreter's execution and cleans up resources.</p> <code>model</code> <p>A generic type placeholder for the model handled by the interpreter.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>class Interpreter(typing.Protocol[T]):\n    \"\"\"\n    A protocol class that defines the interface for an interpreter capable of handling events,\n    managing an event loop, and interacting with a queue and a clock system.\n\n    Attributes:\n        queue:\n             An instance of Queue where the interpreter manages scheduled events.\n        clock:\n             An instance of Clock that provides timing functionality.\n        stack:\n             A dictionary mapping model components to their corresponding futures.\n        log:\n             A Logger instance where the interpreter can log messages.\n\n    Methods:\n        __init__:\n             Constructor that initializes the interpreter with a given queue and an optional logger.\n        send:\n             Sends an event to the interpreter for processing and returns a Future.\n        start:\n             Initiates the event loop for the interpreter with an optional loop argument.\n        wait:\n             Waits for the completion of the given tasks or futures and returns a collected Task.\n        run:\n             Asynchronous method that starts running the interpreter event loop.\n        step:\n             Asynchronous method that performs a single step in the interpreter processing.\n        is_active:\n             Checks if any of the provided elements are currently active within the interpreter.\n        push:\n             Associates an element with a future or task in the interpreter's stack.\n        pop:\n             Removes an element from the stack and handles its corresponding result.\n        terminate:\n             Ends the interpreter's execution and cleans up resources.\n        model:\n             A generic type placeholder for the model handled by the interpreter.\n\n    \"\"\"\n\n    queue: Queue\n    clock: Clock\n    stack: dict[model.Element, Future]\n    log: logging.Logger\n\n    def __init__(self, queue: Queue, log: logging.Logger = None):\n        \"\"\"\n        Initializes the instance with a Queue and an optional Logger object.\n\n        Args:\n            queue (Queue):\n                 The queue to be used by the instance for storing or processing tasks.\n            log (logging.Logger, optional):\n                 The logger to be used for logging information, warnings, errors, etc. Defaults to None, in which case no logging will be performed.\n\n        \"\"\"\n        ...\n\n    def send(self, event: model.Element) -&gt; Future:\n        \"\"\"\n        Sends an event to be processed asynchronously.\n        This method accepts an event object, wraps it in a Future, and schedules it for asynchronous processing.\n        The method returns a Future object that can be used to retrieve the result of the event processing at a later time.\n\n        Args:\n            event (model.Element):\n                 The event to send for processing.\n\n        Returns:\n            Future:\n                 The future object representing the asynchronous operation of the event processing.\n\n        \"\"\"\n        ...\n\n    def start(\n        self,\n        loop: asyncio.AbstractEventLoop = None,\n    ):\n        \"\"\"\n        Starts the asynchronous event loop for the instance.\n\n        Args:\n            loop (asyncio.AbstractEventLoop, optional):\n                 The event loop to run the instance on. If None is provided, the default event loop is used.\n\n        \"\"\"\n        ...\n\n    def wait(\n        self,\n        *tasks: typing.Union[asyncio.Task, asyncio.Future],\n        name: str = None,\n        return_when: str = asyncio.FIRST_COMPLETED,\n    ) -&gt; asyncio.Task:\n        \"\"\"\n        Waits for the completion of given tasks or futures until a condition is met.\n        This method is used to asynchronously wait for either any or all of the specified tasks or futures to complete, depending on the `return_when` parameter. It can be used to orchestrate the execution of different asynchronous operations in a non-blocking manner.\n\n        Args:\n            *tasks (typing.Union[asyncio.Task, asyncio.Future]):\n                 An unpacked tuple of tasks or futures.\n                These are the asynchronous operations that `wait` will wait on.\n            name (str, optional):\n                 A name for the group of tasks being waited on. This name is not\n                directly used by the `wait` function but can be useful for logging and debugging purposes.\n            return_when (str):\n                 A string that specifies when the function should return. The default\n                value is `asyncio.FIRST_COMPLETED`, which means the function will return as soon as any task or future is done.\n                Other possible values are `asyncio.FIRST_EXCEPTION`, which returns when any task or future raises an exception,\n                and `asyncio.ALL_COMPLETED`, which returns only when all tasks or futures are completed.\n\n        Returns:\n            asyncio.Task:\n                 A single asyncio.Task instance that can be awaited. This task completes when\n                the condition specified in `return_when` is met.\n\n        \"\"\"\n        ...\n\n    async def run(self) -&gt; None:\n        \"\"\"\n        Asynchronously executes the function's main logic.\n        This function is designed to be called within an asynchronous context. It runs\n        the primary task or series of tasks that the class instance is responsible\n        for managing. As it is an async function, it should be awaited when called\n        to ensure proper execution and handling of the event loop.\n\n        Returns:\n            None:\n                 This function does not return any value.\n\n        \"\"\"\n        ...\n\n    async def step(self) -&gt; None:\n        \"\"\"\n        Performs an asynchronous step operation for the object. This function is intended to be overridden by subclasses to implement specific asynchronous behavior. The default implementation does nothing and is meant to be a placeholder.\n\n        Returns:\n\n        \"\"\"\n        pass\n\n    def is_active(self, *elements: model.Element) -&gt; bool:\n        \"\"\"\n        Determines if the given elements are active.\n        This method checks if the specified elements within the model are currently active. 'Active' in this context refers to the\n        elements being in a state where they are in use or in operation within the model. Each element provided as an argument\n        to the function is checked, and the function returns True only if all elements are active, otherwise False.\n\n        Args:\n            *elements (model.Element):\n                 Variable number of Element objects to check for active status.\n\n        Returns:\n            bool:\n                 True if all elements are active, False otherwise.\n\n        \"\"\"\n        ...\n\n    def push(self, element: model.Element, future: typing.Union[Future, asyncio.Task]):\n        \"\"\"\n        Adds a new element to a collection with an optional future or task associated with it.\n\n        Args:\n            element (model.Element):\n                 The element to be added to the collection.\n            future (typing.Union[Future, asyncio.Task]):\n                 A future or task that is\n                associated with the element being added. This is optional and can be\n                used to track the completion or result of an asynchronous operation\n                related to the element.\n\n        Raises:\n            TypeError:\n                 If the provided future is neither a Future nor an asyncio.Task instance.\n\n        \"\"\"\n        ...\n\n    def pop(self, element: model.Element, result: typing.Any):\n        \"\"\"\n        Pops an element from the given structure and returns the result.\n        This method is designed to remove the specified element from the structure it is called upon,\n        and optionally returns the result of this operation.\n\n        Args:\n            element (model.Element):\n                 The element to remove from the structure.\n            result (typing.Any):\n                 The result to return after the element has been popped.\n\n        Returns:\n            typing.Any:\n                 The specified return result after the popping operation.\n\n        \"\"\"\n        ...\n\n    def terminate(self):\n        \"\"\"\n        Terminates the current process or operation.\n        This method provides the functionality to cease the operation for the associated object. It is meant to be implemented as a cleanup action to safely shut down or close resources such as file handlers, network connections, or database connections before the termination of the process.\n\n        Raises:\n            NotImplementedError:\n                 If the method has not been implemented by the subclass.\n\n        \"\"\"\n        ...\n\n    model: T = None\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.__init__","title":"<code>__init__(queue, log=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Queue</code> <p>The queue to be used by the instance for storing or processing tasks.</p> required <code>log</code> <code>Logger</code> <p>The logger to be used for logging information, warnings, errors, etc. Defaults to None, in which case no logging will be performed.</p> <code>None</code> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def __init__(self, queue: Queue, log: logging.Logger = None):\n    \"\"\"\n    Initializes the instance with a Queue and an optional Logger object.\n\n    Args:\n        queue (Queue):\n             The queue to be used by the instance for storing or processing tasks.\n        log (logging.Logger, optional):\n             The logger to be used for logging information, warnings, errors, etc. Defaults to None, in which case no logging will be performed.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.is_active","title":"<code>is_active(*elements)</code>","text":"<p>Determines if the given elements are active. This method checks if the specified elements within the model are currently active. 'Active' in this context refers to the elements being in a state where they are in use or in operation within the model. Each element provided as an argument to the function is checked, and the function returns True only if all elements are active, otherwise False.</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>Variable number of Element objects to check for active status.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are active, False otherwise.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def is_active(self, *elements: model.Element) -&gt; bool:\n    \"\"\"\n    Determines if the given elements are active.\n    This method checks if the specified elements within the model are currently active. 'Active' in this context refers to the\n    elements being in a state where they are in use or in operation within the model. Each element provided as an argument\n    to the function is checked, and the function returns True only if all elements are active, otherwise False.\n\n    Args:\n        *elements (model.Element):\n             Variable number of Element objects to check for active status.\n\n    Returns:\n        bool:\n             True if all elements are active, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.pop","title":"<code>pop(element, result)</code>","text":"<p>Pops an element from the given structure and returns the result. This method is designed to remove the specified element from the structure it is called upon, and optionally returns the result of this operation.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>The element to remove from the structure.</p> required <code>result</code> <code>Any</code> <p>The result to return after the element has been popped.</p> required <p>Returns:</p> Type Description <p>typing.Any:  The specified return result after the popping operation.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def pop(self, element: model.Element, result: typing.Any):\n    \"\"\"\n    Pops an element from the given structure and returns the result.\n    This method is designed to remove the specified element from the structure it is called upon,\n    and optionally returns the result of this operation.\n\n    Args:\n        element (model.Element):\n             The element to remove from the structure.\n        result (typing.Any):\n             The result to return after the element has been popped.\n\n    Returns:\n        typing.Any:\n             The specified return result after the popping operation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.push","title":"<code>push(element, future)</code>","text":"<p>Adds a new element to a collection with an optional future or task associated with it.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>The element to be added to the collection.</p> required <code>future</code> <code>Union[Future, Task]</code> <p>A future or task that is associated with the element being added. This is optional and can be used to track the completion or result of an asynchronous operation related to the element.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided future is neither a Future nor an asyncio.Task instance.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def push(self, element: model.Element, future: typing.Union[Future, asyncio.Task]):\n    \"\"\"\n    Adds a new element to a collection with an optional future or task associated with it.\n\n    Args:\n        element (model.Element):\n             The element to be added to the collection.\n        future (typing.Union[Future, asyncio.Task]):\n             A future or task that is\n            associated with the element being added. This is optional and can be\n            used to track the completion or result of an asynchronous operation\n            related to the element.\n\n    Raises:\n        TypeError:\n             If the provided future is neither a Future nor an asyncio.Task instance.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Asynchronously executes the function's main logic. This function is designed to be called within an asynchronous context. It runs the primary task or series of tasks that the class instance is responsible for managing. As it is an async function, it should be awaited when called to ensure proper execution and handling of the event loop.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function does not return any value.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"\n    Asynchronously executes the function's main logic.\n    This function is designed to be called within an asynchronous context. It runs\n    the primary task or series of tasks that the class instance is responsible\n    for managing. As it is an async function, it should be awaited when called\n    to ensure proper execution and handling of the event loop.\n\n    Returns:\n        None:\n             This function does not return any value.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.send","title":"<code>send(event)</code>","text":"<p>Sends an event to be processed asynchronously. This method accepts an event object, wraps it in a Future, and schedules it for asynchronous processing. The method returns a Future object that can be used to retrieve the result of the event processing at a later time.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Element</code> <p>The event to send for processing.</p> required <p>Returns:</p> Name Type Description <code>Future</code> <code>Future</code> <p>The future object representing the asynchronous operation of the event processing.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def send(self, event: model.Element) -&gt; Future:\n    \"\"\"\n    Sends an event to be processed asynchronously.\n    This method accepts an event object, wraps it in a Future, and schedules it for asynchronous processing.\n    The method returns a Future object that can be used to retrieve the result of the event processing at a later time.\n\n    Args:\n        event (model.Element):\n             The event to send for processing.\n\n    Returns:\n        Future:\n             The future object representing the asynchronous operation of the event processing.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.start","title":"<code>start(loop=None)</code>","text":"<p>Starts the asynchronous event loop for the instance.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>AbstractEventLoop</code> <p>The event loop to run the instance on. If None is provided, the default event loop is used.</p> <code>None</code> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def start(\n    self,\n    loop: asyncio.AbstractEventLoop = None,\n):\n    \"\"\"\n    Starts the asynchronous event loop for the instance.\n\n    Args:\n        loop (asyncio.AbstractEventLoop, optional):\n             The event loop to run the instance on. If None is provided, the default event loop is used.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.step","title":"<code>step()</code>  <code>async</code>","text":"<p>Performs an asynchronous step operation for the object. This function is intended to be overridden by subclasses to implement specific asynchronous behavior. The default implementation does nothing and is meant to be a placeholder.</p> <p>Returns:</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>async def step(self) -&gt; None:\n    \"\"\"\n    Performs an asynchronous step operation for the object. This function is intended to be overridden by subclasses to implement specific asynchronous behavior. The default implementation does nothing and is meant to be a placeholder.\n\n    Returns:\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the current process or operation. This method provides the functionality to cease the operation for the associated object. It is meant to be implemented as a cleanup action to safely shut down or close resources such as file handlers, network connections, or database connections before the termination of the process.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method has not been implemented by the subclass.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the current process or operation.\n    This method provides the functionality to cease the operation for the associated object. It is meant to be implemented as a cleanup action to safely shut down or close resources such as file handlers, network connections, or database connections before the termination of the process.\n\n    Raises:\n        NotImplementedError:\n             If the method has not been implemented by the subclass.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.Interpreter.wait","title":"<code>wait(*tasks, name=None, return_when=asyncio.FIRST_COMPLETED)</code>","text":"<p>Waits for the completion of given tasks or futures until a condition is met. This method is used to asynchronously wait for either any or all of the specified tasks or futures to complete, depending on the <code>return_when</code> parameter. It can be used to orchestrate the execution of different asynchronous operations in a non-blocking manner.</p> <p>Parameters:</p> Name Type Description Default <code>*tasks</code> <code>Union[Task, Future]</code> <p>An unpacked tuple of tasks or futures. These are the asynchronous operations that <code>wait</code> will wait on.</p> <code>()</code> <code>name</code> <code>str</code> <p>A name for the group of tasks being waited on. This name is not directly used by the <code>wait</code> function but can be useful for logging and debugging purposes.</p> <code>None</code> <code>return_when</code> <code>str</code> <p>A string that specifies when the function should return. The default value is <code>asyncio.FIRST_COMPLETED</code>, which means the function will return as soon as any task or future is done. Other possible values are <code>asyncio.FIRST_EXCEPTION</code>, which returns when any task or future raises an exception, and <code>asyncio.ALL_COMPLETED</code>, which returns only when all tasks or futures are completed.</p> <code>FIRST_COMPLETED</code> <p>Returns:</p> Type Description <code>Task</code> <p>asyncio.Task:  A single asyncio.Task instance that can be awaited. This task completes when the condition specified in <code>return_when</code> is met.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>def wait(\n    self,\n    *tasks: typing.Union[asyncio.Task, asyncio.Future],\n    name: str = None,\n    return_when: str = asyncio.FIRST_COMPLETED,\n) -&gt; asyncio.Task:\n    \"\"\"\n    Waits for the completion of given tasks or futures until a condition is met.\n    This method is used to asynchronously wait for either any or all of the specified tasks or futures to complete, depending on the `return_when` parameter. It can be used to orchestrate the execution of different asynchronous operations in a non-blocking manner.\n\n    Args:\n        *tasks (typing.Union[asyncio.Task, asyncio.Future]):\n             An unpacked tuple of tasks or futures.\n            These are the asynchronous operations that `wait` will wait on.\n        name (str, optional):\n             A name for the group of tasks being waited on. This name is not\n            directly used by the `wait` function but can be useful for logging and debugging purposes.\n        return_when (str):\n             A string that specifies when the function should return. The default\n            value is `asyncio.FIRST_COMPLETED`, which means the function will return as soon as any task or future is done.\n            Other possible values are `asyncio.FIRST_EXCEPTION`, which returns when any task or future raises an exception,\n            and `asyncio.ALL_COMPLETED`, which returns only when all tasks or futures are completed.\n\n    Returns:\n        asyncio.Task:\n             A single asyncio.Task instance that can be awaited. This task completes when\n            the condition specified in `return_when` is met.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Interpreter/#stateforward.protocols.interpreter.InterpreterStep","title":"<code>InterpreterStep</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration to represent the possible states of an interpreter step. This enum classifies the status of a step within an interpreter's execution process. Each member of the enumeration represents a distinct state that indicates the completeness of the current step being processed.</p> <p>Attributes:</p> Name Type Description <code>complete</code> <code>str</code> <p>A member indicating the interpreter step has been successfully completed without any pending actions.</p> <code>incomplete</code> <code>str</code> <p>A member indicating the interpreter step is not yet finished and may require further processing.</p> <code>deferred</code> <code>str</code> <p>A member indicating the interpreter step's execution has been postponed and will be revisited later.</p> Source code in <code>stateforward/protocols/interpreter.py</code> <pre><code>class InterpreterStep(Enum):\n    \"\"\"\n    An enumeration to represent the possible states of an interpreter step.\n    This enum classifies the status of a step within an interpreter's execution process. Each member of the enumeration represents a distinct state that indicates the completeness of the current step being processed.\n\n    Attributes:\n        complete (str):\n             A member indicating the interpreter step has been successfully completed without any pending actions.\n        incomplete (str):\n             A member indicating the interpreter step is not yet finished and may require further processing.\n        deferred (str):\n             A member indicating the interpreter step's execution has been postponed and will be revisited later.\n\n    \"\"\"\n\n    complete = \"complete\"\n    incomplete = \"incomplete\"\n    deferred = \"deferred\"\n</code></pre>"},{"location":"Python/API/Protocols/Logger/","title":"Logger","text":"<p>Module <code>logger</code> defines an interface for logging functionality, modeled as a Protocol class in Python typing system, which can be implemented by logging providers for consistent logging behavior across different applications.</p>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger--class-logger","title":"Class <code>Logger</code>","text":"<p>This abstract base class defines several methods for logging messages at different severity levels. It does not contain any implementations but serves as a contract that other logging classes can follow to ensure compatibility with the expected logging interface.</p>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger--methods","title":"Methods","text":"<ul> <li> <p><code>setLevel(self, level)</code>: Set the threshold for this logger to <code>level</code>. Logging messages which are less severe than <code>level</code> will be ignored.</p> </li> <li> <p><code>debug(self, msg, *args, **kwargs)</code>: Log a message with severity 'DEBUG' on this logger.</p> </li> <li> <p><code>info(self, msg, *args, **kwargs)</code>: Log a message with severity 'INFO' on this logger.</p> </li> <li> <p><code>warning(self, msg, *args, **kwargs)</code>: Log a message with severity 'WARNING' on this logger.</p> </li> <li> <p><code>error(self, msg, *args, **kwargs)</code>: Log a message with severity 'ERROR' on this logger.</p> </li> <li> <p><code>exception(self, msg, *args, exc_info=True, **kwargs)</code>: Log a message with severity 'ERROR' as well as exception information on this logger. By default, <code>exc_info</code> is <code>True</code>.</p> </li> <li> <p><code>critical(self, msg, *args, **kwargs)</code>: Log a message with severity 'CRITICAL' on this logger.</p> </li> <li> <p><code>fatal(self, msg, *args, **kwargs)</code>: An alias for <code>critical</code> to log a message with 'FATAL' severity level indicating a potentially program-halting issue.</p> </li> <li> <p><code>log(self, level, msg, *args, **kwargs)</code>: Log a message with the specified logging <code>level</code> on this logger. This is more generic and can be used for any logging level.</p> </li> </ul> <p>The <code>*args</code> and <code>**kwargs</code> in the method signatures represent variadic positional and keyword arguments respectively, which can be used to pass additional context or formatting information to the logging methods.</p> <p>Note: This module serves as a protocol and will need concrete implementations provided by classes that fulfill the interface defined by the <code>Logger</code> class.</p>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger","title":"<code>Logger</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol defining the interface for a logging system. This Logger protocol specifies the methods that a logger must implement to be considered a conforming implementation. It provides a way to log messages with different severity levels. Implementations of this protocol can be used to log debug, information, warning, error, exception, and critical level messages.</p> <p>Methods:</p> Name Description <code>setLevel</code> <p>Set the threshold for this logger to level. Logging messages which are less severe than level will be ignored.</p> <code>debug</code> <p>Log 'msg % args' with the severity 'DEBUG'.</p> <code>info</code> <p>Log 'msg % args' with the severity 'INFO'.</p> <code>warning</code> <p>Log 'msg % args' with the severity 'WARNING'.</p> <code>error</code> <p>Log 'msg % args' with the severity 'ERROR'.</p> <code>exception</code> <p>Log 'msg % args' with the severity 'ERROR', including an exception traceback (exceptions only).</p> <code>critical</code> <p>Log 'msg % args' with the severity 'CRITICAL'.</p> <code>fatal</code> <p>Log 'msg % args' with the severity 'CRITICAL' (synonym for critical).</p> <code>log</code> <p>Log 'msg % args' with the severity 'level'. The 'args' and '*kwargs' are to be used for string formatting of the message and passing extra parameters specific to the logging system implementation, respectively.</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>class Logger(typing.Protocol):\n    \"\"\"\n    A protocol defining the interface for a logging system.\n    This Logger protocol specifies the methods that a logger must implement to be considered a conforming implementation. It provides a way to log messages with different severity levels. Implementations of this protocol can be used to log debug, information, warning, error, exception, and critical level messages.\n\n    Methods:\n        setLevel(level):\n             Set the threshold for this logger to level. Logging messages which are less severe than level will be ignored.\n        debug(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'DEBUG'.\n        info(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'INFO'.\n        warning(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'WARNING'.\n        error(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'ERROR'.\n        exception(msg, *args, exc_info=True, **kwargs):\n             Log 'msg % args' with the severity 'ERROR', including an exception traceback (exceptions only).\n        critical(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'CRITICAL'.\n        fatal(msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'CRITICAL' (synonym for critical).\n        log(level, msg, *args, **kwargs):\n             Log 'msg % args' with the severity 'level'.\n            The '*args' and '**kwargs' are to be used for string formatting of the message and passing extra parameters specific to the logging system implementation, respectively.\n\n    \"\"\"\n    def setLevel(self, level):\n        \"\"\"\n        Sets the logging level of the object.\n\n        Args:\n            level (int):\n                 An integer representing the logging level to set.\n\n        \"\"\"\n        ...\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs a debug message to the console or a file, if configured.\n\n        Args:\n            msg (str):\n                 The message to be logged.\n            *args:\n                 Variable length argument list that may be used to pass in objects for\n                formatting the message.\n            **kwargs:\n                 Arbitrary keyword arguments that may be used for providing\n                additional information to fine-tune the logging behavior.\n\n        \"\"\"\n        ...\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs an informational message to the console or designated log handler.\n        This method logs a message with an 'INFO' level. The args provided are\n        used to format the msg string using the standard string formatting\n        operator. Additional kwargs are passed to the underlying logging\n        handler and can control various aspects of the logging process such as\n        the stack info and the exception information.\n\n        Args:\n            msg (str):\n                 The message format string to log.\n            *args:\n                 Variable length argument list used for string formatting.\n            **kwargs:\n                 Arbitrary keyword arguments.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs a warning message with optional arguments supporting variable data insertion.\n\n        Args:\n            msg (str):\n                 The warning message to log. This message can contain format strings which will be replaced by data from `args`.\n            *args:\n                 Variable length argument list used to insert data into the `msg` format string.\n            **kwargs:\n                 Arbitrary keyword arguments. These arguments can be used to pass additional data relevant to the logging system, such as context or error codes.\n\n        \"\"\"\n        ...\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs an error message with additional context provided by arguments.\n        This method is used to log error level messages. The message can be\n        formatted with additional arguments and keyword arguments to provide\n        context for the error. It is especially useful in a logging system where\n        the error message, along with its context, is recorded or reported.\n\n        Args:\n            msg (str):\n                 The error message to log. This should be a clear and concise\n                description of the error.\n            *args:\n                 Variable length argument list used to format the msg.\n            **kwargs:\n                 Arbitrary keyword arguments which can be used to provide\n                additional information for formatting the error message.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Logs an exception message along with the traceback information, if exc_info is True.\n\n        Args:\n            msg (str):\n                 A human-readable message describing the exception.\n            *args:\n                 Variable length argument list that may be used by the logging formatter.\n            exc_info (bool, optional):\n                 Determines whether to log exception traceback information. Defaults to True.\n            **kwargs:\n                 Arbitrary keyword arguments which may be passed to the logger.\n\n        \"\"\"\n        ...\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs a message with level 'CRITICAL' on this logger.\n        The message 'msg' is logged on the logger with the integer level CRITICAL. The arguments are interpreted as for fmt.format(). Exception information is added to the logging message if the 'exc_info' keyword argument is set to a true value. If an exception tuple (in the format returned by sys.exc_info()) or an exception instance is provided as 'exc_info', it is used; otherwise, sys.exc_info() is called to get the exception information.\n\n        Args:\n            msg (str):\n                 The message format string to log.\n            *args:\n                 Variable length argument list to pass to the message format string.\n            **kwargs:\n                 Arbitrary keyword arguments. Commonly used keyword arguments are 'exc_info' to add exception information to the message, and 'extra' which is used to pass additional information for the logger to emit with the message.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def fatal(self, msg, *args, **kwargs):\n        \"\"\"\n        Logs a message with severity 'FATAL' on the logger instance, then exits the program with a non-zero exit code. The message can be a string message or a string with placeholders for variable content, with args providing the variable content to fill in the placeholders. The kwargs can be used to customize the logging behavior (e.g., exception information, stack information, etc.).\n\n        Args:\n            msg (str):\n                 The message to log or a format string containing placeholders for variable content.\n            *args:\n                 Variable length argument list to fill in the placeholders within the msg, if any.\n            **kwargs:\n                 Arbitrary keyword arguments passed to the underlying logging function.\n\n        Returns:\n            None:\n                 This function does not return as it exits the process after logging.\n\n        Raises:\n            SystemExit:\n                 The process will exit with a non-zero exit code after logging the fatal message.\n\n        \"\"\"\n        ...\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Logs a message with the given level on this logger.\n        The message is formatted using the provided positional and keyword arguments. The level corresponds to the\n        severity of the message and should be an integer representing a standard logging level (e.g., logging.DEBUG,\n        logging.INFO, etc.).\n\n        Args:\n            level (int):\n                 An integer representing the logging level indicating the severity of the\n                message. For example, logging.DEBUG, logging.INFO, etc.\n            msg (str):\n                 The message format string to log. This will be merged with args and kwargs to\n                produce the final message string.\n            *args:\n                 Variable length argument list that is merged with msg using str.format() to create\n                the final message string.\n            **kwargs:\n                 Arbitrary keyword arguments that are used for advanced formatting when merging with msg.\n\n        Returns:\n\n        Raises:\n            ValueError:\n                 If the message formatting fails due to improper args or kwargs.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.critical","title":"<code>critical(msg, *args, **kwargs)</code>","text":"<p>Logs a message with level 'CRITICAL' on this logger. The message 'msg' is logged on the logger with the integer level CRITICAL. The arguments are interpreted as for fmt.format(). Exception information is added to the logging message if the 'exc_info' keyword argument is set to a true value. If an exception tuple (in the format returned by sys.exc_info()) or an exception instance is provided as 'exc_info', it is used; otherwise, sys.exc_info() is called to get the exception information.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message format string to log.</p> required <code>*args</code> <p>Variable length argument list to pass to the message format string.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments. Commonly used keyword arguments are 'exc_info' to add exception information to the message, and 'extra' which is used to pass additional information for the logger to emit with the message.</p> <code>{}</code> <p>Returns:</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def critical(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs a message with level 'CRITICAL' on this logger.\n    The message 'msg' is logged on the logger with the integer level CRITICAL. The arguments are interpreted as for fmt.format(). Exception information is added to the logging message if the 'exc_info' keyword argument is set to a true value. If an exception tuple (in the format returned by sys.exc_info()) or an exception instance is provided as 'exc_info', it is used; otherwise, sys.exc_info() is called to get the exception information.\n\n    Args:\n        msg (str):\n             The message format string to log.\n        *args:\n             Variable length argument list to pass to the message format string.\n        **kwargs:\n             Arbitrary keyword arguments. Commonly used keyword arguments are 'exc_info' to add exception information to the message, and 'extra' which is used to pass additional information for the logger to emit with the message.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.debug","title":"<code>debug(msg, *args, **kwargs)</code>","text":"<p>Logs a debug message to the console or a file, if configured.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be logged.</p> required <code>*args</code> <p>Variable length argument list that may be used to pass in objects for formatting the message.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that may be used for providing additional information to fine-tune the logging behavior.</p> <code>{}</code> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def debug(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs a debug message to the console or a file, if configured.\n\n    Args:\n        msg (str):\n             The message to be logged.\n        *args:\n             Variable length argument list that may be used to pass in objects for\n            formatting the message.\n        **kwargs:\n             Arbitrary keyword arguments that may be used for providing\n            additional information to fine-tune the logging behavior.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.error","title":"<code>error(msg, *args, **kwargs)</code>","text":"<p>Logs an error message with additional context provided by arguments. This method is used to log error level messages. The message can be formatted with additional arguments and keyword arguments to provide context for the error. It is especially useful in a logging system where the error message, along with its context, is recorded or reported.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message to log. This should be a clear and concise description of the error.</p> required <code>*args</code> <p>Variable length argument list used to format the msg.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments which can be used to provide additional information for formatting the error message.</p> <code>{}</code> <p>Returns:</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def error(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs an error message with additional context provided by arguments.\n    This method is used to log error level messages. The message can be\n    formatted with additional arguments and keyword arguments to provide\n    context for the error. It is especially useful in a logging system where\n    the error message, along with its context, is recorded or reported.\n\n    Args:\n        msg (str):\n             The error message to log. This should be a clear and concise\n            description of the error.\n        *args:\n             Variable length argument list used to format the msg.\n        **kwargs:\n             Arbitrary keyword arguments which can be used to provide\n            additional information for formatting the error message.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.exception","title":"<code>exception(msg, *args, exc_info=True, **kwargs)</code>","text":"<p>Logs an exception message along with the traceback information, if exc_info is True.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>A human-readable message describing the exception.</p> required <code>*args</code> <p>Variable length argument list that may be used by the logging formatter.</p> <code>()</code> <code>exc_info</code> <code>bool</code> <p>Determines whether to log exception traceback information. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments which may be passed to the logger.</p> <code>{}</code> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def exception(self, msg, *args, exc_info=True, **kwargs):\n    \"\"\"\n    Logs an exception message along with the traceback information, if exc_info is True.\n\n    Args:\n        msg (str):\n             A human-readable message describing the exception.\n        *args:\n             Variable length argument list that may be used by the logging formatter.\n        exc_info (bool, optional):\n             Determines whether to log exception traceback information. Defaults to True.\n        **kwargs:\n             Arbitrary keyword arguments which may be passed to the logger.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.fatal","title":"<code>fatal(msg, *args, **kwargs)</code>","text":"<p>Logs a message with severity 'FATAL' on the logger instance, then exits the program with a non-zero exit code. The message can be a string message or a string with placeholders for variable content, with args providing the variable content to fill in the placeholders. The kwargs can be used to customize the logging behavior (e.g., exception information, stack information, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log or a format string containing placeholders for variable content.</p> required <code>*args</code> <p>Variable length argument list to fill in the placeholders within the msg, if any.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments passed to the underlying logging function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <p>This function does not return as it exits the process after logging.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>The process will exit with a non-zero exit code after logging the fatal message.</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def fatal(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs a message with severity 'FATAL' on the logger instance, then exits the program with a non-zero exit code. The message can be a string message or a string with placeholders for variable content, with args providing the variable content to fill in the placeholders. The kwargs can be used to customize the logging behavior (e.g., exception information, stack information, etc.).\n\n    Args:\n        msg (str):\n             The message to log or a format string containing placeholders for variable content.\n        *args:\n             Variable length argument list to fill in the placeholders within the msg, if any.\n        **kwargs:\n             Arbitrary keyword arguments passed to the underlying logging function.\n\n    Returns:\n        None:\n             This function does not return as it exits the process after logging.\n\n    Raises:\n        SystemExit:\n             The process will exit with a non-zero exit code after logging the fatal message.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.info","title":"<code>info(msg, *args, **kwargs)</code>","text":"<p>Logs an informational message to the console or designated log handler. This method logs a message with an 'INFO' level. The args provided are used to format the msg string using the standard string formatting operator. Additional kwargs are passed to the underlying logging handler and can control various aspects of the logging process such as the stack info and the exception information.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message format string to log.</p> required <code>*args</code> <p>Variable length argument list used for string formatting.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def info(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs an informational message to the console or designated log handler.\n    This method logs a message with an 'INFO' level. The args provided are\n    used to format the msg string using the standard string formatting\n    operator. Additional kwargs are passed to the underlying logging\n    handler and can control various aspects of the logging process such as\n    the stack info and the exception information.\n\n    Args:\n        msg (str):\n             The message format string to log.\n        *args:\n             Variable length argument list used for string formatting.\n        **kwargs:\n             Arbitrary keyword arguments.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.log","title":"<code>log(level, msg, *args, **kwargs)</code>","text":"<p>Logs a message with the given level on this logger. The message is formatted using the provided positional and keyword arguments. The level corresponds to the severity of the message and should be an integer representing a standard logging level (e.g., logging.DEBUG, logging.INFO, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>An integer representing the logging level indicating the severity of the message. For example, logging.DEBUG, logging.INFO, etc.</p> required <code>msg</code> <code>str</code> <p>The message format string to log. This will be merged with args and kwargs to produce the final message string.</p> required <code>*args</code> <p>Variable length argument list that is merged with msg using str.format() to create the final message string.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that are used for advanced formatting when merging with msg.</p> <code>{}</code> <p>Returns:</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message formatting fails due to improper args or kwargs.</p> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def log(self, level, msg, *args, **kwargs):\n    \"\"\"\n    Logs a message with the given level on this logger.\n    The message is formatted using the provided positional and keyword arguments. The level corresponds to the\n    severity of the message and should be an integer representing a standard logging level (e.g., logging.DEBUG,\n    logging.INFO, etc.).\n\n    Args:\n        level (int):\n             An integer representing the logging level indicating the severity of the\n            message. For example, logging.DEBUG, logging.INFO, etc.\n        msg (str):\n             The message format string to log. This will be merged with args and kwargs to\n            produce the final message string.\n        *args:\n             Variable length argument list that is merged with msg using str.format() to create\n            the final message string.\n        **kwargs:\n             Arbitrary keyword arguments that are used for advanced formatting when merging with msg.\n\n    Returns:\n\n    Raises:\n        ValueError:\n             If the message formatting fails due to improper args or kwargs.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.setLevel","title":"<code>setLevel(level)</code>","text":"<p>Sets the logging level of the object.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>An integer representing the logging level to set.</p> required Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def setLevel(self, level):\n    \"\"\"\n    Sets the logging level of the object.\n\n    Args:\n        level (int):\n             An integer representing the logging level to set.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Logger/#stateforward.protocols.logger.Logger.warning","title":"<code>warning(msg, *args, **kwargs)</code>","text":"<p>Logs a warning message with optional arguments supporting variable data insertion.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log. This message can contain format strings which will be replaced by data from <code>args</code>.</p> required <code>*args</code> <p>Variable length argument list used to insert data into the <code>msg</code> format string.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments. These arguments can be used to pass additional data relevant to the logging system, such as context or error codes.</p> <code>{}</code> Source code in <code>stateforward/protocols/logger.py</code> <pre><code>def warning(self, msg, *args, **kwargs):\n    \"\"\"\n    Logs a warning message with optional arguments supporting variable data insertion.\n\n    Args:\n        msg (str):\n             The warning message to log. This message can contain format strings which will be replaced by data from `args`.\n        *args:\n             Variable length argument list used to insert data into the `msg` format string.\n        **kwargs:\n             Arbitrary keyword arguments. These arguments can be used to pass additional data relevant to the logging system, such as context or error codes.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/","title":"Queue","text":"<p>The <code>queue</code> module provides a <code>Queue</code> class as a protocol with type variable <code>T</code>, which represents the generic type of items that the queue can contain. The <code>Queue</code> class defines several methods to interact with the queue in a thread-safe manner, making it suitable for concurrent programming.</p> <ul> <li> <p><code>task_done()</code>: This method indicates that a formerly enqueued task is complete. It is typically used by queue consumers after an item has been processed.</p> </li> <li> <p><code>join()</code>: This method blocks until all items in the queue have been processed. It is used to wait for all queued tasks to be completed.</p> </li> <li> <p><code>qsize()</code>: Returns the approximate size of the queue. It may not be accurate in multithreaded contexts due to the nature of queue operations.</p> </li> <li> <p><code>empty()</code>: Returns <code>True</code> if the queue is empty, otherwise <code>False</code>. This is a snapshot of the state of the queue and may not be reliable in multithreaded environments.</p> </li> <li> <p><code>full()</code>: Determines if the queue is full. Similar to <code>empty()</code>, it's a snapshot and may not be accurate in the presence of multiple threads.</p> </li> <li> <p><code>put(item, block, timeout)</code>: Adds an item to the queue. If <code>block</code> is <code>True</code> (the default), the method blocks until a free slot is available if the queue is full, or until an optional <code>timeout</code> is reached. If <code>block</code> is <code>False</code>, the item is put on the queue if a free slot is immediately available, otherwise, the method raises a <code>Full</code> exception.</p> </li> <li> <p><code>get(block, timeout)</code>: Removes and returns an item from the queue. If <code>block</code> is <code>True</code> (the default), the method blocks until an item is available, or until an optional <code>timeout</code> is reached. If <code>block</code> is <code>False</code>, the method returns an item if one is immediately available, or raises an <code>Empty</code> exception otherwise.</p> </li> <li> <p><code>put_nowait(item)</code>: Equivalent to <code>put</code> with <code>block</code> set to <code>False</code>. It enqueues an item without blocking.</p> </li> <li> <p><code>get_nowait()</code>: Equivalent to <code>get</code> with <code>block</code> set to <code>False</code>. It attempts to immediately remove and return an item from the queue without blocking.</p> </li> </ul> <p>This module is designed to facilitate communication between producer and consumer threads without the need for explicit locking. It abstracts away the complexities of thread synchronization while providing a clear protocol for queuing and dequeueing items.</p>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue","title":"<code>Queue</code>","text":"<p>             Bases: <code>Protocol[T]</code></p> <p>A protocol that defines the expected methods and behaviors of a queue data structure. The Queue protocol specifies interface contracts for queue operations. Any queue implementation conforming to this protocol must provide these methods.</p> <p>Methods:</p> Name Description <code>task_done</code> <p>Indicate that a formerly enqueued task is complete. Used by queue consumers to signal the task is finished. The semantics of task completion depend on the concrete implementation of the queue.</p> <code>join</code> <p>Block until all items in the queue have been received and processed. This method is used to wait for the completion of all the tasks in the queue.</p> <code>qsize</code> <p>Return the approximate size of the queue. Note that the size is approximate because there may be pending add or get operations that are not yet reflected in the size.</p> <code>empty</code> <p>Check if the queue is empty. Returns True if the queue is empty, False otherwise.</p> <code>full</code> <p>Check if the queue is full. Returns True if the queue is full, False otherwise.</p> <code>put</code> <p>T, block: Optional[bool]=True, timeout: Optional[float]=None): Put an item into the queue.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item of type T to be put into the queue.</p> required <code>block</code> <code>Optional[bool]</code> <p>Whether to block if the queue is full (defaults to True).</p> required <code>timeout</code> <code>Optional[float]</code> <p>The maximum time to block for (in seconds), or None for no timeout (defaults to None).</p> required <code>get(block</code> <p>Optional[bool]=True, timeout: Optional[float]=None): Remove and return an item from the queue.</p> required <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Optional[bool]</code> <p>Whether to block if the queue is empty (defaults to True).</p> required <code>timeout</code> <code>Optional[float]</code> <p>The maximum time to block for, or None for no timeout (defaults to None).</p> required <p>Returns:</p> Name Type Description <code>put_nowait</code> <code>item</code> <p>Equivalent to put(item, False). A non-blocking variant of put method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The item to put into the queue without blocking.</p> required <code>get_nowait()</code> <p>Equivalent to get(False). A non-blocking variant of get method.</p> required <p>Returns:</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>class Queue(typing.Protocol[T]):\n    \"\"\"\n    A protocol that defines the expected methods and behaviors of a queue data structure.\n    The Queue protocol specifies interface contracts for queue operations. Any queue implementation\n    conforming to this protocol must provide these methods.\n\n    Methods:\n        task_done():\n             Indicate that a formerly enqueued task is complete.\n            Used by queue consumers to signal the task is finished. The semantics of task completion\n            depend on the concrete implementation of the queue.\n        join():\n             Block until all items in the queue have been received and processed.\n            This method is used to wait for the completion of all the tasks in the queue.\n        qsize():\n             Return the approximate size of the queue.\n            Note that the size is approximate because there may be pending add or get\n            operations that are not yet reflected in the size.\n        empty():\n             Check if the queue is empty.\n            Returns True if the queue is empty, False otherwise.\n        full():\n             Check if the queue is full.\n            Returns True if the queue is full, False otherwise.\n        put(item:\n             T, block: Optional[bool]=True, timeout: Optional[float]=None): Put an item into the queue.\n\n    Args:\n        item (T):\n             The item of type T to be put into the queue.\n        block (Optional[bool]):\n             Whether to block if the queue is full (defaults to True).\n        timeout (Optional[float]):\n             The maximum time to block for (in seconds),\n            or None for no timeout (defaults to None).\n        get(block:\n             Optional[bool]=True, timeout: Optional[float]=None): Remove and return an item from the queue.\n\n    Args:\n        block (Optional[bool]):\n             Whether to block if the queue is empty (defaults to True).\n        timeout (Optional[float]):\n             The maximum time to block for, or None for\n            no timeout (defaults to None).\n\n    Returns:\n        put_nowait(item):\n             Equivalent to put(item, False).\n            A non-blocking variant of put method.\n\n    Args:\n        item:\n             The item to put into the queue without blocking.\n        get_nowait():\n             Equivalent to get(False).\n            A non-blocking variant of get method.\n\n    Returns:\n\n    \"\"\"\n\n    def task_done(self) -&gt; None:\n        \"\"\"\n        Marks a task as successfully completed.\n        This method should be called once a task is finished and its\n        outcome is successful. It is responsible for performing any cleanup,\n        logging, or notification activities associated with task completion.\n\n        Returns:\n            None:\n                 This method does not return a value and only has side effects.\n\n        \"\"\"\n        ...\n\n    def join(self) -&gt; None:\n        \"\"\"\n        Joins a collection of elements into a single string with a specified separator.\n        This method takes all elements of a collection, converts them into strings (if they are not already), and concatenates them into a single string, separating each element by a predefined separator. If the collection is empty, the resulting string will be empty as well. The object itself should hold the collection and the separator as instance variables.\n\n        Returns:\n            None:\n                 This method does not return anything. It acts on the object directly by modifying its state, potentially setting an instance variable with the concatenated string.\n\n        \"\"\"\n        ...\n\n    def qsize(self) -&gt; int:\n        \"\"\"\n\n        Returns the number of items in the queue.\n\n        Returns:\n            int:\n                 The current number of items in the queue.\n\n        \"\"\"\n        ...\n\n    def empty(self) -&gt; bool:\n        \"\"\"\n        Checks if the current data structure is empty.\n        This method evaluates whether the data structure (such as a list, queue, stack, etc.) that it is a member of contains any elements. If there are no elements present, it returns True; otherwise, it returns False.\n\n        Returns:\n            bool:\n                 True if the data structure is empty, False otherwise.\n\n        \"\"\"\n        ...\n\n    def full(self) -&gt; bool:\n        \"\"\"\n        Checks if a structure is full.\n        This method evaluates whether a particular structure (e.g., a data container or a buffer) is\n        complete or has reached its capacity. It does not take any parameters and returns a boolean value\n        indicating the fullness of the structure.\n\n        Returns:\n            bool:\n                 True if the structure is full, False otherwise.\n\n        \"\"\"\n        ...\n\n    def put(\n        self,\n        item: T,\n        block: typing.Optional[bool] = True,\n        timeout: typing.Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"\n        Puts an item into the queue.\n        If the queue is full, the method will either block until a free slot is available or until the optional timeout occurs. An item can be any type.\n\n        Args:\n            item (T):\n                 The item to be put into the queue.\n            block (Optional[bool]):\n                 True if the method should block until a slot is free; False to have it raise the Full exception if the queue is currently full (defaults to True).\n            timeout (Optional[float]):\n                 The number of seconds to wait for a free slot before raising the Full exception if the queue is full and block is True. A 'None' timeout indicates an infinite wait (defaults to None).\n\n        Raises:\n            Full:\n                 If the queue is full and the 'block' is set to False, or if 'block' is set to True and the 'timeout' period is exceeded.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def get(\n        self,\n        block: typing.Optional[bool] = True,\n        timeout: typing.Optional[float] = None,\n    ) -&gt; T:\n        \"\"\"\n        Fetches an item from a data source with optional blocking and timeout.\n\n        Args:\n            block (typing.Optional[bool], optional):\n                 A flag to determine if the operation should wait until an item is available before returning. Defaults to True, meaning the function will block.\n            timeout (typing.Optional[float], optional):\n                 The maximum amount of time (in seconds) to wait for an item to become available. If 'None', the function may wait indefinitely. Only effective when 'block' is True. Defaults to None.\n\n        Returns:\n            T:\n                 The item fetched from the data source. The type 'T' is a placeholder for the actual data type returned by the function.\n\n        Raises:\n            TimeoutError:\n                 If a timeout is set by providing a 'timeout' argument and the operation times out before an item becomes available.\n            SomeOtherException:\n                 If the function encounters an issue specific to the implementation details (replace 'SomeOtherException' with actual exceptions specific to the context).\n\n        \"\"\"\n        ...\n\n    def put_nowait(self, item) -&gt; None:\n        \"\"\"\n        Puts an item into the queue without blocking.\n        This method adds an item to the queue without waiting for a free slot to be available if the queue is already full.\n        If the queue is full, the method will raise the `QueueFull` exception immediately.\n\n        Args:\n            item:\n                 The item to be added to the queue.\n\n        Raises:\n            QueueFull:\n                 If the queue is full and the item cannot be added without waiting.\n\n        Returns:\n\n        \"\"\"\n        ...\n\n    def get_nowait(self) -&gt; T:\n        \"\"\"\n        Retrieves and returns an item from the queue without blocking.\n        This method attempts to immediately retrieve an item from the queue. If no item\n        is available, it will raise an exception rather than waiting for an item to become available.\n\n        Returns:\n            T:\n                 The next item from the queue, if available.\n\n        Raises:\n            QueueEmptyError:\n                 If there is no item available in the queue at the time of the call.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.empty","title":"<code>empty()</code>","text":"<p>Checks if the current data structure is empty. This method evaluates whether the data structure (such as a list, queue, stack, etc.) that it is a member of contains any elements. If there are no elements present, it returns True; otherwise, it returns False.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data structure is empty, False otherwise.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def empty(self) -&gt; bool:\n    \"\"\"\n    Checks if the current data structure is empty.\n    This method evaluates whether the data structure (such as a list, queue, stack, etc.) that it is a member of contains any elements. If there are no elements present, it returns True; otherwise, it returns False.\n\n    Returns:\n        bool:\n             True if the data structure is empty, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.full","title":"<code>full()</code>","text":"<p>Checks if a structure is full. This method evaluates whether a particular structure (e.g., a data container or a buffer) is complete or has reached its capacity. It does not take any parameters and returns a boolean value indicating the fullness of the structure.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the structure is full, False otherwise.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def full(self) -&gt; bool:\n    \"\"\"\n    Checks if a structure is full.\n    This method evaluates whether a particular structure (e.g., a data container or a buffer) is\n    complete or has reached its capacity. It does not take any parameters and returns a boolean value\n    indicating the fullness of the structure.\n\n    Returns:\n        bool:\n             True if the structure is full, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.get","title":"<code>get(block=True, timeout=None)</code>","text":"<p>Fetches an item from a data source with optional blocking and timeout.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Optional[bool]</code> <p>A flag to determine if the operation should wait until an item is available before returning. Defaults to True, meaning the function will block.</p> <code>True</code> <code>timeout</code> <code>Optional[float]</code> <p>The maximum amount of time (in seconds) to wait for an item to become available. If 'None', the function may wait indefinitely. Only effective when 'block' is True. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item fetched from the data source. The type 'T' is a placeholder for the actual data type returned by the function.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If a timeout is set by providing a 'timeout' argument and the operation times out before an item becomes available.</p> <code>SomeOtherException</code> <p>If the function encounters an issue specific to the implementation details (replace 'SomeOtherException' with actual exceptions specific to the context).</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def get(\n    self,\n    block: typing.Optional[bool] = True,\n    timeout: typing.Optional[float] = None,\n) -&gt; T:\n    \"\"\"\n    Fetches an item from a data source with optional blocking and timeout.\n\n    Args:\n        block (typing.Optional[bool], optional):\n             A flag to determine if the operation should wait until an item is available before returning. Defaults to True, meaning the function will block.\n        timeout (typing.Optional[float], optional):\n             The maximum amount of time (in seconds) to wait for an item to become available. If 'None', the function may wait indefinitely. Only effective when 'block' is True. Defaults to None.\n\n    Returns:\n        T:\n             The item fetched from the data source. The type 'T' is a placeholder for the actual data type returned by the function.\n\n    Raises:\n        TimeoutError:\n             If a timeout is set by providing a 'timeout' argument and the operation times out before an item becomes available.\n        SomeOtherException:\n             If the function encounters an issue specific to the implementation details (replace 'SomeOtherException' with actual exceptions specific to the context).\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.get_nowait","title":"<code>get_nowait()</code>","text":"<p>Retrieves and returns an item from the queue without blocking. This method attempts to immediately retrieve an item from the queue. If no item is available, it will raise an exception rather than waiting for an item to become available.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The next item from the queue, if available.</p> <p>Raises:</p> Type Description <code>QueueEmptyError</code> <p>If there is no item available in the queue at the time of the call.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def get_nowait(self) -&gt; T:\n    \"\"\"\n    Retrieves and returns an item from the queue without blocking.\n    This method attempts to immediately retrieve an item from the queue. If no item\n    is available, it will raise an exception rather than waiting for an item to become available.\n\n    Returns:\n        T:\n             The next item from the queue, if available.\n\n    Raises:\n        QueueEmptyError:\n             If there is no item available in the queue at the time of the call.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.join","title":"<code>join()</code>","text":"<p>Joins a collection of elements into a single string with a specified separator. This method takes all elements of a collection, converts them into strings (if they are not already), and concatenates them into a single string, separating each element by a predefined separator. If the collection is empty, the resulting string will be empty as well. The object itself should hold the collection and the separator as instance variables.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return anything. It acts on the object directly by modifying its state, potentially setting an instance variable with the concatenated string.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def join(self) -&gt; None:\n    \"\"\"\n    Joins a collection of elements into a single string with a specified separator.\n    This method takes all elements of a collection, converts them into strings (if they are not already), and concatenates them into a single string, separating each element by a predefined separator. If the collection is empty, the resulting string will be empty as well. The object itself should hold the collection and the separator as instance variables.\n\n    Returns:\n        None:\n             This method does not return anything. It acts on the object directly by modifying its state, potentially setting an instance variable with the concatenated string.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.put","title":"<code>put(item, block=True, timeout=None)</code>","text":"<p>Puts an item into the queue. If the queue is full, the method will either block until a free slot is available or until the optional timeout occurs. An item can be any type.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to be put into the queue.</p> required <code>block</code> <code>Optional[bool]</code> <p>True if the method should block until a slot is free; False to have it raise the Full exception if the queue is currently full (defaults to True).</p> <code>True</code> <code>timeout</code> <code>Optional[float]</code> <p>The number of seconds to wait for a free slot before raising the Full exception if the queue is full and block is True. A 'None' timeout indicates an infinite wait (defaults to None).</p> <code>None</code> <p>Raises:</p> Type Description <code>Full</code> <p>If the queue is full and the 'block' is set to False, or if 'block' is set to True and the 'timeout' period is exceeded.</p> <p>Returns:</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def put(\n    self,\n    item: T,\n    block: typing.Optional[bool] = True,\n    timeout: typing.Optional[float] = None,\n) -&gt; None:\n    \"\"\"\n    Puts an item into the queue.\n    If the queue is full, the method will either block until a free slot is available or until the optional timeout occurs. An item can be any type.\n\n    Args:\n        item (T):\n             The item to be put into the queue.\n        block (Optional[bool]):\n             True if the method should block until a slot is free; False to have it raise the Full exception if the queue is currently full (defaults to True).\n        timeout (Optional[float]):\n             The number of seconds to wait for a free slot before raising the Full exception if the queue is full and block is True. A 'None' timeout indicates an infinite wait (defaults to None).\n\n    Raises:\n        Full:\n             If the queue is full and the 'block' is set to False, or if 'block' is set to True and the 'timeout' period is exceeded.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.put_nowait","title":"<code>put_nowait(item)</code>","text":"<p>Puts an item into the queue without blocking. This method adds an item to the queue without waiting for a free slot to be available if the queue is already full. If the queue is full, the method will raise the <code>QueueFull</code> exception immediately.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The item to be added to the queue.</p> required <p>Raises:</p> Type Description <code>QueueFull</code> <p>If the queue is full and the item cannot be added without waiting.</p> <p>Returns:</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def put_nowait(self, item) -&gt; None:\n    \"\"\"\n    Puts an item into the queue without blocking.\n    This method adds an item to the queue without waiting for a free slot to be available if the queue is already full.\n    If the queue is full, the method will raise the `QueueFull` exception immediately.\n\n    Args:\n        item:\n             The item to be added to the queue.\n\n    Raises:\n        QueueFull:\n             If the queue is full and the item cannot be added without waiting.\n\n    Returns:\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.qsize","title":"<code>qsize()</code>","text":"<p>Returns the number of items in the queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current number of items in the queue.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def qsize(self) -&gt; int:\n    \"\"\"\n\n    Returns the number of items in the queue.\n\n    Returns:\n        int:\n             The current number of items in the queue.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/Protocols/Queue/#stateforward.protocols.queue.Queue.task_done","title":"<code>task_done()</code>","text":"<p>Marks a task as successfully completed. This method should be called once a task is finished and its outcome is successful. It is responsible for performing any cleanup, logging, or notification activities associated with task completion.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value and only has side effects.</p> Source code in <code>stateforward/protocols/queue.py</code> <pre><code>def task_done(self) -&gt; None:\n    \"\"\"\n    Marks a task as successfully completed.\n    This method should be called once a task is finished and its\n    outcome is successful. It is responsible for performing any cleanup,\n    logging, or notification activities associated with task completion.\n\n    Returns:\n        None:\n             This method does not return a value and only has side effects.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Python/API/StateMachine/Clock/","title":"Clock","text":"<p>The <code>clock</code> module provides the <code>Clock</code> class which extends from the <code>element.Element</code> base class. It is designed to manage time in a flexible manner, allowing the simulation or manipulation of the time progression through a scale multiplier.</p> <p>The <code>Clock</code> class contains two main attributes: - <code>multiplier</code>: A float that represents the scale by which the actual time interval is multiplied. By default, it is set to <code>0.001</code>, which means that time is scaled to milliseconds. This can be changed upon initialization or later during the execution of the program. - <code>start_time</code>: A <code>datetime</code> object that marks the starting point of the clock. If not specified during instantiation, it defaults to the current UTC time.</p> <p>The class provides an initializer (<code>__init__</code>) which takes two optional parameters: - <code>start_time</code>: A <code>datetime</code> object to set the starting time of the clock. If not provided, it uses the current UTC time. - <code>scale</code>: A float that sets the multiplier for the interval. It defaults to the existing class attribute <code>multiplier</code> if not provided.</p> <p>The <code>Clock</code> class also includes a method <code>now</code> that returns the current time. This time is calculated based on the <code>start_time</code> and adjusted by the <code>multiplier</code> to simulate different time progressions (faster or slower). If <code>start_time</code> is <code>None</code>, the method simply returns the current UTC time.</p> <p>Additionally, the module contains a <code>compile</code> class method annotated with <code>@classmethod</code> within a comment block, but its implementation is omitted from the documentation as it does not pertain directly to the <code>Clock</code> class's functionality.</p>"},{"location":"Python/API/StateMachine/Clock/#stateforward.state_machine.clocks.clock.Clock","title":"<code>Clock</code>","text":"<p>             Bases: <code>Element</code></p> <p>A class representing a scalable clock which can simulate the passage of time at different speeds.</p> <p>Attributes:</p> Name Type Description <code>multiplier</code> <code>float</code> <p>A scaling factor for the time interval, where by default 1 millisecond (0.001) is used as a scaling unit.</p> <code>start_time</code> <code>Union[datetime, None]</code> <p>The reference start time from which the clock begins, or None if it uses the current UTC time when an object is initialized.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Optional[datetime]=None, scale: float=None): Initializes the Clock instance with a start_time and a given scaling factor. If no start_time is provided, the current UTC time is used. If no scaling factor is provided, the default multiplier is used.</p> <code>now</code> <p>Retrieves the current time according to the clock's scaling factor and the time elapsed since the start_time. If start_time was not set, it returns the current UTC time.</p> Source code in <code>stateforward/state_machine/clocks/clock.py</code> <pre><code>class Clock(element.Element):\n    \"\"\"\n    A class representing a scalable clock which can simulate the passage of time at different speeds.\n\n    Attributes:\n        multiplier (float):\n             A scaling factor for the time interval, where by default 1 millisecond (0.001)\n            is used as a scaling unit.\n        start_time (Union[datetime, None]):\n             The reference start time from which the clock begins, or None\n            if it uses the current UTC time when an object is initialized.\n\n    Methods:\n        __init__(self, start_time:\n             Optional[datetime]=None, scale: float=None):\n            Initializes the Clock instance with a start_time and a given scaling factor.\n            If no start_time is provided, the current UTC time is used. If no scaling factor\n            is provided, the default multiplier is used.\n        now(self) -&gt; datetime:\n            Retrieves the current time according to the clock's scaling factor and the time elapsed\n            since the start_time. If start_time was not set, it returns the current UTC time.\n\n    \"\"\"\n    multiplier: float = 0.001  # multiplier for the interval in seconds defaults to 1ms\n    start_time: typing.Union[datetime, None] = None\n\n    def __init__(\n        self, start_time: typing.Optional[datetime] = None, scale: float = None\n    ):\n        \"\"\"\n        Initializes a new instance of the class.\n        This constructor sets up the instance with an optional start time and scale. If no start time is provided, the current UTC time is used. Similarly, if no scale value is provided, the default scale defined in the class instance is used.\n\n        Args:\n            start_time (Optional[datetime], optional):\n                 The start time for the instance. Defaults to None, in which case the current UTC time is used.\n            scale (float, optional):\n                 A multiplier value for scaling. Defaults to None, in which the default class scale value is used.\n\n        \"\"\"\n        self.start_time = start_time or datetime.utcnow()\n        self.multiplier = scale or self.multiplier\n\n    def now(self) -&gt; datetime:\n        \"\"\"\n        Calculates the adjusted current time for an instance based on its start time and a time multiplier.\n        This method determines the 'current' time for the object by either returning the real current UTC time if the object's\n        start time is not set, or by calculating the time that has passed since the object's start time, adjusting it with\n        the specified multiplier, and then adding this adjusted duration to the start time.\n\n        Returns:\n            datetime:\n                 The adjusted current time for the instance if the start time is set, otherwise the real current UTC time.\n\n        \"\"\"\n        if self.start_time is None:\n            return datetime.utcnow()\n        return self.start_time + timedelta(\n            seconds=(datetime.utcnow() - self.start_time).total_seconds()\n            * self.multiplier\n        )\n</code></pre>"},{"location":"Python/API/StateMachine/Clock/#stateforward.state_machine.clocks.clock.Clock.__init__","title":"<code>__init__(start_time=None, scale=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Optional[datetime]</code> <p>The start time for the instance. Defaults to None, in which case the current UTC time is used.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A multiplier value for scaling. Defaults to None, in which the default class scale value is used.</p> <code>None</code> Source code in <code>stateforward/state_machine/clocks/clock.py</code> <pre><code>def __init__(\n    self, start_time: typing.Optional[datetime] = None, scale: float = None\n):\n    \"\"\"\n    Initializes a new instance of the class.\n    This constructor sets up the instance with an optional start time and scale. If no start time is provided, the current UTC time is used. Similarly, if no scale value is provided, the default scale defined in the class instance is used.\n\n    Args:\n        start_time (Optional[datetime], optional):\n             The start time for the instance. Defaults to None, in which case the current UTC time is used.\n        scale (float, optional):\n             A multiplier value for scaling. Defaults to None, in which the default class scale value is used.\n\n    \"\"\"\n    self.start_time = start_time or datetime.utcnow()\n    self.multiplier = scale or self.multiplier\n</code></pre>"},{"location":"Python/API/StateMachine/Clock/#stateforward.state_machine.clocks.clock.Clock.now","title":"<code>now()</code>","text":"<p>Calculates the adjusted current time for an instance based on its start time and a time multiplier. This method determines the 'current' time for the object by either returning the real current UTC time if the object's start time is not set, or by calculating the time that has passed since the object's start time, adjusting it with the specified multiplier, and then adding this adjusted duration to the start time.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The adjusted current time for the instance if the start time is set, otherwise the real current UTC time.</p> Source code in <code>stateforward/state_machine/clocks/clock.py</code> <pre><code>def now(self) -&gt; datetime:\n    \"\"\"\n    Calculates the adjusted current time for an instance based on its start time and a time multiplier.\n    This method determines the 'current' time for the object by either returning the real current UTC time if the object's\n    start time is not set, or by calculating the time that has passed since the object's start time, adjusting it with\n    the specified multiplier, and then adding this adjusted duration to the start time.\n\n    Returns:\n        datetime:\n             The adjusted current time for the instance if the start time is set, otherwise the real current UTC time.\n\n    \"\"\"\n    if self.start_time is None:\n        return datetime.utcnow()\n    return self.start_time + timedelta(\n        seconds=(datetime.utcnow() - self.start_time).total_seconds()\n        * self.multiplier\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Elements/","title":"Elements","text":"<p>The <code>elements</code> module provides a comprehensive set of classes that represent various components of a state machine. The classes in this module can be utilized to model the states, transitions, events, and behaviors within a state machine architecture. Below is an overview of the main classes and enumerations within the module, each designed to encapsulate specific aspects of state machine behavior and functionality.</p>"},{"location":"Python/API/StateMachine/Elements/#stateforward.state_machine.elements--classes","title":"Classes","text":"<ul> <li> <p><code>Vertex</code>: The base class for nodes within the state machine graph, which can have incoming and outgoing transitions.</p> </li> <li> <p><code>Transition</code>: Represents a state change in the state machine, connecting two vertices and potentially associated with triggering events, guards, and effects.</p> </li> <li> <p><code>TransitionPath</code>: Describes the sequence of vertices a transition passes through, including the vertices to enter and leave during the transition.</p> </li> </ul>"},{"location":"Python/API/StateMachine/Elements/#stateforward.state_machine.elements--enumerations","title":"Enumerations","text":"<ul> <li> <p><code>ConcurrencyKind</code>: Defines the types of concurrency mechanisms used, like <code>threading</code>, <code>multiprocessing</code>, or <code>asynchronous</code> execution.</p> </li> <li> <p><code>TransitionKind</code>: Categorizes transitions as <code>internal</code>, <code>local</code>, <code>external</code>, or <code>self</code> transitions.</p> </li> <li> <p><code>PseudostateKind</code>: Specifies various types of control nodes within the state machine, such as <code>initial</code>, <code>choice</code>, <code>join</code>, <code>fork</code>, and others.</p> </li> </ul>"},{"location":"Python/API/StateMachine/Elements/#stateforward.state_machine.elements--subclasses","title":"Subclasses","text":"<ul> <li> <p><code>FinalState</code>: Represents an end state for a region within a state machine.</p> </li> <li> <p><code>Pseudostate</code>: A subclass of <code>Vertex</code>, representing different kinds of control points within the state machine, such as initial states or junction points.</p> </li> <li> <p><code>State</code>: A vertex that may contain nested regions, representing a state which can also have entry and exit behaviors.</p> </li> <li> <p><code>Region</code>: Organizes the structure of states and transitions, representing a distinct context for stateful behaviors.</p> </li> <li> <p><code>Event</code>: The base class for events which can trigger transitions.</p> </li> <li> <p><code>Constraint</code>: Represents a condition that guards transitions or influences state behavior.</p> </li> <li> <p><code>StateMachine</code>: Encapsulates the entire state machine structure and behavior, acting as a container for states, regions, and transitions.</p> </li> </ul>"},{"location":"Python/API/StateMachine/Elements/#stateforward.state_machine.elements--other-components","title":"Other Components","text":"<ul> <li> <p><code>Behavior</code>: Encapsulates the action or activity associated with a state or event within the state machine.</p> </li> <li> <p><code>CompletionEvent</code>: Represents an event that is fired upon the completion of a state's internal activity.</p> </li> <li> <p><code>ChangeEvent</code>: Triggers a transition based on a conditional expression being satisfied.</p> </li> <li> <p><code>TimeEvent</code>: Is fired when a specific time-related condition is met, like a timeout or an elapsed time period.</p> </li> </ul> <p>This module is intended to be used in conjunction with other modules and utilities that form a framework for state management and behavior modeling. The components defined here can be extended or used as is to create complex and robust state machines for various application domains.</p>"},{"location":"Python/API/StateMachine/Overview/","title":"Overview","text":"<p>The <code>__init__</code> module serves as the entry point for the package. It initializes the package and makes the functions and elements from the submodules <code>functional</code> and <code>elements</code> available at the package level. This is achieved by importing all the contents from these submodules, which allows the user to access these functions and elements directly without needing to import them individually from their respective submodules. By doing so, it simplifies the import statements required in client code and offers a more convenient interface to work with the components provided by the package.</p>"},{"location":"Python/API/StateMachine/Preprocessor/","title":"Preprocessor","text":""},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor","title":"<code>preprocessor</code>","text":"<p>The <code>preprocessor</code> module is responsible for transforming the abstract representation of a state machine into a form that is ready for execution. This involves enriching the state machine's constituents, such as vertices, transitions, and regions, with additional metadata and associations that are necessary for runtime processing. The preprocessing stage plays a crucial role in setting up the state machine by defining the relationships between its parts, refining its behaviors, and establishing the conditions for event handling and state transition.</p> <p>The module provides a <code>StateMachinePreprocessor</code> class which houses methods corresponding to different elements of the state machine, including:</p> <ul> <li> <p><code>preprocess_vertex</code>: It enriches vertices of the state machine by finding their containers, and categorizing incoming and outgoing transitions.</p> </li> <li> <p><code>preprocess_state</code>: This method refines states by handling instances that are composite states and manages behaviors such as entry, exit, and activity. It also addresses the incorporation of submachines within states.</p> </li> <li> <p><code>preprocess_composite_state</code>: Composite states, which contain regions and substates, are processed to ensure proper nesting and transition management.</p> </li> <li> <p><code>create_transition_path</code>: Based on the kind of transition (external, local, or self), this method constructs a transition path that defines the order in which states are to be entered and exited during the transition.</p> </li> <li> <p><code>preprocess_final_state</code>: This method handles the preprocessing of final states within the state machine.</p> </li> <li> <p><code>preprocess_transition</code>: Transitions between states are prepared by associating sources, targets, containers, and events, and by determining the transition kind.</p> </li> <li> <p><code>preprocess_region</code>: Regions, which are collections of vertices, are preprocessed such that each region is aware of its associated initial state and parent state machine or composite state.</p> </li> <li> <p><code>preprocess_processor</code>: This method is responsible for setting up the interpreter with the correct asynchronous behavior if required by the state machine's concurrency model.</p> </li> <li> <p><code>preprocess_call_event</code>, <code>preprocess_change_event</code>, and <code>preprocess_behavior</code>: These methods are dedicated to processing different types of events and behaviors, ensuring that their invocation and state changes are correctly managed according to whether the operations are coroutine functions or regular functions.</p> </li> <li> <p><code>preprocess_state_machine</code>: Finally, this method ties together all preprocessing steps for the overall state machine, ensuring it is ready for execution with all the necessary properties and behaviors set up.</p> </li> </ul> <p>This module does not depend on specific external imports as it's mainly focused on setting up the state machine internals based on provided abstract definitions. The class and method definitions within the module leverage functionalities from the <code>stateforward</code> package which defines the model and core functionalities required for state machine processing.</p>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor","title":"<code>StateMachinePreprocessor</code>","text":"<p>             Bases: <code>Preprocessor</code></p> <p>A preprocessor class for state machine models that extends the functionality of a base model preprocessor. This class contains methods for preprocessing various elements within a state machine such as vertices, states, composite states, final states, transitions, regions, processors, call events, change events, behaviors, and the state machine itself. Each preprocessing method makes modifications to the elements, ensuring they are correctly configured within the state machine\u2019s model, and establishing connections and relationships as needed. The class initializes with a logger attribute for logging messages and warnings during the preprocessing stage.</p> <p>Attributes:</p> Name Type Description <code>log</code> <code>Logger</code> <p>A logger instance used for outputting debug and error information during preprocessing.</p> <p>Methods:</p> Name Description <code>preprocess_vertex</code> <p>Parses a vertex element, setting up its container, as well as outgoing and incoming transitions.</p> <code>preprocess_state</code> <p>Processes a state element, handling submachine preprocessing and setting up entry, exit, and activity behaviors before delegating to vertex preprocessing.</p> <code>preprocess_composite_state</code> <p>Handles preprocessing for composite states, creating regions, and categorizing internal transitions and subvertices.</p> <code>create_transition_path</code> <p>Creates a transition path for transitions, factoring in the kind of transition and the hierarchy of source and target states.</p> <code>preprocess_final_state</code> <p>Preprocessor for final state elements, mainly delegates to vertex preprocessing.</p> <code>preprocess_transition</code> <p>Handles the preparation of transition elements, setting source, target, events effect, container, and transition path.</p> <code>preprocess_region</code> <p>Processes region elements, setting up subvertices, initial states, state machines, and linkages to states or state machines.</p> <code>preprocess_processor</code> <p>Prepares a model interpreter with the appropriate queue depending on the concurrency kind.</p> <code>preprocess_call_event</code> <p>Processes call event elements, particularly attaching coroutine-friendly call methods when operations are asynchronous.</p> <code>preprocess_change_event</code> <p>Preprocesses change event elements and sets up associated conditions.</p> <code>preprocess_behavior</code> <p>Preprocessor for behavior elements, ensuring correct activities are set dependent on concurrency and establishing event pools and contexts.</p> <code>preprocess_state_machine</code> <p>Comprehensive preprocessing for the state machine which involves state, behavior, and transition preprocessing along with additional configurations.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>class StateMachinePreprocessor(model.Preprocessor):\n    \"\"\"\n    A preprocessor class for state machine models that extends the functionality of a base model preprocessor.\n    This class contains methods for preprocessing various elements within a state machine such as vertices, states, composite states, final states, transitions, regions, processors, call events, change events, behaviors, and the state machine itself. Each preprocessing method makes modifications to the elements, ensuring they are correctly configured within the state machine\u2019s model, and establishing connections and relationships as needed.\n    The class initializes with a logger attribute for logging messages and warnings during the preprocessing stage.\n\n    Attributes:\n        log (Logger):\n             A logger instance used for outputting debug and error information during preprocessing.\n\n    Methods:\n        preprocess_vertex:\n             Parses a vertex element, setting up its container, as well as outgoing and incoming transitions.\n        preprocess_state:\n             Processes a state element, handling submachine preprocessing and setting up entry, exit, and activity behaviors before delegating to vertex preprocessing.\n        preprocess_composite_state:\n             Handles preprocessing for composite states, creating regions, and categorizing internal transitions and subvertices.\n        create_transition_path:\n             Creates a transition path for transitions, factoring in the kind of transition and the hierarchy of source and target states.\n        preprocess_final_state:\n             Preprocessor for final state elements, mainly delegates to vertex preprocessing.\n        preprocess_transition:\n             Handles the preparation of transition elements, setting source, target, events effect, container, and transition path.\n        preprocess_region:\n             Processes region elements, setting up subvertices, initial states, state machines, and linkages to states or state machines.\n        preprocess_processor:\n             Prepares a model interpreter with the appropriate queue depending on the concurrency kind.\n        preprocess_call_event:\n             Processes call event elements, particularly attaching coroutine-friendly call methods when operations are asynchronous.\n        preprocess_change_event:\n             Preprocesses change event elements and sets up associated conditions.\n        preprocess_behavior:\n             Preprocessor for behavior elements, ensuring correct activities are set dependent on concurrency and establishing event pools and contexts.\n        preprocess_state_machine:\n             Comprehensive preprocessing for the state machine which involves state, behavior, and transition preprocessing along with additional configurations.\n\n    \"\"\"\n\n    log: Logger = create_logger(\"StateMachinePreprocessor\")\n\n    def preprocess_vertex(self, element: type[\"core.Vertex\"]):\n        \"\"\"\n        Processes the given vertex by assigning it a container and categorizing its incoming and outgoing transitions.\n\n        Args:\n            element (type['core.Vertex']):\n                 The vertex element to preprocess. This vertex should be part of a state machine model.\n                The function logs the process of finding the container for the given vertex. If no container is found, an error is logged.\n                Furthermore, the function identifies and categorizes all outgoing and incoming transitions of the vertex. It checks for transitions that are either originating from or targeting the element. It updates the 'outgoing' and 'incoming' attributes of the element with the newly found transitions.\n\n        \"\"\"\n        logger = create_logger(f\"preprocess_vertex({model.qualified_name_of(element)})\")\n        logger.debug(f\"finding container for {model.qualified_name_of(element)}\")\n        container = model.find_ancestor_of(\n            element,\n            lambda owned_element: model.element.is_subtype(owned_element, core.Region),\n        )\n\n        if container is None:\n            logger.error(f\"vertex {model.qualified_name_of(element)} has no container\")\n        logger.debug(f\"found container {model.qualified_name_of(container)}\")\n        model.set_attribute(element, \"container\", container)\n\n        outgoing = list(element.outgoing) if element.outgoing else []\n        incoming = list(element.incoming) if element.incoming else []\n        for transition in model.find_descendants_of(\n            model.of(element),\n            lambda owned_element: model.element.is_subtype(\n                owned_element, core.Transition\n            ),\n        ):\n            if (\n                transition.source or model.owner_of(transition)\n            ) == element and transition not in outgoing:\n                outgoing.append(transition)\n            elif transition.target == element and transition not in incoming:\n                incoming.append(transition)\n        model.set_attribute(element, \"outgoing\", model.collection(*outgoing))\n        model.set_attribute(element, \"incoming\", model.collection(*incoming))\n\n    def preprocess_state(self, element: type[\"core.State\"]):\n        \"\"\"\n        Preprocesses a state in the state machine for further operations.\n        This method takes a state as an argument and performs preprocessing step depending on whether it is a composite state or contains a submachine. If the state has a submachine, it gets logged. Additionally, it handles the preprocessing for the vertices of the state and ensures that 'entry', 'exit', and 'activity' behaviors are set on the state if they are not already defined.\n\n        Args:\n            element (core.State):\n                 The state to preprocess. This type should be derived from a class that has an attribute 'submachine', which indicates whether the state is a simple state or a composite state with its own submachine.\n\n        Returns:\n\n        \"\"\"\n        if element.submachine is None:\n            self.preprocess_composite_state(element)\n        else:\n            self.log.warning(\n                f\"preprocessing submachine {element} {getattr(element, 'entry', None)}\"\n            )\n            # for region in element.submachine.regions.core():\n            #     model.set_attribute(region, \"state\", element)\n            #     model.set_attribute(region, \"state_machine\", None)\n\n        self.preprocess_vertex(element)\n\n        for behavior in (\"entry\", \"exit\", \"activity\"):\n            if getattr(element, behavior) is None:\n                model.set_attribute(\n                    element,\n                    behavior,\n                    model.element.new(behavior, bases=(core.Behavior,)),\n                )\n\n    def preprocess_composite_state(self, element: type[\"core.CompositeState\"]):\n        \"\"\"\n        Processes a composite state to organize its sub-elements such as transitions, vertices, and regions.\n        This method takes an element that is assumed to be a composite state, and iterates over its owned elements\n        to categorize them into transitions, subvertices, and regions. If there are subvertices without an enclosing region,\n        a new region is created to contain them along with any associated transitions. Existing regions within the composite state\n        are preserved. The method then ensures that all transitions and subvertices are assigned to a region, either the new region\n        or one of the existing ones, by updating their 'container' attributes. If an owned element corresponds to an attribute of\n        the composite state, that association is maintained within the newly formed or existing region.\n\n        Args:\n            element (type['core.CompositeState']):\n                 The composite state to be preprocessed, expected to be an instance of 'core.CompositeState'.\n\n        Returns:\n            None:\n                 This method modifies the composite state element in-place and has no return value.\n\n        \"\"\"\n        transitions = []\n        subvertex = []\n        regions = []\n        for owned_element in [\n            _owned_element\n            for _owned_element in model.owned_elements_of(element)\n            if not any(\n                model.is_descendant_of(region, _owned_element) for region in regions\n            )\n        ]:\n            if model.element.is_subtype(owned_element, core.Transition):\n                transitions.append(owned_element)\n            elif model.element.is_type(owned_element, model.Collection) and all(\n                model.element.is_subtype(_child, core.Transition)\n                for _child in owned_element\n            ):\n                transitions.extend(owned_element)\n            elif model.element.is_subtype(owned_element, core.Vertex):\n                subvertex.append(owned_element)\n            elif model.element.is_subtype(owned_element, core.Region):\n                regions.append(owned_element)\n        if subvertex:\n            new_region = model.element.new(\n                f\"region_{len(regions)}\",\n                bases=(core.Region,),\n            )\n            model.set_attribute(\n                element,\n                \"regions\",\n                model.collection(new_region, *regions),\n            )\n            for owned_element in subvertex + transitions:\n                if (\n                    owner_of_owned_element := model.owner_of(owned_element)\n                ) is not None:\n                    owned_element = model.remove_owned_element_from(\n                        owner_of_owned_element, owned_element\n                    )\n                    model.set_attribute(owned_element, \"container\", new_region)\n                if (\n                    owned_element_name := model.name_of(owned_element)\n                ) in model.attributes_of(element):\n                    model.set_attribute(new_region, owned_element_name, owned_element)\n                else:\n                    model.add_owned_element_to(new_region, owned_element)\n        elif regions:\n            model.set_attribute(element, \"regions\", model.collection(*regions))\n\n        # else:\n        #     model.set_attribute(element, \"region\", model.collection())\n\n    def create_transition_path(self, transition: type[\"core.Transition\"]):\n        \"\"\"\n        Generates and returns a transition path object based on the provided transition.\n        This method analyzes the provided transition object to determine the path of\n        state entries and exits required for a state machine transition. This is done\n        by examining the `source`, `target`, and `kind` attributes of the `transition`\n        object. Depending on the kind of transition (external, local, or self), it\n        assembles two lists representing the states to be entered ('enter') and the\n        states to be left ('leave'). The method then uses these lists to create a new\n        transition path object with 'enter' and 'leave' as its attributes.\n\n        Args:\n            transition (core.Transition):\n                 The transition object whose path needs\n                to be created.\n\n        Returns:\n\n        \"\"\"\n        enter = []\n        leave = []\n        # TODO this can be reduced\n        if transition.kind == core.TransitionKind.external:\n            leave.append(transition.source)\n            for ancestor in model.ancestors_of(transition.source):\n                if model.id_of(ancestor) == model.id_of(transition.container):\n                    break\n                if model.element.is_subtype(ancestor, core.State):\n                    leave.append(ancestor)\n            for ancestor in model.ancestors_of(transition.target):\n                if model.id_of(ancestor) == model.id_of(transition.container):\n                    break\n                if model.element.is_subtype(ancestor, core.State):\n                    enter.insert(0, ancestor)\n            enter.append(transition.target)\n        elif transition.kind == core.TransitionKind.local:\n            for ancestor in model.ancestors_of(transition.target):\n                if model.id_of(ancestor) == model.id_of(transition.source):\n                    break\n                if model.element.is_subtype(ancestor, core.State):\n                    enter.append(ancestor)\n            enter.append(transition.target)\n        elif transition.kind == core.TransitionKind.self:\n            leave.append(transition.source)\n            enter.append(transition.target)\n        return model.element.new(\n            \"path\",\n            bases=(core.TransitionPath,),\n            enter=model.collection(*enter),\n            leave=model.collection(*leave),\n        )\n\n    def preprocess_final_state(self, element: type[\"core.FinalState\"]):\n        \"\"\"\n        Processes a final state element within the state machine before compilation.\n        This method is responsible for applying preprocessing steps to the given final state element\n        within the context of the state machine. It is designed to be overridden in subclasses for\n        specific behaviors. The default implementation delegates the preprocessing to the\n        `preprocess_vertex` method.\n\n        Args:\n            element (type['core.FinalState']):\n                 The final state element of the state machine to preprocess.\n\n        Returns:\n\n        \"\"\"\n        self.preprocess_vertex(element)\n\n    def preprocess_transition(self, element: type[\"core.Transition\"]):\n        \"\"\"\n        Preprocesses the transition element to ensure it has all the necessary attributes set up correctly.\n        This method processes a given transition element by setting up default values and verifying its\n        correctness within a state machine. It checks if the transition source is defined, and if not,\n        it attempts to derive the source based on hierarchy and ownership rules. It handles the completion\n        events for states, initializes an empty effect if none is provided, and determines the transition\n        kind based on the relationship between the source and target.\n\n        Args:\n            element (type['core.Transition']):\n                 The transition element to preprocess.\n\n        Raises:\n            ValueError:\n                 If the transition source is not found or if the transition has no container.\n                This function does not return any value but modifies the transition element in place.\n\n        \"\"\"\n        if element.source is None:\n            owner = model.owner_of(element)\n            if model.element.is_subtype(owner, model.Collection):\n                owner = model.owner_of(owner)\n            if not model.element.is_subtype(owner, core.Vertex):\n                raise ValueError(\n                    f\"transition {model.qualified_name_of(element)} has no source and is not owned by a state\"\n                )\n            # transition source always defaults to the parent\n            model.set_attribute(element, \"source\", owner)\n\n        # yield from self.wait_for_completion_of(element.source)\n        self.preprocess_element(element.source)\n        if element.events is None:\n            if model.element.is_subtype(element.source, core.State):\n                completion = element.source.completion\n                if completion is None:\n                    completion = model.element.new(\n                        \"completion\",\n                        (core.CompletionEvent,),\n                    )\n                    model.set_attribute(element.source, \"completion\", completion)\n\n                model.set_attribute(\n                    element,\n                    \"events\",\n                    model.collection(\n                        completion,\n                    ),\n                )\n\n        if element.effect is None:\n            model.set_attribute(\n                element,\n                \"effect\",\n                model.element.new(\n                    \"effect\",\n                    (core.Behavior,),\n                    activity=no_async_activity\n                    if model.of(element).concurrency_kind\n                    is core.ConcurrencyKind.asynchronous\n                    else no_activity,\n                ),\n            )\n        container = element.source.container\n        if element.source == element.target:\n            element.kind = core.TransitionKind.self\n        elif element.target is None:\n            element.kind = core.TransitionKind.internal\n        elif model.is_descendant_of(element.source, element.target):\n            element.kind = core.TransitionKind.local\n        else:\n            self.preprocess_element(element.target)\n            element.kind = core.TransitionKind.external\n            container = least_common_ancestor(element.source, element.target)\n        if container is None:\n            raise ValueError(\n                f\"transition {model.qualified_name_of(element)} has no container\"\n            )\n        model.set_attribute(element, \"container\", container)\n        path = self.create_transition_path(element)\n        model.set_attribute(element, \"path\", path)\n\n    def preprocess_region(self, element: type[\"core.Region\"]):\n        \"\"\"\n        Processes the given UML region by setting attributes and filtering sub-elements.\n        This method takes an element of type 'core.Region' and performs preprocessing to set attributes\n        related to its subvertices, initial state, parent state, and parent state machine. It identifies\n        all the subvertices of the region that are of type 'core.Vertex' and sets the 'subvertex' attribute.\n        If the region does not have an explicit initial state, this method will attempt to find one based on\n        the provided filtering criteria. Once an initial state is identified or confirmed, the method sets\n        the 'initial' attribute of the element.\n        The method also discerns and sets attributes for the region's parent state and state machine,\n        ensuring that each is appropriately classified as either a 'core.State' or 'StateMachine'.\n\n        Args:\n            element (type['core.Region']):\n                 The region of a state machine to preprocess.\n\n        Raises:\n            AttributeError:\n                 If the attributes related to 'subvertex', 'initial', 'state', or\n                'state_machine' cannot be set due to incorrect typing or hierarchy of the provided element.\n\n        Returns:\n\n        \"\"\"\n        from stateforward.core import StateMachine\n\n        def initial_filter(vertex):\n            \"\"\"\n            Determines whether a given vertex is a subtype of core.Initial.\n\n            Args:\n                vertex (Any):\n                     The vertex to be checked for being a subtype.\n\n            Returns:\n                bool:\n                     True if the vertex is a subtype of core.Initial, otherwise False.\n\n            \"\"\"\n            return model.element.is_subtype(vertex, core.Initial)\n\n        model.set_attribute(\n            element,\n            \"subvertex\",\n            model.collection(\n                *model.find_owned_elements_of(\n                    element,\n                    lambda owned_element: model.element.is_subtype(\n                        owned_element, core.Vertex\n                    ),\n                )\n            ),\n        )\n        initial = getattr(element, \"initial\", None)\n\n        if initial is None:\n            initial = model.find_owned_element_of(element, initial_filter)\n            model.set_attribute(element, \"initial\", initial)\n        else:\n            self.log.debug(\n                f\"region {model.qualified_name_of(element)} has initial {model.qualified_name_of(initial)}\"\n            )\n        parent = model.owner_of(element)\n        if not model.element.is_subtype(parent, (StateMachine, core.State)):\n            parent = model.owner_of(parent)\n        model.set_attribute(\n            element,\n            \"state\",\n            parent if model.element.is_subtype(parent, core.State) else None,\n        )\n        model.set_attribute(\n            element,\n            \"state_machine\",\n            parent if model.element.is_subtype(parent, StateMachine) else None,\n        )\n\n    def preprocess_processor(self, element: type[\"model.Interpreter\"]):\n        \"\"\"\n        Preprocesses an interpreter element to set up queue characteristics based on concurrency type.\n        This method examines the concurrency_kind attribute of the provided interpreter element and sets an attribute to use an asynchronous queue if the concurrency kind matches asynchronous operation.\n\n        Args:\n            element (type['model.Interpreter']):\n                 The interpreter element to preprocess, it must be an instance or subclass of model.Interpreter. The element is expected to have a model property with a concurrency_kind attribute.\n\n        Raises:\n            AttributeError:\n                 If the 'model' property or 'concurrency_kind' attribute is missing from the element.\n\n        \"\"\"\n        concurrency_kind = element.model.concurrency_kind\n        if concurrency_kind == core.ConcurrencyKind.asynchronous:\n            model.set_attribute(element, \"queue\", AsyncQueue)\n\n    def preprocess_call_event(self, element: type[\"core.CallEvent\"]):\n        \"\"\"\n        Processes the provided CallEvent by setting the appropriate __call__ attribute,\n        depending on whether the operation is a coroutine function or not.\n        This method decorates the given CallEvent's operation with a new __call__ method.\n        If the operation is an asynchronous coroutine function, it wraps the call in an\n        'async def' to handle the coroutine execution, sends an event to the model's interpreter,\n        and then returns the result upon completion. If the operation is a regular function,\n        it wraps the call in a 'def' and sets the result before returning.\n        After processing, the CallEvent can be invoked as a callable which automatically\n        handles the operation execution and result management.\n\n        Args:\n            element (type['core.CallEvent']):\n                 The CallEvent instance to be preprocessed.\n\n        Raises:\n            AttributeError:\n                 If the 'operation' attribute is not found in the CallEvent.\n\n        \"\"\"\n        if asyncio.iscoroutinefunction(element.operation):\n\n            async def __call__(self, *args, **kwargs):\n                \"\"\"\n                Performs an asynchronous operation and then sends its class instance to the model's interpreter.\n                This asynchronous method is a coroutine that must be awaited. It wraps an internal operation coroutine, invokes it with the supplied arguments, and then sends the current class instance to the associated interpreter, which is an attribute of the model object.\n\n                Args:\n                    *args:\n                         Variable length argument list to be passed to the internal operation coroutine.\n                    **kwargs:\n                         Arbitrary keyword arguments to be passed to the internal operation coroutine.\n\n                Returns:\n\n                Raises:\n                    Exception:\n                         Propagates any exceptions raised by the internal operation coroutine or the model's interpreter.\n\n                \"\"\"\n                value = await self.operation(*args, **kwargs)\n                await self.model.interpreter.send(self.__class__())\n                return value\n\n        else:\n\n            def __call__(self, *args, **kwargs):\n                \"\"\"\n                Performs the operation bound to the callable object and stores the result.\n                This method allows the instance to be called as a function, executing the operation method\n                with the provided arguments and keyword arguments. After execution, the result is saved\n                using the results attribute's set_result method.\n\n                Args:\n                    *args:\n                         Variable length argument list that will be passed to the operation method.\n                    **kwargs:\n                         Arbitrary keyword arguments that will be passed to the operation method.\n\n                Returns:\n\n                \"\"\"\n                value = self.operation(*args, **kwargs)\n                self.results.set_result(value)\n                return value\n\n        setattr(element, \"__call__\", __call__)\n\n    def preprocess_change_event(self, element: type[core.ChangeEvent]):\n        \"\"\"\n        Preprocesses a ChangeEvent object by assigning an asyncio.Condition to its 'condition' attribute.\n\n        Args:\n            element (type[core.ChangeEvent]):\n                 The ChangeEvent instance that is to be preprocessed.\n\n        Raises:\n            AttributeError:\n                 If 'condition' is not an attribute of the provided ChangeEvent instance.\n\n        Note:\n\n        \"\"\"\n        element.condition = asyncio.Condition\n\n    def preprocess_behavior(self, element: type[\"core.Behavior\"]):\n        \"\"\"\n        Preprocesses the behavior element to set up appropriate activities and contexts.\n        This method takes a behavior element and does the following:\n        - Determines the type of concurrency (asynchronous or synchronous) and assigns the correct no-activity function if the activity is not provided.\n        - If concurrency is asynchronous and the activity is not a coroutine function, it wraps the provided activity inside a function that can handle coroutine calling conventions.\n        - Sets the 'activity' attribute of the behavior element to the processed activity function, ensuring that it has appropriate module and qualname attributes.\n        - Identifies the context of the behavior by finding the ancestor element that is a subtype of core.Behavior.\n        - Processes all owned elements of the behavior element.\n        - Collects all events that are descendants of the behavior element and assigns them to the 'pool' attribute.\n        - Sets the 'context' attribute of the behavior element to the identified context.\n\n        Args:\n            element (type['core.Behavior']):\n                 The behavior element to preprocess.\n\n        \"\"\"\n        concurrency_kind = model.of(element).concurrency_kind\n        activity = element.activity\n        if activity is None:\n            if concurrency_kind == core.ConcurrencyKind.asynchronous:\n                activity = no_async_activity\n            else:\n                activity = no_activity\n        elif (\n            concurrency_kind == core.ConcurrencyKind.asynchronous\n            and not iscoroutinefunction(element.activity)\n        ):\n\n            def activity(self, event: \"core.Event\", _activity=element.activity):\n                \"\"\"\n                Performs an activity associated with a given event.\n                This function is designed to execute a specific activity that is tied to an event passed to the function. The activity to be executed is provided by the _activity argument, which defaults to `element.activity`. It calls this provided activity function, passing in the instance (`self`) and the event object.\n\n                Args:\n                    event (core.Event):\n                         The event object that is associated with the activity to be performed.\n                    _activity (callable, optional):\n                         A callable that represents the activity to be performed when the function is called. Defaults to `element.activity` if not provided.\n\n                Returns:\n\n                \"\"\"\n                return _activity(self, event)\n\n        activity.__module__ = model.of(element).__module__\n        activity.__qualname__ = f\"{model.qualified_name_of(element)}.activity\"\n        model.set_attribute(element, \"activity\", activity)\n        context = model.find_ancestor_of(\n            element,\n            lambda ancestor: model.element.is_subtype(ancestor, core.Behavior),\n        )\n        self.preprocess_owned_elements(element)\n\n        events = []\n        for descendant in model.descendants_of(element):\n            if model.element.is_subtype(descendant, core.Event):\n                events.append(descendant)\n        model.set_attribute(element, \"pool\", model.collection(*events))\n        model.set_attribute(\n            element,\n            \"context\",\n            context,\n        )\n\n    def preprocess_state_machine(self, element: type[\"core.Behavior\"]):\n        \"\"\"\n        Preprocesses a state machine behavior object prior to compilation.\n        This method takes an element which is an instance of a specific state machine behavior and performs preprocessing steps on it. These steps involve preprocessing any composite states within the element and the behavior itself. This is essential to prepare the element for subsequent compilation or transformation processes. It involves logging the preprocessing step, ensuring internal consistency, setting up necessary ordering, and potentially more based on the implementation details.\n        The function concludes by sorting a collection within the state machine. The sorting criteria is based on the type of event; it prioritizes non-completion events over completion events. This ordering may affect how events are processed or triggered within the state machine behavior at runtime.\n\n        Args:\n            element (core.Behavior):\n                 The state machine behavior to preprocess. This is expected to be a subtype of 'core.Behavior'.\n\n        Returns:\n            None:\n                 This method performs operations on the 'element' object but does not return any value.\n\n        \"\"\"\n        self.log.debug(\n            f\"preprocessing state machine {model.qualified_name_of(element)}\"\n        )\n        if element.submachine_state is not None:\n            return self.preprocess_state(element.submachine_state)\n        self.preprocess_composite_state(element)\n        self.preprocess_behavior(element)\n        model.sort_collection(\n            element.pool,\n            lambda event: not model.element.is_subtype(event, core.CompletionEvent),\n        )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.create_transition_path","title":"<code>create_transition_path(transition)</code>","text":"<p>Generates and returns a transition path object based on the provided transition. This method analyzes the provided transition object to determine the path of state entries and exits required for a state machine transition. This is done by examining the <code>source</code>, <code>target</code>, and <code>kind</code> attributes of the <code>transition</code> object. Depending on the kind of transition (external, local, or self), it assembles two lists representing the states to be entered ('enter') and the states to be left ('leave'). The method then uses these lists to create a new transition path object with 'enter' and 'leave' as its attributes.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>Transition</code> <p>The transition object whose path needs to be created.</p> required <p>Returns:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def create_transition_path(self, transition: type[\"core.Transition\"]):\n    \"\"\"\n    Generates and returns a transition path object based on the provided transition.\n    This method analyzes the provided transition object to determine the path of\n    state entries and exits required for a state machine transition. This is done\n    by examining the `source`, `target`, and `kind` attributes of the `transition`\n    object. Depending on the kind of transition (external, local, or self), it\n    assembles two lists representing the states to be entered ('enter') and the\n    states to be left ('leave'). The method then uses these lists to create a new\n    transition path object with 'enter' and 'leave' as its attributes.\n\n    Args:\n        transition (core.Transition):\n             The transition object whose path needs\n            to be created.\n\n    Returns:\n\n    \"\"\"\n    enter = []\n    leave = []\n    # TODO this can be reduced\n    if transition.kind == core.TransitionKind.external:\n        leave.append(transition.source)\n        for ancestor in model.ancestors_of(transition.source):\n            if model.id_of(ancestor) == model.id_of(transition.container):\n                break\n            if model.element.is_subtype(ancestor, core.State):\n                leave.append(ancestor)\n        for ancestor in model.ancestors_of(transition.target):\n            if model.id_of(ancestor) == model.id_of(transition.container):\n                break\n            if model.element.is_subtype(ancestor, core.State):\n                enter.insert(0, ancestor)\n        enter.append(transition.target)\n    elif transition.kind == core.TransitionKind.local:\n        for ancestor in model.ancestors_of(transition.target):\n            if model.id_of(ancestor) == model.id_of(transition.source):\n                break\n            if model.element.is_subtype(ancestor, core.State):\n                enter.append(ancestor)\n        enter.append(transition.target)\n    elif transition.kind == core.TransitionKind.self:\n        leave.append(transition.source)\n        enter.append(transition.target)\n    return model.element.new(\n        \"path\",\n        bases=(core.TransitionPath,),\n        enter=model.collection(*enter),\n        leave=model.collection(*leave),\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_behavior","title":"<code>preprocess_behavior(element)</code>","text":"<p>Preprocesses the behavior element to set up appropriate activities and contexts. This method takes a behavior element and does the following: - Determines the type of concurrency (asynchronous or synchronous) and assigns the correct no-activity function if the activity is not provided. - If concurrency is asynchronous and the activity is not a coroutine function, it wraps the provided activity inside a function that can handle coroutine calling conventions. - Sets the 'activity' attribute of the behavior element to the processed activity function, ensuring that it has appropriate module and qualname attributes. - Identifies the context of the behavior by finding the ancestor element that is a subtype of core.Behavior. - Processes all owned elements of the behavior element. - Collects all events that are descendants of the behavior element and assigns them to the 'pool' attribute. - Sets the 'context' attribute of the behavior element to the identified context.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Behavior]</code> <p>The behavior element to preprocess.</p> required Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_behavior(self, element: type[\"core.Behavior\"]):\n    \"\"\"\n    Preprocesses the behavior element to set up appropriate activities and contexts.\n    This method takes a behavior element and does the following:\n    - Determines the type of concurrency (asynchronous or synchronous) and assigns the correct no-activity function if the activity is not provided.\n    - If concurrency is asynchronous and the activity is not a coroutine function, it wraps the provided activity inside a function that can handle coroutine calling conventions.\n    - Sets the 'activity' attribute of the behavior element to the processed activity function, ensuring that it has appropriate module and qualname attributes.\n    - Identifies the context of the behavior by finding the ancestor element that is a subtype of core.Behavior.\n    - Processes all owned elements of the behavior element.\n    - Collects all events that are descendants of the behavior element and assigns them to the 'pool' attribute.\n    - Sets the 'context' attribute of the behavior element to the identified context.\n\n    Args:\n        element (type['core.Behavior']):\n             The behavior element to preprocess.\n\n    \"\"\"\n    concurrency_kind = model.of(element).concurrency_kind\n    activity = element.activity\n    if activity is None:\n        if concurrency_kind == core.ConcurrencyKind.asynchronous:\n            activity = no_async_activity\n        else:\n            activity = no_activity\n    elif (\n        concurrency_kind == core.ConcurrencyKind.asynchronous\n        and not iscoroutinefunction(element.activity)\n    ):\n\n        def activity(self, event: \"core.Event\", _activity=element.activity):\n            \"\"\"\n            Performs an activity associated with a given event.\n            This function is designed to execute a specific activity that is tied to an event passed to the function. The activity to be executed is provided by the _activity argument, which defaults to `element.activity`. It calls this provided activity function, passing in the instance (`self`) and the event object.\n\n            Args:\n                event (core.Event):\n                     The event object that is associated with the activity to be performed.\n                _activity (callable, optional):\n                     A callable that represents the activity to be performed when the function is called. Defaults to `element.activity` if not provided.\n\n            Returns:\n\n            \"\"\"\n            return _activity(self, event)\n\n    activity.__module__ = model.of(element).__module__\n    activity.__qualname__ = f\"{model.qualified_name_of(element)}.activity\"\n    model.set_attribute(element, \"activity\", activity)\n    context = model.find_ancestor_of(\n        element,\n        lambda ancestor: model.element.is_subtype(ancestor, core.Behavior),\n    )\n    self.preprocess_owned_elements(element)\n\n    events = []\n    for descendant in model.descendants_of(element):\n        if model.element.is_subtype(descendant, core.Event):\n            events.append(descendant)\n    model.set_attribute(element, \"pool\", model.collection(*events))\n    model.set_attribute(\n        element,\n        \"context\",\n        context,\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_call_event","title":"<code>preprocess_call_event(element)</code>","text":"<p>Processes the provided CallEvent by setting the appropriate call attribute, depending on whether the operation is a coroutine function or not. This method decorates the given CallEvent's operation with a new call method. If the operation is an asynchronous coroutine function, it wraps the call in an 'async def' to handle the coroutine execution, sends an event to the model's interpreter, and then returns the result upon completion. If the operation is a regular function, it wraps the call in a 'def' and sets the result before returning. After processing, the CallEvent can be invoked as a callable which automatically handles the operation execution and result management.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[CallEvent]</code> <p>The CallEvent instance to be preprocessed.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the 'operation' attribute is not found in the CallEvent.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_call_event(self, element: type[\"core.CallEvent\"]):\n    \"\"\"\n    Processes the provided CallEvent by setting the appropriate __call__ attribute,\n    depending on whether the operation is a coroutine function or not.\n    This method decorates the given CallEvent's operation with a new __call__ method.\n    If the operation is an asynchronous coroutine function, it wraps the call in an\n    'async def' to handle the coroutine execution, sends an event to the model's interpreter,\n    and then returns the result upon completion. If the operation is a regular function,\n    it wraps the call in a 'def' and sets the result before returning.\n    After processing, the CallEvent can be invoked as a callable which automatically\n    handles the operation execution and result management.\n\n    Args:\n        element (type['core.CallEvent']):\n             The CallEvent instance to be preprocessed.\n\n    Raises:\n        AttributeError:\n             If the 'operation' attribute is not found in the CallEvent.\n\n    \"\"\"\n    if asyncio.iscoroutinefunction(element.operation):\n\n        async def __call__(self, *args, **kwargs):\n            \"\"\"\n            Performs an asynchronous operation and then sends its class instance to the model's interpreter.\n            This asynchronous method is a coroutine that must be awaited. It wraps an internal operation coroutine, invokes it with the supplied arguments, and then sends the current class instance to the associated interpreter, which is an attribute of the model object.\n\n            Args:\n                *args:\n                     Variable length argument list to be passed to the internal operation coroutine.\n                **kwargs:\n                     Arbitrary keyword arguments to be passed to the internal operation coroutine.\n\n            Returns:\n\n            Raises:\n                Exception:\n                     Propagates any exceptions raised by the internal operation coroutine or the model's interpreter.\n\n            \"\"\"\n            value = await self.operation(*args, **kwargs)\n            await self.model.interpreter.send(self.__class__())\n            return value\n\n    else:\n\n        def __call__(self, *args, **kwargs):\n            \"\"\"\n            Performs the operation bound to the callable object and stores the result.\n            This method allows the instance to be called as a function, executing the operation method\n            with the provided arguments and keyword arguments. After execution, the result is saved\n            using the results attribute's set_result method.\n\n            Args:\n                *args:\n                     Variable length argument list that will be passed to the operation method.\n                **kwargs:\n                     Arbitrary keyword arguments that will be passed to the operation method.\n\n            Returns:\n\n            \"\"\"\n            value = self.operation(*args, **kwargs)\n            self.results.set_result(value)\n            return value\n\n    setattr(element, \"__call__\", __call__)\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_change_event","title":"<code>preprocess_change_event(element)</code>","text":"<p>Preprocesses a ChangeEvent object by assigning an asyncio.Condition to its 'condition' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[ChangeEvent]</code> <p>The ChangeEvent instance that is to be preprocessed.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If 'condition' is not an attribute of the provided ChangeEvent instance.</p> <p>Note:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_change_event(self, element: type[core.ChangeEvent]):\n    \"\"\"\n    Preprocesses a ChangeEvent object by assigning an asyncio.Condition to its 'condition' attribute.\n\n    Args:\n        element (type[core.ChangeEvent]):\n             The ChangeEvent instance that is to be preprocessed.\n\n    Raises:\n        AttributeError:\n             If 'condition' is not an attribute of the provided ChangeEvent instance.\n\n    Note:\n\n    \"\"\"\n    element.condition = asyncio.Condition\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_composite_state","title":"<code>preprocess_composite_state(element)</code>","text":"<p>Processes a composite state to organize its sub-elements such as transitions, vertices, and regions. This method takes an element that is assumed to be a composite state, and iterates over its owned elements to categorize them into transitions, subvertices, and regions. If there are subvertices without an enclosing region, a new region is created to contain them along with any associated transitions. Existing regions within the composite state are preserved. The method then ensures that all transitions and subvertices are assigned to a region, either the new region or one of the existing ones, by updating their 'container' attributes. If an owned element corresponds to an attribute of the composite state, that association is maintained within the newly formed or existing region.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[CompositeState]</code> <p>The composite state to be preprocessed, expected to be an instance of 'core.CompositeState'.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>This method modifies the composite state element in-place and has no return value.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_composite_state(self, element: type[\"core.CompositeState\"]):\n    \"\"\"\n    Processes a composite state to organize its sub-elements such as transitions, vertices, and regions.\n    This method takes an element that is assumed to be a composite state, and iterates over its owned elements\n    to categorize them into transitions, subvertices, and regions. If there are subvertices without an enclosing region,\n    a new region is created to contain them along with any associated transitions. Existing regions within the composite state\n    are preserved. The method then ensures that all transitions and subvertices are assigned to a region, either the new region\n    or one of the existing ones, by updating their 'container' attributes. If an owned element corresponds to an attribute of\n    the composite state, that association is maintained within the newly formed or existing region.\n\n    Args:\n        element (type['core.CompositeState']):\n             The composite state to be preprocessed, expected to be an instance of 'core.CompositeState'.\n\n    Returns:\n        None:\n             This method modifies the composite state element in-place and has no return value.\n\n    \"\"\"\n    transitions = []\n    subvertex = []\n    regions = []\n    for owned_element in [\n        _owned_element\n        for _owned_element in model.owned_elements_of(element)\n        if not any(\n            model.is_descendant_of(region, _owned_element) for region in regions\n        )\n    ]:\n        if model.element.is_subtype(owned_element, core.Transition):\n            transitions.append(owned_element)\n        elif model.element.is_type(owned_element, model.Collection) and all(\n            model.element.is_subtype(_child, core.Transition)\n            for _child in owned_element\n        ):\n            transitions.extend(owned_element)\n        elif model.element.is_subtype(owned_element, core.Vertex):\n            subvertex.append(owned_element)\n        elif model.element.is_subtype(owned_element, core.Region):\n            regions.append(owned_element)\n    if subvertex:\n        new_region = model.element.new(\n            f\"region_{len(regions)}\",\n            bases=(core.Region,),\n        )\n        model.set_attribute(\n            element,\n            \"regions\",\n            model.collection(new_region, *regions),\n        )\n        for owned_element in subvertex + transitions:\n            if (\n                owner_of_owned_element := model.owner_of(owned_element)\n            ) is not None:\n                owned_element = model.remove_owned_element_from(\n                    owner_of_owned_element, owned_element\n                )\n                model.set_attribute(owned_element, \"container\", new_region)\n            if (\n                owned_element_name := model.name_of(owned_element)\n            ) in model.attributes_of(element):\n                model.set_attribute(new_region, owned_element_name, owned_element)\n            else:\n                model.add_owned_element_to(new_region, owned_element)\n    elif regions:\n        model.set_attribute(element, \"regions\", model.collection(*regions))\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_final_state","title":"<code>preprocess_final_state(element)</code>","text":"<p>Processes a final state element within the state machine before compilation. This method is responsible for applying preprocessing steps to the given final state element within the context of the state machine. It is designed to be overridden in subclasses for specific behaviors. The default implementation delegates the preprocessing to the <code>preprocess_vertex</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[FinalState]</code> <p>The final state element of the state machine to preprocess.</p> required <p>Returns:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_final_state(self, element: type[\"core.FinalState\"]):\n    \"\"\"\n    Processes a final state element within the state machine before compilation.\n    This method is responsible for applying preprocessing steps to the given final state element\n    within the context of the state machine. It is designed to be overridden in subclasses for\n    specific behaviors. The default implementation delegates the preprocessing to the\n    `preprocess_vertex` method.\n\n    Args:\n        element (type['core.FinalState']):\n             The final state element of the state machine to preprocess.\n\n    Returns:\n\n    \"\"\"\n    self.preprocess_vertex(element)\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_processor","title":"<code>preprocess_processor(element)</code>","text":"<p>Preprocesses an interpreter element to set up queue characteristics based on concurrency type. This method examines the concurrency_kind attribute of the provided interpreter element and sets an attribute to use an asynchronous queue if the concurrency kind matches asynchronous operation.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Interpreter]</code> <p>The interpreter element to preprocess, it must be an instance or subclass of model.Interpreter. The element is expected to have a model property with a concurrency_kind attribute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the 'model' property or 'concurrency_kind' attribute is missing from the element.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_processor(self, element: type[\"model.Interpreter\"]):\n    \"\"\"\n    Preprocesses an interpreter element to set up queue characteristics based on concurrency type.\n    This method examines the concurrency_kind attribute of the provided interpreter element and sets an attribute to use an asynchronous queue if the concurrency kind matches asynchronous operation.\n\n    Args:\n        element (type['model.Interpreter']):\n             The interpreter element to preprocess, it must be an instance or subclass of model.Interpreter. The element is expected to have a model property with a concurrency_kind attribute.\n\n    Raises:\n        AttributeError:\n             If the 'model' property or 'concurrency_kind' attribute is missing from the element.\n\n    \"\"\"\n    concurrency_kind = element.model.concurrency_kind\n    if concurrency_kind == core.ConcurrencyKind.asynchronous:\n        model.set_attribute(element, \"queue\", AsyncQueue)\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_region","title":"<code>preprocess_region(element)</code>","text":"<p>Processes the given UML region by setting attributes and filtering sub-elements. This method takes an element of type 'core.Region' and performs preprocessing to set attributes related to its subvertices, initial state, parent state, and parent state machine. It identifies all the subvertices of the region that are of type 'core.Vertex' and sets the 'subvertex' attribute. If the region does not have an explicit initial state, this method will attempt to find one based on the provided filtering criteria. Once an initial state is identified or confirmed, the method sets the 'initial' attribute of the element. The method also discerns and sets attributes for the region's parent state and state machine, ensuring that each is appropriately classified as either a 'core.State' or 'StateMachine'.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Region]</code> <p>The region of a state machine to preprocess.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attributes related to 'subvertex', 'initial', 'state', or 'state_machine' cannot be set due to incorrect typing or hierarchy of the provided element.</p> <p>Returns:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_region(self, element: type[\"core.Region\"]):\n    \"\"\"\n    Processes the given UML region by setting attributes and filtering sub-elements.\n    This method takes an element of type 'core.Region' and performs preprocessing to set attributes\n    related to its subvertices, initial state, parent state, and parent state machine. It identifies\n    all the subvertices of the region that are of type 'core.Vertex' and sets the 'subvertex' attribute.\n    If the region does not have an explicit initial state, this method will attempt to find one based on\n    the provided filtering criteria. Once an initial state is identified or confirmed, the method sets\n    the 'initial' attribute of the element.\n    The method also discerns and sets attributes for the region's parent state and state machine,\n    ensuring that each is appropriately classified as either a 'core.State' or 'StateMachine'.\n\n    Args:\n        element (type['core.Region']):\n             The region of a state machine to preprocess.\n\n    Raises:\n        AttributeError:\n             If the attributes related to 'subvertex', 'initial', 'state', or\n            'state_machine' cannot be set due to incorrect typing or hierarchy of the provided element.\n\n    Returns:\n\n    \"\"\"\n    from stateforward.core import StateMachine\n\n    def initial_filter(vertex):\n        \"\"\"\n        Determines whether a given vertex is a subtype of core.Initial.\n\n        Args:\n            vertex (Any):\n                 The vertex to be checked for being a subtype.\n\n        Returns:\n            bool:\n                 True if the vertex is a subtype of core.Initial, otherwise False.\n\n        \"\"\"\n        return model.element.is_subtype(vertex, core.Initial)\n\n    model.set_attribute(\n        element,\n        \"subvertex\",\n        model.collection(\n            *model.find_owned_elements_of(\n                element,\n                lambda owned_element: model.element.is_subtype(\n                    owned_element, core.Vertex\n                ),\n            )\n        ),\n    )\n    initial = getattr(element, \"initial\", None)\n\n    if initial is None:\n        initial = model.find_owned_element_of(element, initial_filter)\n        model.set_attribute(element, \"initial\", initial)\n    else:\n        self.log.debug(\n            f\"region {model.qualified_name_of(element)} has initial {model.qualified_name_of(initial)}\"\n        )\n    parent = model.owner_of(element)\n    if not model.element.is_subtype(parent, (StateMachine, core.State)):\n        parent = model.owner_of(parent)\n    model.set_attribute(\n        element,\n        \"state\",\n        parent if model.element.is_subtype(parent, core.State) else None,\n    )\n    model.set_attribute(\n        element,\n        \"state_machine\",\n        parent if model.element.is_subtype(parent, StateMachine) else None,\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_state","title":"<code>preprocess_state(element)</code>","text":"<p>Preprocesses a state in the state machine for further operations. This method takes a state as an argument and performs preprocessing step depending on whether it is a composite state or contains a submachine. If the state has a submachine, it gets logged. Additionally, it handles the preprocessing for the vertices of the state and ensures that 'entry', 'exit', and 'activity' behaviors are set on the state if they are not already defined.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>State</code> <p>The state to preprocess. This type should be derived from a class that has an attribute 'submachine', which indicates whether the state is a simple state or a composite state with its own submachine.</p> required <p>Returns:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_state(self, element: type[\"core.State\"]):\n    \"\"\"\n    Preprocesses a state in the state machine for further operations.\n    This method takes a state as an argument and performs preprocessing step depending on whether it is a composite state or contains a submachine. If the state has a submachine, it gets logged. Additionally, it handles the preprocessing for the vertices of the state and ensures that 'entry', 'exit', and 'activity' behaviors are set on the state if they are not already defined.\n\n    Args:\n        element (core.State):\n             The state to preprocess. This type should be derived from a class that has an attribute 'submachine', which indicates whether the state is a simple state or a composite state with its own submachine.\n\n    Returns:\n\n    \"\"\"\n    if element.submachine is None:\n        self.preprocess_composite_state(element)\n    else:\n        self.log.warning(\n            f\"preprocessing submachine {element} {getattr(element, 'entry', None)}\"\n        )\n        # for region in element.submachine.regions.core():\n        #     model.set_attribute(region, \"state\", element)\n        #     model.set_attribute(region, \"state_machine\", None)\n\n    self.preprocess_vertex(element)\n\n    for behavior in (\"entry\", \"exit\", \"activity\"):\n        if getattr(element, behavior) is None:\n            model.set_attribute(\n                element,\n                behavior,\n                model.element.new(behavior, bases=(core.Behavior,)),\n            )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_state_machine","title":"<code>preprocess_state_machine(element)</code>","text":"<p>Preprocesses a state machine behavior object prior to compilation. This method takes an element which is an instance of a specific state machine behavior and performs preprocessing steps on it. These steps involve preprocessing any composite states within the element and the behavior itself. This is essential to prepare the element for subsequent compilation or transformation processes. It involves logging the preprocessing step, ensuring internal consistency, setting up necessary ordering, and potentially more based on the implementation details. The function concludes by sorting a collection within the state machine. The sorting criteria is based on the type of event; it prioritizes non-completion events over completion events. This ordering may affect how events are processed or triggered within the state machine behavior at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Behavior</code> <p>The state machine behavior to preprocess. This is expected to be a subtype of 'core.Behavior'.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>This method performs operations on the 'element' object but does not return any value.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_state_machine(self, element: type[\"core.Behavior\"]):\n    \"\"\"\n    Preprocesses a state machine behavior object prior to compilation.\n    This method takes an element which is an instance of a specific state machine behavior and performs preprocessing steps on it. These steps involve preprocessing any composite states within the element and the behavior itself. This is essential to prepare the element for subsequent compilation or transformation processes. It involves logging the preprocessing step, ensuring internal consistency, setting up necessary ordering, and potentially more based on the implementation details.\n    The function concludes by sorting a collection within the state machine. The sorting criteria is based on the type of event; it prioritizes non-completion events over completion events. This ordering may affect how events are processed or triggered within the state machine behavior at runtime.\n\n    Args:\n        element (core.Behavior):\n             The state machine behavior to preprocess. This is expected to be a subtype of 'core.Behavior'.\n\n    Returns:\n        None:\n             This method performs operations on the 'element' object but does not return any value.\n\n    \"\"\"\n    self.log.debug(\n        f\"preprocessing state machine {model.qualified_name_of(element)}\"\n    )\n    if element.submachine_state is not None:\n        return self.preprocess_state(element.submachine_state)\n    self.preprocess_composite_state(element)\n    self.preprocess_behavior(element)\n    model.sort_collection(\n        element.pool,\n        lambda event: not model.element.is_subtype(event, core.CompletionEvent),\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_transition","title":"<code>preprocess_transition(element)</code>","text":"<p>Preprocesses the transition element to ensure it has all the necessary attributes set up correctly. This method processes a given transition element by setting up default values and verifying its correctness within a state machine. It checks if the transition source is defined, and if not, it attempts to derive the source based on hierarchy and ownership rules. It handles the completion events for states, initializes an empty effect if none is provided, and determines the transition kind based on the relationship between the source and target.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Transition]</code> <p>The transition element to preprocess.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the transition source is not found or if the transition has no container. This function does not return any value but modifies the transition element in place.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_transition(self, element: type[\"core.Transition\"]):\n    \"\"\"\n    Preprocesses the transition element to ensure it has all the necessary attributes set up correctly.\n    This method processes a given transition element by setting up default values and verifying its\n    correctness within a state machine. It checks if the transition source is defined, and if not,\n    it attempts to derive the source based on hierarchy and ownership rules. It handles the completion\n    events for states, initializes an empty effect if none is provided, and determines the transition\n    kind based on the relationship between the source and target.\n\n    Args:\n        element (type['core.Transition']):\n             The transition element to preprocess.\n\n    Raises:\n        ValueError:\n             If the transition source is not found or if the transition has no container.\n            This function does not return any value but modifies the transition element in place.\n\n    \"\"\"\n    if element.source is None:\n        owner = model.owner_of(element)\n        if model.element.is_subtype(owner, model.Collection):\n            owner = model.owner_of(owner)\n        if not model.element.is_subtype(owner, core.Vertex):\n            raise ValueError(\n                f\"transition {model.qualified_name_of(element)} has no source and is not owned by a state\"\n            )\n        # transition source always defaults to the parent\n        model.set_attribute(element, \"source\", owner)\n\n    # yield from self.wait_for_completion_of(element.source)\n    self.preprocess_element(element.source)\n    if element.events is None:\n        if model.element.is_subtype(element.source, core.State):\n            completion = element.source.completion\n            if completion is None:\n                completion = model.element.new(\n                    \"completion\",\n                    (core.CompletionEvent,),\n                )\n                model.set_attribute(element.source, \"completion\", completion)\n\n            model.set_attribute(\n                element,\n                \"events\",\n                model.collection(\n                    completion,\n                ),\n            )\n\n    if element.effect is None:\n        model.set_attribute(\n            element,\n            \"effect\",\n            model.element.new(\n                \"effect\",\n                (core.Behavior,),\n                activity=no_async_activity\n                if model.of(element).concurrency_kind\n                is core.ConcurrencyKind.asynchronous\n                else no_activity,\n            ),\n        )\n    container = element.source.container\n    if element.source == element.target:\n        element.kind = core.TransitionKind.self\n    elif element.target is None:\n        element.kind = core.TransitionKind.internal\n    elif model.is_descendant_of(element.source, element.target):\n        element.kind = core.TransitionKind.local\n    else:\n        self.preprocess_element(element.target)\n        element.kind = core.TransitionKind.external\n        container = least_common_ancestor(element.source, element.target)\n    if container is None:\n        raise ValueError(\n            f\"transition {model.qualified_name_of(element)} has no container\"\n        )\n    model.set_attribute(element, \"container\", container)\n    path = self.create_transition_path(element)\n    model.set_attribute(element, \"path\", path)\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_vertex","title":"<code>preprocess_vertex(element)</code>","text":"<p>Processes the given vertex by assigning it a container and categorizing its incoming and outgoing transitions.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>type[Vertex]</code> <p>The vertex element to preprocess. This vertex should be part of a state machine model. The function logs the process of finding the container for the given vertex. If no container is found, an error is logged. Furthermore, the function identifies and categorizes all outgoing and incoming transitions of the vertex. It checks for transitions that are either originating from or targeting the element. It updates the 'outgoing' and 'incoming' attributes of the element with the newly found transitions.</p> required Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def preprocess_vertex(self, element: type[\"core.Vertex\"]):\n    \"\"\"\n    Processes the given vertex by assigning it a container and categorizing its incoming and outgoing transitions.\n\n    Args:\n        element (type['core.Vertex']):\n             The vertex element to preprocess. This vertex should be part of a state machine model.\n            The function logs the process of finding the container for the given vertex. If no container is found, an error is logged.\n            Furthermore, the function identifies and categorizes all outgoing and incoming transitions of the vertex. It checks for transitions that are either originating from or targeting the element. It updates the 'outgoing' and 'incoming' attributes of the element with the newly found transitions.\n\n    \"\"\"\n    logger = create_logger(f\"preprocess_vertex({model.qualified_name_of(element)})\")\n    logger.debug(f\"finding container for {model.qualified_name_of(element)}\")\n    container = model.find_ancestor_of(\n        element,\n        lambda owned_element: model.element.is_subtype(owned_element, core.Region),\n    )\n\n    if container is None:\n        logger.error(f\"vertex {model.qualified_name_of(element)} has no container\")\n    logger.debug(f\"found container {model.qualified_name_of(container)}\")\n    model.set_attribute(element, \"container\", container)\n\n    outgoing = list(element.outgoing) if element.outgoing else []\n    incoming = list(element.incoming) if element.incoming else []\n    for transition in model.find_descendants_of(\n        model.of(element),\n        lambda owned_element: model.element.is_subtype(\n            owned_element, core.Transition\n        ),\n    ):\n        if (\n            transition.source or model.owner_of(transition)\n        ) == element and transition not in outgoing:\n            outgoing.append(transition)\n        elif transition.target == element and transition not in incoming:\n            incoming.append(transition)\n    model.set_attribute(element, \"outgoing\", model.collection(*outgoing))\n    model.set_attribute(element, \"incoming\", model.collection(*incoming))\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.least_common_ancestor","title":"<code>least_common_ancestor(node1, node2)</code>","text":"<p>Finds the least common ancestor between two vertices in a state machine graph. This function computes the least common ancestor (LCA) between two given vertices (node1 and node2). It operates under the assumption that each vertex has a container that can also be considered a vertex, and that the structure forms a hierarchical state machine. The LCA is defined as the lowest vertex at which the two input vertices are both descendants.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>type[Vertex]</code> <p>The first vertex for which to find the LCA.</p> required <code>node2</code> <code>type[Vertex]</code> <p>The second vertex for which to find the LCA.</p> required <p>Returns:</p> Type Description <p>type['core.Vertex']:  The least common ancestor of the two given vertices. Returns the container itself if one vertex is a descendant of another, or if the container of the first node doesn't have a state, indicating the top of the hierarchy.</p> <p>Raises:</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def least_common_ancestor(node1: type[\"core.Vertex\"], node2: type[\"core.Vertex\"]):\n    \"\"\"\n    Finds the least common ancestor between two vertices in a state machine graph.\n    This function computes the least common ancestor (LCA) between two given vertices (node1 and node2). It operates under the assumption that each vertex has a container that can also be considered a vertex, and that the structure forms a hierarchical state machine. The LCA is defined as the lowest vertex at which the two input vertices are both descendants.\n\n    Args:\n        node1 (type['core.Vertex']):\n             The first vertex for which to find the LCA.\n        node2 (type['core.Vertex']):\n             The second vertex for which to find the LCA.\n\n    Returns:\n        type['core.Vertex']:\n             The least common ancestor of the two given vertices. Returns the container itself if one vertex is a descendant of another, or if the container of the first node doesn't have a state, indicating the top of the hierarchy.\n\n    Raises:\n\n    \"\"\"\n    if model.is_descendant_of(node1.container, node2):\n        lca = node1.container\n    elif model.is_descendant_of(node2.container, node1):\n        lca = node2.container\n    else:\n        container = node1.container\n        if container.state is None:\n            return container\n        lca = least_common_ancestor(container.state, node2)\n    return lca\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.no_activity","title":"<code>no_activity(self, event)</code>","text":"<p>Handles a situation where there is no activity for a given event. This method is a placeholder intended to be overridden by subclasses to define specific behavior when an event has no activity. By default, it does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event object that has no activity.</p> required Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>def no_activity(self, event: \"core.Event\"):\n    \"\"\"\n    Handles a situation where there is no activity for a given event.\n    This method is a placeholder intended to be overridden by subclasses to define\n    specific behavior when an event has no activity. By default, it does nothing.\n\n    Args:\n        event (core.Event):\n             The event object that has no activity.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/API/StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.no_async_activity","title":"<code>no_async_activity(self, event)</code>  <code>async</code>","text":"<p>Coroutines defined with async def syntax are meant to be invoked in an asynchronous event loop. However, \"no_async_activity\" is designated as a stub with a pass statement, which means it currently does not perform any action when awaited on an event. The presence of an event parameter of hypothetical type 'core.Event' implies that it may potentially handle an event object from some core library or framework in the future.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>async def no_async_activity(self, event: \"core.Event\"):\n    \"\"\"\n    Coroutines defined with async def syntax are meant to be invoked in an asynchronous event loop. However, \"no_async_activity\" is designated as a stub with a pass statement, which means it currently does not perform any action when awaited on an event. The presence of an event parameter of hypothetical type 'core.Event' implies that it may potentially handle an event object from some core library or framework in the future.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/","title":"Async Behavior Interpreter","text":"<p>The <code>async_behavior_interpreter</code> module is designed to provide an asynchronous interpreter for state machines, specifically tailored for handling behaviors encoded into event-driven systems. It extends functionality from a base <code>AsyncInterpreter</code>, and is meant to work within a broader framework that manages state transitions and event processing called <code>stateforward</code>. This interpreter deals with asynchronous event queues and utilizes Python's <code>asyncio</code> library to manage concurrent execution of behaviors associated with state machine events.</p> <p>The primary class provided by this module is <code>AsyncBehaviorInterpreter</code>, which inherits from the <code>AsyncInterpreter</code> class and introduces additional mechanisms to manage deferred events within the state machine's execution flow. Events are accumulated from various sources such as the internal model pool, an asynchronous queue, and a deferred list, ensuring that all events are processed in an ordered and non-repetitive fashion.</p> <p>The <code>AsyncBehaviorInterpreter</code> class introduces two key asynchronous methods: <code>step</code> and <code>exec_event_processing</code>. The <code>step</code> method orchestrates the processing of events by maintaining a stack for event execution, processing events from the queue, checking for deferred events, and tirelessly fetching events until all have been handled. The <code>exec_event_processing</code> method, which is to be implemented, is responsible for handling the processing logic for each event encountered.</p> <p>The <code>AsyncBehaviorInterpreter</code> also provides a synchronous method <code>compile</code> meant to be overridden by subclasses as a classmethod. This method's role is typically to compile or prepare the state machine for execution, though it is abstract in the context of the provided schema.</p> <p>Additional utility methods such as <code>exec_behavior</code> facilitate the execution of behaviors associated with events, handling both synchronous and asynchronous operations seamlessly.</p> <p>The module is robust in its logging capabilities, ensuring that event processing is transparent and debuggable. A <code>Logger</code> interface is expected for this purpose, and a default logger is created if none is provided upon instantiation of the interpreter.</p> <p>The module leverages <code>asyncio</code> for handling concurrency and asynchronous operations, and incorporates custom abstractions such as <code>StateMachine</code>, <code>Clock</code>, <code>Queue</code>, and <code>Logger</code> provided by the <code>stateforward</code> framework. It is a key component within the framework for implementing asynchronous behavior-driven state machines.</p>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter.AsyncBehaviorInterpreter","title":"<code>AsyncBehaviorInterpreter</code>","text":"<p>             Bases: <code>AsyncInterpreter</code></p> <p>A class to interpret and manage asynchronous behaviors within an event-driven system. It utilizes a queue to process events and can defer processing of some events to a subsequent cycle.</p> <p>Attributes:</p> Name Type Description <code>deferred</code> <code>list[Event]</code> <p>A list to keep track of events that are deferred during processing.</p> <code>Inherits</code> <code>list[Event]</code> <code>AsyncInterpreter</code> <code>list[Event]</code> <p>Base class that provides the asynchronous event interpretation framework.</p> <code>Clock</code> <code>list[Event]</code> <p>(Inherited via AsyncInterpreter) Represents a time-keeping component.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Queue=None, log: Logger=None): Initializes the AsyncBehaviorInterpreter instance.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Queue</code> <p>An asyncio Queue instance used to manage the event queue. Defaults to None, where an asyncio.Queue() will be created.</p> <code>None</code> <code>log</code> <code>Logger</code> <p>Logger instance for logging/debugging. Defaults to None, where a new logger is created based on the model's qualified name.</p> <code>None</code> <code>step(self)</code> <p>Processes events in the queue, executing behaviors associated with each event and supporting deferral of events. Events are deduplicated and processed in order until the queue is emptied or all events are deferred. Results are collected and any completions are handled.</p> required <p>Returns:</p> Type Description <p>exec_behavior(self, behavior:  core.Behavior, event: typing.Optional[core.Event]): Executes the specified behavior with the associated event.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Behavior</code> <p>The behavior object to execute.</p> required <code>event</code> <code>Optional[Event]</code> <p>The event related to the behavior, if any.</p> required <p>Returns:</p> Type Description <p>exec_event_processing(self, event:  core.Event) -&gt; InterpreterStep: Method stub for processing an individual event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to be processed.</p> required <p>Returns:</p> Name Type Description <code>InterpreterStep</code> <p>The outcome of processing the event, indicating if the event is complete, pending, or deferred.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_behavior_interpreter.py</code> <pre><code>class AsyncBehaviorInterpreter(AsyncInterpreter, clock=Clock):\n    \"\"\"\n    A class to interpret and manage asynchronous behaviors within an event-driven system. It utilizes a queue to process events and can defer processing of some events to a subsequent cycle.\n\n    Attributes:\n        deferred (list[core.Event]):\n             A list to keep track of events that are deferred during processing.\n        Inherits:\n        AsyncInterpreter:\n             Base class that provides the asynchronous event interpretation framework.\n        Clock:\n             (Inherited via AsyncInterpreter) Represents a time-keeping component.\n\n    Methods:\n        __init__(self, queue:\n             Queue=None, log: Logger=None):\n            Initializes the AsyncBehaviorInterpreter instance.\n\n    Args:\n        queue (Queue, optional):\n             An asyncio Queue instance used to manage the event queue. Defaults to None, where an asyncio.Queue() will be created.\n        log (Logger, optional):\n             Logger instance for logging/debugging. Defaults to None, where a new logger is created based on the model's qualified name.\n        step(self):\n            Processes events in the queue, executing behaviors associated with each event and supporting deferral of events.\n            Events are deduplicated and processed in order until the queue is emptied or all events are deferred. Results are collected and any completions are handled.\n\n    Returns:\n        exec_behavior(self, behavior:\n             core.Behavior, event: typing.Optional[core.Event]):\n            Executes the specified behavior with the associated event.\n\n    Args:\n        behavior (core.Behavior):\n             The behavior object to execute.\n        event (typing.Optional[core.Event]):\n             The event related to the behavior, if any.\n\n    Returns:\n        exec_event_processing(self, event:\n             core.Event) -&gt; InterpreterStep:\n            Method stub for processing an individual event.\n\n    Args:\n        event (core.Event):\n             The event to be processed.\n\n    Returns:\n        InterpreterStep:\n             The outcome of processing the event, indicating if the event is complete, pending, or deferred.\n\n    \"\"\"\n\n    deferred: list[core.Event] = None\n\n    def __init__(self, queue: Queue = None, log: Logger = None):\n        \"\"\"\n        __init__(self, queue: Queue=None, log: Logger=None)\n        Initializes a new instance of the enclosing class with optional queue and log parameters.\n        This method sets up the class instance with a specified or default asynchronous queue and logging system. If no queue is provided, an asyncio Queue instance is created. If no logger is provided, a new logger is created based on the qualified name of the class instance via the create_logger function. The method also initializes a list to keep track of deferred tasks.\n\n        Args:\n            queue (Queue, optional):\n                 An instance of a queue for task management. Defaults to None, in which case a new asyncio Queue is created.\n            log (Logger, optional):\n                 A logging instance to log messages and errors. Defaults to None, in which case a new logger is created based on the qualified name of the class instance.\n\n        Attributes:\n            deferred (List):\n                 A list to store deferred tasks or activities that should be executed later.\n\n        \"\"\"\n        super().__init__(\n            queue=queue or asyncio.Queue(),\n            log=log or create_logger(model.qualified_name_of(self)),\n        )\n        self.deferred = []\n\n    async def step(self):\n        \"\"\"\n        Performs a single step in the event processing cycle of the current state machine asynchronously.\n        This async method processes events that are pending in the machine's queue, handling each event according to the state machine's logic. During the step, it ensures that each event is either processed completely or deferred for later processing. The state machine evaluates events from its internal queue, deferred events from the previous step, and new events that arrive during the cycle. Duplicate events are filtered out, ensuring that each unique event is processed only once per iteration. Processed events are logged for debugging purposes, and any events that are determined to be owned by no one are stacked for result assignment. If an event signals the completion of the processing cycle, the method will clear the list of processed events and break out of the loop for the current step.\n        The method uses an internal while loop that runs as long as there are events to process. Events that have already been processed are skipped in subsequent iterations. Once all events are processed, the loop will end, updating the deferred list with any events that were not processed and need to be revisited in the next step. The method concludes by setting the result for any futures in the stack that have been processed, thus completing the step.\n\n        Note that this method should be used within the context of an async function or coroutine due to its asynchronous nature.\n\n        Returns:\n            None:\n                 This method does not return a value, as its purpose is to update the state machine's\n                internal state based on event processing.\n\n        \"\"\"\n        processed = []\n        events = []\n        deferred = self.deferred\n        stack = []\n        while events := list(\n            dict.fromkeys(\n                (\n                    # include active events in the event pool\n                    *(event for event in self.model.pool if event in self.stack),\n                    # include deferred events from the previous iteration\n                    *deferred,\n                    # include events from the previous iteration\n                    *events,\n                    # include events from the queue\n                    *(self.queue.get_nowait() for _ in range(self.queue.qsize())),\n                )\n            )\n        ):\n            # reset deferred events\n            deferred = []\n            # if all events have been processed this iteration is complete\n            if not all(event in processed for event in events):\n                # clear the idle flag to prevent interruptions\n                while events:\n                    # pop the first event from the list\n                    event = events.pop(0)\n                    results = await self.exec_event_processing(event)\n                    self.log.debug(\n                        f\"Processed {model.qualified_name_of(event)} results {results} and {processed}\"\n                    )\n                    # add the event to the list of processed events\n                    if results is InterpreterStep.deferred:\n                        deferred.append(event)\n                    else:\n                        if model.owner_of(event) is None:\n                            stack.append((self.pop(event), results))\n                        if results is InterpreterStep.complete:\n                            processed = []\n                            break\n                    processed.append(event)\n                continue\n            break\n        self.deferred = deferred\n        for future, results in stack:\n            future.set_result(results)\n\n    async def exec_behavior(\n        self, behavior: core.Behavior, event: typing.Optional[core.Event]\n    ):\n        \"\"\"\n        Asynchronously executes a behavior in response to an event.\n        This function takes a behavior object and optionally an event object. It begins by logging the execution\n        of the behavior using its qualified name. Afterwards, it executes the activity associated with the behavior,\n        potentially waiting for the result if the activity is async (a future or coroutine). Finally, it returns the result of the behavior's activity.\n\n        Args:\n            behavior (core.Behavior):\n                 The behavior object to execute.\n            event (typing.Optional[core.Event]):\n                 The event that triggers the execution of the behavior, if any.\n\n        Returns:\n\n        \"\"\"\n        behavior_name = model.qualified_name_of(behavior)\n        self.log.debug(f\"Executing {behavior_name}\")\n        value = behavior.activity(event)\n        if asyncio.isfuture(value) or asyncio.iscoroutine(value):\n            value = await value\n        return value\n\n    async def exec_event_processing(self, event: core.Event) -&gt; InterpreterStep:\n        \"\"\"\n        Processes a given event asynchronously within the system's event processing pipeline.\n        This function serves as an asynchronous handler, tasked with interpreting and processing an event object. It forms an integral part of the event-driven architecture and is expected to be invoked with an event instance that it shall interpret, potentially yielding changes in system behavior or state as a result. Upon successful execution, it returns an instance of InterpreterStep, which encapsulates the outcome of processing the event.\n\n        Args:\n            event (core.Event):\n                 An event instance that contains data and information to be processed by the system.\n\n        Returns:\n            InterpreterStep:\n                 An object representing the result of the event processing. It includes information about what actions should be taken next within the system based on the interpretation of the event.\n\n        Raises:\n            Exception:\n                 If the event processing fails or encounters an unexpected error, an exception may be thrown indicating the nature of the failure.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter.AsyncBehaviorInterpreter.__init__","title":"<code>__init__(queue=None, log=None)</code>","text":"<p>This method sets up the class instance with a specified or default asynchronous queue and logging system. If no queue is provided, an asyncio Queue instance is created. If no logger is provided, a new logger is created based on the qualified name of the class instance via the create_logger function. The method also initializes a list to keep track of deferred tasks.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Queue</code> <p>An instance of a queue for task management. Defaults to None, in which case a new asyncio Queue is created.</p> <code>None</code> <code>log</code> <code>Logger</code> <p>A logging instance to log messages and errors. Defaults to None, in which case a new logger is created based on the qualified name of the class instance.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>deferred</code> <code>List</code> <p>A list to store deferred tasks or activities that should be executed later.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_behavior_interpreter.py</code> <pre><code>def __init__(self, queue: Queue = None, log: Logger = None):\n    \"\"\"\n    __init__(self, queue: Queue=None, log: Logger=None)\n    Initializes a new instance of the enclosing class with optional queue and log parameters.\n    This method sets up the class instance with a specified or default asynchronous queue and logging system. If no queue is provided, an asyncio Queue instance is created. If no logger is provided, a new logger is created based on the qualified name of the class instance via the create_logger function. The method also initializes a list to keep track of deferred tasks.\n\n    Args:\n        queue (Queue, optional):\n             An instance of a queue for task management. Defaults to None, in which case a new asyncio Queue is created.\n        log (Logger, optional):\n             A logging instance to log messages and errors. Defaults to None, in which case a new logger is created based on the qualified name of the class instance.\n\n    Attributes:\n        deferred (List):\n             A list to store deferred tasks or activities that should be executed later.\n\n    \"\"\"\n    super().__init__(\n        queue=queue or asyncio.Queue(),\n        log=log or create_logger(model.qualified_name_of(self)),\n    )\n    self.deferred = []\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter.AsyncBehaviorInterpreter.exec_behavior","title":"<code>exec_behavior(behavior, event)</code>  <code>async</code>","text":"<p>Asynchronously executes a behavior in response to an event. This function takes a behavior object and optionally an event object. It begins by logging the execution of the behavior using its qualified name. Afterwards, it executes the activity associated with the behavior, potentially waiting for the result if the activity is async (a future or coroutine). Finally, it returns the result of the behavior's activity.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Behavior</code> <p>The behavior object to execute.</p> required <code>event</code> <code>Optional[Event]</code> <p>The event that triggers the execution of the behavior, if any.</p> required <p>Returns:</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_behavior_interpreter.py</code> <pre><code>async def exec_behavior(\n    self, behavior: core.Behavior, event: typing.Optional[core.Event]\n):\n    \"\"\"\n    Asynchronously executes a behavior in response to an event.\n    This function takes a behavior object and optionally an event object. It begins by logging the execution\n    of the behavior using its qualified name. Afterwards, it executes the activity associated with the behavior,\n    potentially waiting for the result if the activity is async (a future or coroutine). Finally, it returns the result of the behavior's activity.\n\n    Args:\n        behavior (core.Behavior):\n             The behavior object to execute.\n        event (typing.Optional[core.Event]):\n             The event that triggers the execution of the behavior, if any.\n\n    Returns:\n\n    \"\"\"\n    behavior_name = model.qualified_name_of(behavior)\n    self.log.debug(f\"Executing {behavior_name}\")\n    value = behavior.activity(event)\n    if asyncio.isfuture(value) or asyncio.iscoroutine(value):\n        value = await value\n    return value\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter.AsyncBehaviorInterpreter.exec_event_processing","title":"<code>exec_event_processing(event)</code>  <code>async</code>","text":"<p>Processes a given event asynchronously within the system's event processing pipeline. This function serves as an asynchronous handler, tasked with interpreting and processing an event object. It forms an integral part of the event-driven architecture and is expected to be invoked with an event instance that it shall interpret, potentially yielding changes in system behavior or state as a result. Upon successful execution, it returns an instance of InterpreterStep, which encapsulates the outcome of processing the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An event instance that contains data and information to be processed by the system.</p> required <p>Returns:</p> Name Type Description <code>InterpreterStep</code> <code>InterpreterStep</code> <p>An object representing the result of the event processing. It includes information about what actions should be taken next within the system based on the interpretation of the event.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the event processing fails or encounters an unexpected error, an exception may be thrown indicating the nature of the failure.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_behavior_interpreter.py</code> <pre><code>async def exec_event_processing(self, event: core.Event) -&gt; InterpreterStep:\n    \"\"\"\n    Processes a given event asynchronously within the system's event processing pipeline.\n    This function serves as an asynchronous handler, tasked with interpreting and processing an event object. It forms an integral part of the event-driven architecture and is expected to be invoked with an event instance that it shall interpret, potentially yielding changes in system behavior or state as a result. Upon successful execution, it returns an instance of InterpreterStep, which encapsulates the outcome of processing the event.\n\n    Args:\n        event (core.Event):\n             An event instance that contains data and information to be processed by the system.\n\n    Returns:\n        InterpreterStep:\n             An object representing the result of the event processing. It includes information about what actions should be taken next within the system based on the interpretation of the event.\n\n    Raises:\n        Exception:\n             If the event processing fails or encounters an unexpected error, an exception may be thrown indicating the nature of the failure.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Behavior%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter.AsyncBehaviorInterpreter.step","title":"<code>step()</code>  <code>async</code>","text":"<p>Performs a single step in the event processing cycle of the current state machine asynchronously. This async method processes events that are pending in the machine's queue, handling each event according to the state machine's logic. During the step, it ensures that each event is either processed completely or deferred for later processing. The state machine evaluates events from its internal queue, deferred events from the previous step, and new events that arrive during the cycle. Duplicate events are filtered out, ensuring that each unique event is processed only once per iteration. Processed events are logged for debugging purposes, and any events that are determined to be owned by no one are stacked for result assignment. If an event signals the completion of the processing cycle, the method will clear the list of processed events and break out of the loop for the current step. The method uses an internal while loop that runs as long as there are events to process. Events that have already been processed are skipped in subsequent iterations. Once all events are processed, the loop will end, updating the deferred list with any events that were not processed and need to be revisited in the next step. The method concludes by setting the result for any futures in the stack that have been processed, thus completing the step.</p> <p>Note that this method should be used within the context of an async function or coroutine due to its asynchronous nature.</p> <p>Returns:</p> Name Type Description <code>None</code> <p>This method does not return a value, as its purpose is to update the state machine's internal state based on event processing.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_behavior_interpreter.py</code> <pre><code>async def step(self):\n    \"\"\"\n    Performs a single step in the event processing cycle of the current state machine asynchronously.\n    This async method processes events that are pending in the machine's queue, handling each event according to the state machine's logic. During the step, it ensures that each event is either processed completely or deferred for later processing. The state machine evaluates events from its internal queue, deferred events from the previous step, and new events that arrive during the cycle. Duplicate events are filtered out, ensuring that each unique event is processed only once per iteration. Processed events are logged for debugging purposes, and any events that are determined to be owned by no one are stacked for result assignment. If an event signals the completion of the processing cycle, the method will clear the list of processed events and break out of the loop for the current step.\n    The method uses an internal while loop that runs as long as there are events to process. Events that have already been processed are skipped in subsequent iterations. Once all events are processed, the loop will end, updating the deferred list with any events that were not processed and need to be revisited in the next step. The method concludes by setting the result for any futures in the stack that have been processed, thus completing the step.\n\n    Note that this method should be used within the context of an async function or coroutine due to its asynchronous nature.\n\n    Returns:\n        None:\n             This method does not return a value, as its purpose is to update the state machine's\n            internal state based on event processing.\n\n    \"\"\"\n    processed = []\n    events = []\n    deferred = self.deferred\n    stack = []\n    while events := list(\n        dict.fromkeys(\n            (\n                # include active events in the event pool\n                *(event for event in self.model.pool if event in self.stack),\n                # include deferred events from the previous iteration\n                *deferred,\n                # include events from the previous iteration\n                *events,\n                # include events from the queue\n                *(self.queue.get_nowait() for _ in range(self.queue.qsize())),\n            )\n        )\n    ):\n        # reset deferred events\n        deferred = []\n        # if all events have been processed this iteration is complete\n        if not all(event in processed for event in events):\n            # clear the idle flag to prevent interruptions\n            while events:\n                # pop the first event from the list\n                event = events.pop(0)\n                results = await self.exec_event_processing(event)\n                self.log.debug(\n                    f\"Processed {model.qualified_name_of(event)} results {results} and {processed}\"\n                )\n                # add the event to the list of processed events\n                if results is InterpreterStep.deferred:\n                    deferred.append(event)\n                else:\n                    if model.owner_of(event) is None:\n                        stack.append((self.pop(event), results))\n                    if results is InterpreterStep.complete:\n                        processed = []\n                        break\n                processed.append(event)\n            continue\n        break\n    self.deferred = deferred\n    for future, results in stack:\n        future.set_result(results)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/","title":"Async Interpreter","text":"<p>The <code>async_interpreter</code> module provides an asynchronous execution framework specifically designed for state-based systems, utilizing asynchronous I/O provided by Python's asyncio library. It is built upon the concept of interacting with different models, events, queues, and clocks within state-based systems. This module contains several key classes and components, each working together to execute sequences of operations in a non-blocking manner. Key components include <code>InterpreterStep</code>, <code>AsyncInterpreter</code>, and <code>Null</code>, as well as crucial controllable constructs such as <code>queue</code>, <code>clock</code>, <code>stack</code>, and <code>log</code>. The module defines the functioning of an asynchronous interpreter for state machine workflows, providing methods for event handling, concurrency management, and execution control. Notably, the <code>AsyncInterpreter</code> class inherits from <code>model.Element</code> and is parameterized to work with various model types, enriching its capability to interface with different state machine elements. This module is essential for scenarios where asynchronous event handling and state management are paramount, and it relies heavily on the asyncio event loop and future constructs for its operation.</p>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter","title":"<code>AsyncInterpreter</code>","text":"<p>             Bases: <code>Element</code>, <code>Generic[T]</code></p> <p>An asynchronous interpreter designed to operate with the provided state machine. This interpreter runs within the asyncio event loop and handles asynchronous task management and event processing for the state machine. It manages a queue of events and a stack to maintain the state of in-flight operations.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <code>Queue</code> <p>The queue for managing incoming events.</p> <code>clock</code> <code>Clock</code> <p>An object managing the clock speed for the interpreter's operations.</p> <code>stack</code> <code>dict[Element, Future]</code> <p>A dictionary mapping state machine elements to their associated futures/tasks.</p> <code>loop</code> <code>AbstractEventLoop</code> <p>The event loop in which this interpreter operates.</p> <code>log</code> <code>Logger</code> <p>Logger for the interpreter to output its activity.</p> <code>running</code> <code>Event</code> <p>An event signaling whether the interpreter is currently running.</p> <code>stepping</code> <code>Lock</code> <p>A lock to ensure step execution is done atomically.</p> <code>model</code> <code>T</code> <p>A generic type parameter representing the state machine model.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Queue, log: logging.Logger=None): Initializes the AsyncInterpreter with a queue and an optional logger.</p> <code>send</code> <p>model.Element): Sends an event to be processed by the state machine.</p> <code>start</code> <p>asyncio.AbstractEventLoop=None): Starts the interpreter within the given or default event loop.</p> <code>wait</code> <p>typing.Union[asyncio.Task, asyncio.Future],</p> <code>name</code> <p>str=None, return_when: str=asyncio.FIRST_COMPLETED) -&gt; asyncio.Task: Waits for the given tasks to complete, returning an asyncio.Task wrapping the wait operation.</p> <code>run</code> <p>The coroutine that runs the main event processing loop of the interpreter.</p> <code>step</code> <p>Processes the next set of tasks from the stack.</p> <code>is_active</code> <p>model.Element) -&gt; bool: Checks if the given elements are active within the current stack.</p> <code>push</code> <p>model.Element,</p> <code>future</code> <p>typing.Union[Future, asyncio.Task]=NULL): Pushes a new element and associated future/task onto the stack.</p> <code>pop</code> <p>model.Element, *, result: typing.Any=NULL): Pops an element and its associated task from the stack, handling its result.</p> <code>terminate</code> <p>Terminates the interpreter, cleaning up and cancelling tasks as necessary.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>class AsyncInterpreter(model.Element, typing.Generic[T]):\n    \"\"\"\n    An asynchronous interpreter designed to operate with the provided state machine.\n    This interpreter runs within the asyncio event loop and handles asynchronous task management\n    and event processing for the state machine. It manages a queue of events and a stack to\n    maintain the state of in-flight operations.\n\n    Attributes:\n        queue (Queue):\n             The queue for managing incoming events.\n        clock (Clock):\n             An object managing the clock speed for the interpreter's operations.\n        stack (dict[model.Element, asyncio.Future]):\n             A dictionary mapping state machine elements\n            to their associated futures/tasks.\n        loop (asyncio.AbstractEventLoop):\n             The event loop in which this interpreter operates.\n        log (logging.Logger):\n             Logger for the interpreter to output its activity.\n        running (asyncio.Event):\n             An event signaling whether the interpreter is currently running.\n        stepping (asyncio.Lock):\n             A lock to ensure step execution is done atomically.\n        model (T):\n             A generic type parameter representing the state machine model.\n\n    Methods:\n        __init__(self, queue:\n             Queue, log: logging.Logger=None):\n            Initializes the AsyncInterpreter with a queue and an optional logger.\n        send(self, event:\n             model.Element):\n            Sends an event to be processed by the state machine.\n        start(self, loop:\n             asyncio.AbstractEventLoop=None):\n            Starts the interpreter within the given or default event loop.\n        wait(self, *tasks:\n             typing.Union[asyncio.Task, asyncio.Future],\n        name:\n             str=None, return_when: str=asyncio.FIRST_COMPLETED) -&gt; asyncio.Task:\n            Waits for the given tasks to complete, returning an asyncio.Task wrapping the wait operation.\n        run(self) -&gt; None:\n            The coroutine that runs the main event processing loop of the interpreter.\n        step(self) -&gt; None:\n            Processes the next set of tasks from the stack.\n        is_active(self, *elements:\n             model.Element) -&gt; bool:\n            Checks if the given elements are active within the current stack.\n        push(self, element:\n             model.Element,\n        future:\n             typing.Union[Future, asyncio.Task]=NULL):\n            Pushes a new element and associated future/task onto the stack.\n        pop(self, element:\n             model.Element, *, result: typing.Any=NULL):\n            Pops an element and its associated task from the stack, handling its result.\n        terminate(self) -&gt; asyncio.Task:\n            Terminates the interpreter, cleaning up and cancelling tasks as necessary.\n\n    \"\"\"\n\n    queue: Queue = None\n    clock: Clock\n    stack: dict[model.Element, asyncio.Future] = None\n    loop: asyncio.AbstractEventLoop = None\n    log: logging.Logger = logging.getLogger(__name__)\n    running: asyncio.Event = None\n    stepping: asyncio.Lock = None\n\n    def __init__(self, queue: Queue, log: logging.Logger = None):\n        \"\"\"\n        Initializes the instance with a queue, an optional log, and internal attributes.\n        This method sets up the data structures and synchronization primitives required for the operation\n        of an instance. It assigns the queue to the instance, initializes a stack as a dictionary,\n        prepares an asyncio event to manage the running state, and sets up logging.\n\n        Args:\n            queue (Queue):\n                 A queue object used for inter-thread or inter-process communication.\n            log (logging.Logger, optional):\n                 A logger instance for logging messages. If not provided, it falls back to a default logger.\n\n        Attributes:\n            stack (dict):\n                 A dictionary to hold instance-specific data.\n            queue (Queue):\n                 The queue object passed during initialization.\n            running (asyncio.Event):\n                 An event to indicate whether the instance is running.\n            log (logging.Logger):\n                 A logger instance for outputting logs.\n\n        \"\"\"\n        self.stack = {}\n        self.queue = queue\n        self.running = asyncio.Event()\n        self.log = log or self.log\n\n    def send(self, event: model.Element):\n        \"\"\"\n        Sends an event to be processed by the state machine.\n        This method logs the receipt of the event, pushes it to the stack along with a new Future object, adds the event to a queue, and then awaits the processing of the event. The method returns the result of waiting for the future associated with the event to be completed.\n\n        Args:\n            event (model.Element):\n                 The event to be sent to the state machine for processing.\n\n        Returns:\n\n        \"\"\"\n        self.log.debug(f\"Received {model.qualified_name_of(event)}\")\n        # push the event onto the stack\n        future = self.push(event, asyncio.Future())\n        # add the event to the queue\n        self.queue.put_nowait(event)\n        return self.wait(\n            future,\n            self.stack.get(self),\n            name=f\"{model.qualified_name_of(event)}.sent\",\n        )\n\n    def start(\n        self,\n        loop: asyncio.AbstractEventLoop = None,\n    ):\n        \"\"\"\n        Starts an asynchronous task to run the state machine in an event loop.\n        This method initializes the event loop for the state machine, logs the state machine's qualified name,\n        and then creates and starts an asynchronous task for the state machine's `run` method.\n        It pushes the running task into a tracking structure for managing tasks and then waits for the\n        initialization to complete before proceeding.\n\n        Args:\n            loop (asyncio.AbstractEventLoop, optional):\n                 The event loop in which the state machine will\n                be run. If not provided, the current event loop will be used.\n\n        Returns:\n            A `wait` wrapper that is used to wait for two events:\n                 the task that runs the state machine\n                to complete, and a separate task that signals the state machine is running.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(self)\n        self.log.debug(f\"Starting {qualified_name}\")\n        loop = self.loop = loop or asyncio.get_event_loop()\n        task = loop.create_task(self.run(), name=qualified_name)\n        self.push(self, task)\n        return self.wait(task, self.loop.create_task(self.running.wait()))\n\n    def wait(\n        self,\n        *tasks: typing.Union[asyncio.Task, asyncio.Future],\n        name: str = None,\n        return_when: str = asyncio.FIRST_COMPLETED,\n    ) -&gt; asyncio.Task:\n        \"\"\"\n        Waits for the completion of one or more asyncio.Task or asyncio.Future objects.\n        This function is a coroutine that accepts any number of asyncio.Task or asyncio.Future\n        objects and an optional name for the underlying task that will wait for the\n        provided tasks or futures to complete. The function will schedule the execution\n        of these tasks or futures on the event loop, and wait until the conditions specified\n        by return_when are met. return_when can indicate waiting for the first task to\n        complete (asyncio.FIRST_COMPLETED), all tasks to complete (asyncio.ALL_COMPLETED),\n        or the first task to not be cancelled (asyncio.FIRST_EXCEPTION).\n        Upon completing the wait condition, the function will return the task that was created\n        to perform the wait operation. If any of the awaited tasks or futures raise an\n        exception during execution, the exception will be propagated.\n\n        Args:\n            *tasks (Union[asyncio.Task, asyncio.Future]):\n                 An arbitrary number of asyncio.Task\n                or asyncio.Future objects to be awaited.\n            name (str, optional):\n                 An optional name for the asyncio.Task that will be created\n                to perform the waiting operation. If not provided, a name is generated by\n                concatenating the names of the tasks with '_and_'.\n            return_when (str):\n                 The condition that determines when the wait operation\n                should return. Must be one of asyncio.FIRST_COMPLETED, asyncio.ALL_COMPLETED,\n                or asyncio.FIRST_EXCEPTION.\n\n        Returns:\n            asyncio.Task:\n                 The task that was created to wait for the provided tasks or futures.\n\n        \"\"\"\n\n        async def wait_for_tasks(_tasks=tasks, _return_when=return_when):\n            \"\"\"\n            Waits for the completion of tasks, possibly returning before all tasks are finished based on a condition.\n            This function asynchronously waits for the `_tasks` iterable of tasks to reach a completion state, which is determined by the `_return_when` condition. Once the condition is met, it retrieves one of the completed tasks from `done` set. If that task raised an exception, the exception is propagated by awaiting on the task object.\n\n            Args:\n                _tasks (Iterable[Task]):\n                     The collection of asyncio.Task objects to wait on. Defaults to the `tasks` variable in the current context.\n                _return_when (str):\n                     The condition upon which the function should return. This condition dictates whether the function waits for all tasks to complete, or returns earlier. Defaults to the `return_when` variable in the current context.\n\n            Returns:\n                Tuple[Set[Task], Set[Task]]:\n                     A tuple containing two sets. The first set contains all tasks that are done, and the second set contains all tasks that are pending.\n\n            Raises:\n                Any exception raised by a task:\n                     If any task among `_tasks` raises an exception, that exception is propagated.\n\n            \"\"\"\n            done, pending = await asyncio.wait(_tasks, return_when=_return_when)\n            task = done.pop()\n            if task.exception() is not None:\n                await task\n\n        return self.loop.create_task(\n            wait_for_tasks(),\n            name=name or \"_and_\".join(task.get_name() for task in tasks),\n        )\n\n    async def run(self) -&gt; None:\n        \"\"\"\n        Asynchronously runs the process associated with the class instance.\n        This coroutine continuously executes the 'step' method and awaits for a sleep interval based on the 'clock.multiplier'. It checks if the instance is active and if the 'running' flag is set before each iteration. If the 'running' flag is cancelled, it logs a debug message indicating the cancellation. If the 'running' flag is still set after an interruption, it ensures that the 'terminate' method is called.\n\n        Raises:\n            asyncio.CancelledError:\n                 If the coroutine is cancelled during its execution.\n\n        \"\"\"\n        self.log.debug(\n            f\"Running {model.qualified_name_of(self)} clock multiplier {self.clock.multiplier}\"\n        )\n        if self.is_active(self):\n            self.running.set()\n            try:\n                while self.running.is_set():\n                    await self.step()\n                    await asyncio.sleep(self.clock.multiplier)\n            except asyncio.CancelledError:\n                self.log.debug(f\"Cancelled {model.qualified_name_of(self)}\")\n            if self.running.is_set():\n                await self.terminate()\n\n    async def step(self) -&gt; None:\n        \"\"\"\n        Performs an asynchronous iteration step over a collection of futures stored in an instance's stack.\n        This method iterates through the values of the instance's stack attribute, which is expected to be a mapping of futures. It checks if any of the futures have raised an exception. If an exception is encountered in any future, it is immediately raised, halting the iteration.\n\n        Raises:\n            Exception:\n                 Any exception raised by a future in the stack.\n\n        Returns:\n\n        \"\"\"\n        for future in self.stack.values():\n            if exception := future.exception() is not None:\n                raise exception\n\n    def is_active(self, *elements: model.Element) -&gt; bool:\n        \"\"\"\n        Checks if all specified elements are active within the current context.\n        This method determines if all elements provided as arguments exist in the context's active stack.\n\n        Args:\n            *elements (model.Element):\n                 Variable number of elements to check for activeness within the stack.\n\n        Returns:\n            bool:\n                 True if all specified elements are active (i.e., they exist in the stack); False otherwise.\n\n        \"\"\"\n        return bool(self.stack) and all(element in self.stack for element in elements)\n\n    def push(\n        self, element: model.Element, future: typing.Union[Future, asyncio.Task] = NULL\n    ):\n        \"\"\"\n        Pushes an element onto the stack with an associated future or task, ensuring uniqueness.\n        This method adds an element to an internal stack, associating it with a future or an asyncio task, which may represent the element's processing state.\n        If the element already exists within the stack, a ValueError is thrown to avoid duplication.\n        The method ensures that each element can have only one corresponding future or task.\n\n        Args:\n            element (model.Element):\n                 The element to push onto the stack.\n            future (typing.Union[Future, asyncio.Task], optional):\n                 A future or task to associate with the element.\n                If not provided, the default value defined by NULL will be used.\n\n        Returns:\n            Future:\n                 The future or task associated with the element. This can be either the provided argument\n                or the one already associated with the element in case of previously existing entry.\n\n        Raises:\n            ValueError:\n                 If the element is already present in the stack.\n\n        \"\"\"\n        if element in self.stack:\n            raise ValueError(\n                f\"element {model.qualified_name_of(element)} already exists\"\n            )\n        future = self.stack.setdefault(element, future)\n        return typing.cast(Future, future)\n\n    def pop(self, element: model.Element, *, result: typing.Any = NULL):\n        \"\"\"\n        Pops an element from the stack and sets the result if specified.\n        This method retrieves the future associated with a stack element, removes the element from the stack,\n        and optionally sets a result on the future. If the future is already done and contains an exception,\n        the exception is raised. If `result` is provided and not NULL, it is used to set the future's result.\n\n        Args:\n            element (model.Element):\n                 The element to be popped from the stack.\n            result (typing.Any, optional):\n                 The result to set on the future if not NULL. Defaults to NULL.\n\n        Returns:\n            typing.cast(Future, future):\n                 The future associated with the popped element.\n\n        Raises:\n\n        \"\"\"\n        future = self.stack.pop(element, NULL)\n        if future.done():\n            if future.exception() is not None:\n                raise future.result()\n            elif result is not NULL:\n                future.set_result(result)\n        return typing.cast(Future, future)\n\n    def terminate(self) -&gt; asyncio.Task:\n        \"\"\"\n        Cancels the asynchronous task associated with the current instance if it is still running.\n        This method checks if the `running` attribute, presumably an instance of `threading.Event` or similar,\n        is set. If it is, it clears the `running` attribute to stop the task. It then retrieves the current\n        task using a `pop` method and inspects it. If the task is not yet completed, it will attempt\n        to cancel it by calling its `cancel` method. The task object, now potentially canceled, is\n        then recast as an `asyncio.Task` and returned.\n\n        Returns:\n            asyncio.Task:\n                 The task associated with this instance after attempting to cancel it if necessary.\n\n        \"\"\"\n        if self.running.is_set():\n            self.running.clear()\n        task = self.pop(self)\n        if not task.done():\n            task.cancel()\n        return typing.cast(asyncio.Task, task)\n\n    model: T = None\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.__init__","title":"<code>__init__(queue, log=None)</code>","text":"<p>of an instance. It assigns the queue to the instance, initializes a stack as a dictionary, prepares an asyncio event to manage the running state, and sets up logging.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Queue</code> <p>A queue object used for inter-thread or inter-process communication.</p> required <code>log</code> <code>Logger</code> <p>A logger instance for logging messages. If not provided, it falls back to a default logger.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>stack</code> <code>dict</code> <p>A dictionary to hold instance-specific data.</p> <code>queue</code> <code>Queue</code> <p>The queue object passed during initialization.</p> <code>running</code> <code>Event</code> <p>An event to indicate whether the instance is running.</p> <code>log</code> <code>Logger</code> <p>A logger instance for outputting logs.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def __init__(self, queue: Queue, log: logging.Logger = None):\n    \"\"\"\n    Initializes the instance with a queue, an optional log, and internal attributes.\n    This method sets up the data structures and synchronization primitives required for the operation\n    of an instance. It assigns the queue to the instance, initializes a stack as a dictionary,\n    prepares an asyncio event to manage the running state, and sets up logging.\n\n    Args:\n        queue (Queue):\n             A queue object used for inter-thread or inter-process communication.\n        log (logging.Logger, optional):\n             A logger instance for logging messages. If not provided, it falls back to a default logger.\n\n    Attributes:\n        stack (dict):\n             A dictionary to hold instance-specific data.\n        queue (Queue):\n             The queue object passed during initialization.\n        running (asyncio.Event):\n             An event to indicate whether the instance is running.\n        log (logging.Logger):\n             A logger instance for outputting logs.\n\n    \"\"\"\n    self.stack = {}\n    self.queue = queue\n    self.running = asyncio.Event()\n    self.log = log or self.log\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.is_active","title":"<code>is_active(*elements)</code>","text":"<p>Checks if all specified elements are active within the current context. This method determines if all elements provided as arguments exist in the context's active stack.</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>Variable number of elements to check for activeness within the stack.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all specified elements are active (i.e., they exist in the stack); False otherwise.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def is_active(self, *elements: model.Element) -&gt; bool:\n    \"\"\"\n    Checks if all specified elements are active within the current context.\n    This method determines if all elements provided as arguments exist in the context's active stack.\n\n    Args:\n        *elements (model.Element):\n             Variable number of elements to check for activeness within the stack.\n\n    Returns:\n        bool:\n             True if all specified elements are active (i.e., they exist in the stack); False otherwise.\n\n    \"\"\"\n    return bool(self.stack) and all(element in self.stack for element in elements)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.pop","title":"<code>pop(element, *, result=NULL)</code>","text":"<p>Pops an element from the stack and sets the result if specified. This method retrieves the future associated with a stack element, removes the element from the stack, and optionally sets a result on the future. If the future is already done and contains an exception, the exception is raised. If <code>result</code> is provided and not NULL, it is used to set the future's result.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>The element to be popped from the stack.</p> required <code>result</code> <code>Any</code> <p>The result to set on the future if not NULL. Defaults to NULL.</p> <code>NULL</code> <p>Returns:</p> Type Description <p>typing.cast(Future, future):  The future associated with the popped element.</p> <p>Raises:</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def pop(self, element: model.Element, *, result: typing.Any = NULL):\n    \"\"\"\n    Pops an element from the stack and sets the result if specified.\n    This method retrieves the future associated with a stack element, removes the element from the stack,\n    and optionally sets a result on the future. If the future is already done and contains an exception,\n    the exception is raised. If `result` is provided and not NULL, it is used to set the future's result.\n\n    Args:\n        element (model.Element):\n             The element to be popped from the stack.\n        result (typing.Any, optional):\n             The result to set on the future if not NULL. Defaults to NULL.\n\n    Returns:\n        typing.cast(Future, future):\n             The future associated with the popped element.\n\n    Raises:\n\n    \"\"\"\n    future = self.stack.pop(element, NULL)\n    if future.done():\n        if future.exception() is not None:\n            raise future.result()\n        elif result is not NULL:\n            future.set_result(result)\n    return typing.cast(Future, future)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.push","title":"<code>push(element, future=NULL)</code>","text":"<p>Pushes an element onto the stack with an associated future or task, ensuring uniqueness. This method adds an element to an internal stack, associating it with a future or an asyncio task, which may represent the element's processing state. If the element already exists within the stack, a ValueError is thrown to avoid duplication. The method ensures that each element can have only one corresponding future or task.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>The element to push onto the stack.</p> required <code>future</code> <code>Union[Future, Task]</code> <p>A future or task to associate with the element. If not provided, the default value defined by NULL will be used.</p> <code>NULL</code> <p>Returns:</p> Name Type Description <code>Future</code> <p>The future or task associated with the element. This can be either the provided argument or the one already associated with the element in case of previously existing entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element is already present in the stack.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def push(\n    self, element: model.Element, future: typing.Union[Future, asyncio.Task] = NULL\n):\n    \"\"\"\n    Pushes an element onto the stack with an associated future or task, ensuring uniqueness.\n    This method adds an element to an internal stack, associating it with a future or an asyncio task, which may represent the element's processing state.\n    If the element already exists within the stack, a ValueError is thrown to avoid duplication.\n    The method ensures that each element can have only one corresponding future or task.\n\n    Args:\n        element (model.Element):\n             The element to push onto the stack.\n        future (typing.Union[Future, asyncio.Task], optional):\n             A future or task to associate with the element.\n            If not provided, the default value defined by NULL will be used.\n\n    Returns:\n        Future:\n             The future or task associated with the element. This can be either the provided argument\n            or the one already associated with the element in case of previously existing entry.\n\n    Raises:\n        ValueError:\n             If the element is already present in the stack.\n\n    \"\"\"\n    if element in self.stack:\n        raise ValueError(\n            f\"element {model.qualified_name_of(element)} already exists\"\n        )\n    future = self.stack.setdefault(element, future)\n    return typing.cast(Future, future)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Asynchronously runs the process associated with the class instance. This coroutine continuously executes the 'step' method and awaits for a sleep interval based on the 'clock.multiplier'. It checks if the instance is active and if the 'running' flag is set before each iteration. If the 'running' flag is cancelled, it logs a debug message indicating the cancellation. If the 'running' flag is still set after an interruption, it ensures that the 'terminate' method is called.</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If the coroutine is cancelled during its execution.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"\n    Asynchronously runs the process associated with the class instance.\n    This coroutine continuously executes the 'step' method and awaits for a sleep interval based on the 'clock.multiplier'. It checks if the instance is active and if the 'running' flag is set before each iteration. If the 'running' flag is cancelled, it logs a debug message indicating the cancellation. If the 'running' flag is still set after an interruption, it ensures that the 'terminate' method is called.\n\n    Raises:\n        asyncio.CancelledError:\n             If the coroutine is cancelled during its execution.\n\n    \"\"\"\n    self.log.debug(\n        f\"Running {model.qualified_name_of(self)} clock multiplier {self.clock.multiplier}\"\n    )\n    if self.is_active(self):\n        self.running.set()\n        try:\n            while self.running.is_set():\n                await self.step()\n                await asyncio.sleep(self.clock.multiplier)\n        except asyncio.CancelledError:\n            self.log.debug(f\"Cancelled {model.qualified_name_of(self)}\")\n        if self.running.is_set():\n            await self.terminate()\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.send","title":"<code>send(event)</code>","text":"<p>Sends an event to be processed by the state machine. This method logs the receipt of the event, pushes it to the stack along with a new Future object, adds the event to a queue, and then awaits the processing of the event. The method returns the result of waiting for the future associated with the event to be completed.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Element</code> <p>The event to be sent to the state machine for processing.</p> required <p>Returns:</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def send(self, event: model.Element):\n    \"\"\"\n    Sends an event to be processed by the state machine.\n    This method logs the receipt of the event, pushes it to the stack along with a new Future object, adds the event to a queue, and then awaits the processing of the event. The method returns the result of waiting for the future associated with the event to be completed.\n\n    Args:\n        event (model.Element):\n             The event to be sent to the state machine for processing.\n\n    Returns:\n\n    \"\"\"\n    self.log.debug(f\"Received {model.qualified_name_of(event)}\")\n    # push the event onto the stack\n    future = self.push(event, asyncio.Future())\n    # add the event to the queue\n    self.queue.put_nowait(event)\n    return self.wait(\n        future,\n        self.stack.get(self),\n        name=f\"{model.qualified_name_of(event)}.sent\",\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.start","title":"<code>start(loop=None)</code>","text":"<p>Starts an asynchronous task to run the state machine in an event loop. This method initializes the event loop for the state machine, logs the state machine's qualified name, and then creates and starts an asynchronous task for the state machine's <code>run</code> method. It pushes the running task into a tracking structure for managing tasks and then waits for the initialization to complete before proceeding.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>AbstractEventLoop</code> <p>The event loop in which the state machine will be run. If not provided, the current event loop will be used.</p> <code>None</code> <p>Returns:</p> Type Description <p>A <code>wait</code> wrapper that is used to wait for two events:  the task that runs the state machine to complete, and a separate task that signals the state machine is running.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def start(\n    self,\n    loop: asyncio.AbstractEventLoop = None,\n):\n    \"\"\"\n    Starts an asynchronous task to run the state machine in an event loop.\n    This method initializes the event loop for the state machine, logs the state machine's qualified name,\n    and then creates and starts an asynchronous task for the state machine's `run` method.\n    It pushes the running task into a tracking structure for managing tasks and then waits for the\n    initialization to complete before proceeding.\n\n    Args:\n        loop (asyncio.AbstractEventLoop, optional):\n             The event loop in which the state machine will\n            be run. If not provided, the current event loop will be used.\n\n    Returns:\n        A `wait` wrapper that is used to wait for two events:\n             the task that runs the state machine\n            to complete, and a separate task that signals the state machine is running.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(self)\n    self.log.debug(f\"Starting {qualified_name}\")\n    loop = self.loop = loop or asyncio.get_event_loop()\n    task = loop.create_task(self.run(), name=qualified_name)\n    self.push(self, task)\n    return self.wait(task, self.loop.create_task(self.running.wait()))\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.step","title":"<code>step()</code>  <code>async</code>","text":"<p>Performs an asynchronous iteration step over a collection of futures stored in an instance's stack. This method iterates through the values of the instance's stack attribute, which is expected to be a mapping of futures. It checks if any of the futures have raised an exception. If an exception is encountered in any future, it is immediately raised, halting the iteration.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Any exception raised by a future in the stack.</p> <p>Returns:</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>async def step(self) -&gt; None:\n    \"\"\"\n    Performs an asynchronous iteration step over a collection of futures stored in an instance's stack.\n    This method iterates through the values of the instance's stack attribute, which is expected to be a mapping of futures. It checks if any of the futures have raised an exception. If an exception is encountered in any future, it is immediately raised, halting the iteration.\n\n    Raises:\n        Exception:\n             Any exception raised by a future in the stack.\n\n    Returns:\n\n    \"\"\"\n    for future in self.stack.values():\n        if exception := future.exception() is not None:\n            raise exception\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.terminate","title":"<code>terminate()</code>","text":"<p>Cancels the asynchronous task associated with the current instance if it is still running. This method checks if the <code>running</code> attribute, presumably an instance of <code>threading.Event</code> or similar, is set. If it is, it clears the <code>running</code> attribute to stop the task. It then retrieves the current task using a <code>pop</code> method and inspects it. If the task is not yet completed, it will attempt to cancel it by calling its <code>cancel</code> method. The task object, now potentially canceled, is then recast as an <code>asyncio.Task</code> and returned.</p> <p>Returns:</p> Type Description <code>Task</code> <p>asyncio.Task:  The task associated with this instance after attempting to cancel it if necessary.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def terminate(self) -&gt; asyncio.Task:\n    \"\"\"\n    Cancels the asynchronous task associated with the current instance if it is still running.\n    This method checks if the `running` attribute, presumably an instance of `threading.Event` or similar,\n    is set. If it is, it clears the `running` attribute to stop the task. It then retrieves the current\n    task using a `pop` method and inspects it. If the task is not yet completed, it will attempt\n    to cancel it by calling its `cancel` method. The task object, now potentially canceled, is\n    then recast as an `asyncio.Task` and returned.\n\n    Returns:\n        asyncio.Task:\n             The task associated with this instance after attempting to cancel it if necessary.\n\n    \"\"\"\n    if self.running.is_set():\n        self.running.clear()\n    task = self.pop(self)\n    if not task.done():\n        task.cancel()\n    return typing.cast(asyncio.Task, task)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.AsyncInterpreter.wait","title":"<code>wait(*tasks, name=None, return_when=asyncio.FIRST_COMPLETED)</code>","text":"<p>Waits for the completion of one or more asyncio.Task or asyncio.Future objects. This function is a coroutine that accepts any number of asyncio.Task or asyncio.Future objects and an optional name for the underlying task that will wait for the provided tasks or futures to complete. The function will schedule the execution of these tasks or futures on the event loop, and wait until the conditions specified by return_when are met. return_when can indicate waiting for the first task to complete (asyncio.FIRST_COMPLETED), all tasks to complete (asyncio.ALL_COMPLETED), or the first task to not be cancelled (asyncio.FIRST_EXCEPTION). Upon completing the wait condition, the function will return the task that was created to perform the wait operation. If any of the awaited tasks or futures raise an exception during execution, the exception will be propagated.</p> <p>Parameters:</p> Name Type Description Default <code>*tasks</code> <code>Union[Task, Future]</code> <p>An arbitrary number of asyncio.Task or asyncio.Future objects to be awaited.</p> <code>()</code> <code>name</code> <code>str</code> <p>An optional name for the asyncio.Task that will be created to perform the waiting operation. If not provided, a name is generated by concatenating the names of the tasks with 'and'.</p> <code>None</code> <code>return_when</code> <code>str</code> <p>The condition that determines when the wait operation should return. Must be one of asyncio.FIRST_COMPLETED, asyncio.ALL_COMPLETED, or asyncio.FIRST_EXCEPTION.</p> <code>FIRST_COMPLETED</code> <p>Returns:</p> Type Description <code>Task</code> <p>asyncio.Task:  The task that was created to wait for the provided tasks or futures.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def wait(\n    self,\n    *tasks: typing.Union[asyncio.Task, asyncio.Future],\n    name: str = None,\n    return_when: str = asyncio.FIRST_COMPLETED,\n) -&gt; asyncio.Task:\n    \"\"\"\n    Waits for the completion of one or more asyncio.Task or asyncio.Future objects.\n    This function is a coroutine that accepts any number of asyncio.Task or asyncio.Future\n    objects and an optional name for the underlying task that will wait for the\n    provided tasks or futures to complete. The function will schedule the execution\n    of these tasks or futures on the event loop, and wait until the conditions specified\n    by return_when are met. return_when can indicate waiting for the first task to\n    complete (asyncio.FIRST_COMPLETED), all tasks to complete (asyncio.ALL_COMPLETED),\n    or the first task to not be cancelled (asyncio.FIRST_EXCEPTION).\n    Upon completing the wait condition, the function will return the task that was created\n    to perform the wait operation. If any of the awaited tasks or futures raise an\n    exception during execution, the exception will be propagated.\n\n    Args:\n        *tasks (Union[asyncio.Task, asyncio.Future]):\n             An arbitrary number of asyncio.Task\n            or asyncio.Future objects to be awaited.\n        name (str, optional):\n             An optional name for the asyncio.Task that will be created\n            to perform the waiting operation. If not provided, a name is generated by\n            concatenating the names of the tasks with '_and_'.\n        return_when (str):\n             The condition that determines when the wait operation\n            should return. Must be one of asyncio.FIRST_COMPLETED, asyncio.ALL_COMPLETED,\n            or asyncio.FIRST_EXCEPTION.\n\n    Returns:\n        asyncio.Task:\n             The task that was created to wait for the provided tasks or futures.\n\n    \"\"\"\n\n    async def wait_for_tasks(_tasks=tasks, _return_when=return_when):\n        \"\"\"\n        Waits for the completion of tasks, possibly returning before all tasks are finished based on a condition.\n        This function asynchronously waits for the `_tasks` iterable of tasks to reach a completion state, which is determined by the `_return_when` condition. Once the condition is met, it retrieves one of the completed tasks from `done` set. If that task raised an exception, the exception is propagated by awaiting on the task object.\n\n        Args:\n            _tasks (Iterable[Task]):\n                 The collection of asyncio.Task objects to wait on. Defaults to the `tasks` variable in the current context.\n            _return_when (str):\n                 The condition upon which the function should return. This condition dictates whether the function waits for all tasks to complete, or returns earlier. Defaults to the `return_when` variable in the current context.\n\n        Returns:\n            Tuple[Set[Task], Set[Task]]:\n                 A tuple containing two sets. The first set contains all tasks that are done, and the second set contains all tasks that are pending.\n\n        Raises:\n            Any exception raised by a task:\n                 If any task among `_tasks` raises an exception, that exception is propagated.\n\n        \"\"\"\n        done, pending = await asyncio.wait(_tasks, return_when=_return_when)\n        task = done.pop()\n        if task.exception() is not None:\n            await task\n\n    return self.loop.create_task(\n        wait_for_tasks(),\n        name=name or \"_and_\".join(task.get_name() for task in tasks),\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.InterpreterStep","title":"<code>InterpreterStep</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration to represent the status of an interpretation step. This class is an enumeration (Enum) which categorizes the state of an interpretation step into one of three possible statuses:</p> <p>Attributes:</p> Name Type Description <code>complete</code> <code>str</code> <p>A status indicating that the interpretation step is complete and no further action is required.</p> <code>incomplete</code> <code>str</code> <p>A status indicating that the interpretation step is not fully resolved and may require additional information or action.</p> <code>deferred</code> <code>str</code> <p>A status that denotes a delay in the completion or evaluation of the interpretation step, potentially awaiting external input or another event.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>class InterpreterStep(Enum):\n    \"\"\"\n    An enumeration to represent the status of an interpretation step.\n    This class is an enumeration (Enum) which categorizes the state of an interpretation step into one of three possible statuses:\n\n    Attributes:\n        complete (str):\n             A status indicating that the interpretation step is complete and no further action is required.\n        incomplete (str):\n             A status indicating that the interpretation step is not fully resolved and may require additional information or action.\n        deferred (str):\n             A status that denotes a delay in the completion or evaluation of the interpretation step, potentially awaiting external input or another event.\n\n    \"\"\"\n\n    complete = \"complete\"\n    incomplete = \"incomplete\"\n    deferred = \"deferred\"\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.Null","title":"<code>Null</code>","text":"<p>             Bases: <code>Future</code></p> <p>A placeholder class designed to represent a Future with no value. This class is a subclass of <code>asyncio.Future</code> and is intended for scenarios where a Future-like object is required, but no actual result is expected. Upon initialization, it immediately sets its own result to <code>None</code>.</p> <p>Attributes:</p> Name Type Description <code>None</code> <p>This class does not have any public attributes besides those provided by its superclass.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructs a new <code>Null</code> object and sets its result to <code>None</code>. The <code>Null</code> class does not have its own methods, but inherits all methods from <code>asyncio.Future</code>.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>class Null(asyncio.Future):\n    \"\"\"\n    A placeholder class designed to represent a Future with no value.\n    This class is a subclass of `asyncio.Future` and is intended for scenarios where a Future-like object is required, but no actual result is expected. Upon initialization, it immediately sets its own result to `None`.\n\n    Attributes:\n        None:\n             This class does not have any public attributes besides those provided by its superclass.\n\n    Methods:\n        __init__:\n             Constructs a new `Null` object and sets its result to `None`.\n            The `Null` class does not have its own methods, but inherits all methods from `asyncio.Future`.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the class.\n        This constructor method sets up the initial state of the object by calling its superclass initializer and setting the result attribute to None.\n\n        \"\"\"\n        super().__init__()\n        self.set_result(None)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_interpreter.Null.__init__","title":"<code>__init__()</code>","text":"Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_interpreter.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of the class.\n    This constructor method sets up the initial state of the object by calling its superclass initializer and setting the result attribute to None.\n\n    \"\"\"\n    super().__init__()\n    self.set_result(None)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/","title":"Async StateMachine Interpreter","text":"<p>The <code>async_state_machine_interpreter</code> module provides an asynchronous interpreter for state machines, capable of handling concurrent state transitions and events within the framework provided by <code>stateforward</code>. It is designed to work with the state machines structured according to the core classes and interfaces from the <code>stateforward</code> library.</p> <p>The main class in this module is <code>AsyncStateMachineInterpreter</code>, which is an asynchronous interpreter that extends <code>AsyncBehaviorInterpreter</code>. It manages the asynchronous execution of states, transitions, regions, events, and the associated guard conditions and actions defined on a state machine.</p> <p>Key Functionalities: - Event Processing: Processes events concurrently across different regions of the state machine, handling transitions and state changes.</p> <ul> <li> <p>Activity Execution: Manages execution of entry, do, and exit activities associated with states.</p> </li> <li> <p>Transition Handling: Performs transition checks and guards evaluation, executes the effects of transitions, as well as entry and exit actions.</p> </li> <li> <p>State Management: Handles the entry and exit of states, including composite states, and manages sub-states and regions.</p> </li> <li> <p>Event Management: Handles the scheduling and management of time events, change events, and completion events.</p> </li> <li> <p>Termination: Provides a mechanism to terminate the state machine execution.</p> </li> </ul> <p>Architecture Summary: This module includes a collection of coroutine functions designed to asynchronously execute the different components of a state machine. It uses <code>asyncio</code> to manage asynchronous tasks and employs the <code>gather</code> function to handle concurrency. The interpreters maintain the current state of the machine and execute all states and transitions based on the events received. Error handling is implemented to ensure proper management of invalid transitions and other exceptions.</p>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter","title":"<code>AsyncStateMachineInterpreter</code>","text":"<p>             Bases: <code>AsyncBehaviorInterpreter[T]</code></p> <p>An asynchronous interpreter for state machine behavior execution. This interpreter asynchronously processes events and manages state transitions within a state machine based on a provided model. It handles concurrent entry and exit actions for regions, states, sub-states, and pseudostates, as well as the evaluation and execution of various event kinds such as time events and change events.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>StateMachine</code> <p>The state machine model to interpret.</p> <code>log</code> <code>Logger</code> <p>Logger for debug messages.</p> <code>stack</code> <code>dict</code> <p>A tracking structure for the active states and ongoing tasks in the state machine.</p> <p>Methods:</p> Name Description <code>exec_event_processing</code> <p>Processes an individual event for all regions in the state machine.</p> <code>exec_region_processing</code> <p>Processes an event for a specific region within the state machine.</p> <code>exec_state_processing</code> <p>Processes an event for a specific state within the state machine.</p> <code>exec_vertex_processing</code> <p>Processes an event for a specific vertex within the state machine.</p> <code>exec_transition_processing</code> <p>Evaluates and, if conditions are met, executes a transition for an event.</p> <code>exec_constraint_evaluate</code> <p>Evaluates a guard constraint with respect to an event.</p> <code>exec_transition</code> <p>Executes the actions associated with taking a transition, including exit and entry actions where appropriate.</p> <code>exec_vertex_exit</code> <p>Manages the exit actions and clean-up upon leaving a vertex in the state machine.</p> <code>exec_vertex_entry</code> <p>Manages the entry actions and setup when entering a vertex in the state machine.</p> <code>exec_region_entry/exit</code> <p>Handles the entry/exit logic for a region within the state machine.</p> <code>exec_state_entry/exit</code> <p>Manages the entry and exit logic of a state, including executing any associated entry, exit, or activity actions.</p> <code>exec_state_machine_entry/exit</code> <p>Handles the logic for entering and leaving the entire state machine or a sub-state machine.</p> <code>exec_pseudostate_entry/exit</code> <p>Manages the logic for entering and exiting a pseudostate, based on the pseudostate kind.</p> <code>exec_event_entry</code> <p>Wraps the starting of the async event processing in a Task and logs entry.</p> <code>run</code> <p>Initiates the state machine execution by entering the state machine and processing steps.</p> <code>terminate</code> <p>Handles the orderly shutdown of the state machine, exiting all active regions and states. This interpreter extends AsyncBehaviorInterpreter, making it capable of dealing with the asynchronous nature of the systems modelled by the state machine.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>class AsyncStateMachineInterpreter(AsyncBehaviorInterpreter[T]):\n    \"\"\"\n    An asynchronous interpreter for state machine behavior execution.\n    This interpreter asynchronously processes events and manages state transitions within a state machine based on a provided model. It handles concurrent entry and exit actions for regions, states, sub-states, and pseudostates, as well as the evaluation and execution of various event kinds such as time events and change events.\n\n    Attributes:\n        model (StateMachine):\n             The state machine model to interpret.\n        log (Logger):\n             Logger for debug messages.\n        stack (dict):\n             A tracking structure for the active states and ongoing tasks in the state machine.\n\n    Methods:\n        exec_event_processing:\n             Processes an individual event for all regions in the state machine.\n        exec_region_processing:\n             Processes an event for a specific region within the state machine.\n        exec_state_processing:\n             Processes an event for a specific state within the state machine.\n        exec_vertex_processing:\n             Processes an event for a specific vertex within the state machine.\n        exec_transition_processing:\n             Evaluates and, if conditions are met, executes a transition for an event.\n        exec_constraint_evaluate:\n             Evaluates a guard constraint with respect to an event.\n        exec_transition:\n             Executes the actions associated with taking a transition, including exit and entry actions where appropriate.\n        exec_vertex_exit:\n             Manages the exit actions and clean-up upon leaving a vertex in the state machine.\n        exec_vertex_entry:\n             Manages the entry actions and setup when entering a vertex in the state machine.\n        exec_region_entry/exit:\n             Handles the entry/exit logic for a region within the state machine.\n        exec_state_entry/exit:\n             Manages the entry and exit logic of a state, including executing any associated entry, exit, or activity actions.\n        exec_state_machine_entry/exit:\n             Handles the logic for entering and leaving the entire state machine or a sub-state machine.\n        exec_pseudostate_entry/exit:\n             Manages the logic for entering and exiting a pseudostate, based on the pseudostate kind.\n        exec_event_entry:\n             Wraps the starting of the async event processing in a Task and logs entry.\n        run:\n             Initiates the state machine execution by entering the state machine and processing steps.\n        terminate:\n             Handles the orderly shutdown of the state machine, exiting all active regions and states.\n            This interpreter extends AsyncBehaviorInterpreter, making it capable of dealing with the asynchronous nature of the systems modelled by the state machine.\n\n    \"\"\"\n\n    async def exec_event_processing(self, event: core.elements.Event):\n        \"\"\"\n        Asynchronously processes an event across all regions within a model.\n        This method takes a single event and concurrently processes it through all regions defined in the model. It uses asyncio.gather to asynchronously execute region processing for each region. After all regions have processed the event, the method determines the overall processing result based on the outcomes of the regional processing. The method returns an instance of InterpreterStep to indicate whether event processing is complete, deferred, or incomplete.\n\n        Args:\n            event (core.elements.Event):\n                 The event to be processed by the state machine.\n\n        Returns:\n            (InterpreterStep):\n                 An enum value indicating the completion state of the event processing. It can either be InterpreterStep.complete if the processing is finished across all regions, InterpreterStep.deferred if at least one region deferred the event, or InterpreterStep.incomplete if all regions are incomplete in processing the event.\n\n        \"\"\"\n        results = await asyncio.gather(\n            *(\n                self.exec_region_processing(region, event)\n                for region in self.model.regions\n            )\n        )\n        if InterpreterStep.complete in results:\n            return InterpreterStep.complete\n        return (\n            InterpreterStep.deferred\n            if InterpreterStep.deferred in results\n            else InterpreterStep.incomplete\n        )\n\n    async def exec_region_processing(\n        self, region: core.elements.Region, event: core.elements.Event\n    ):\n        \"\"\"\n        Performs the execution processing of a given region within a state machine, handling an incoming event.\n        This asynchronous method checks if the region is currently active and proceeds to process the\n        specified event by executing its corresponding active state. It is part of the state machine's\n        execution logic which would typically be involved in the workflow of state transitions and event handling.\n\n        Args:\n            region (core.elements.Region):\n                 The region of the state machine to be processed.\n            event (core.elements.Event):\n                 The event to be handled within the region's active state.\n\n        Returns:\n            (InterpreterStep):\n                 An enumeration value representing the completion status of the region processing.\n                This could either be `InterpreterStep.incomplete` indicating that the processing is not yet complete,\n                due to either the region not being active or the absence of an active state within the region.\n\n        Raises:\n            TypeError:\n                 If the region or event parameters are not instances of their respective expected types.\n\n        \"\"\"\n        if not self.is_active(region):\n            return InterpreterStep.incomplete\n        active_state = next(\n            (state for state in region.subvertex if self.is_active(state)), None\n        )\n        if active_state is None:\n            return InterpreterStep.incomplete\n        return await self.exec_state_processing(active_state, event)\n\n    async def exec_state_processing(\n        self, state: core.elements.State, event: core.elements.Event\n    ):\n        \"\"\"\n        Performs processing on a state within the state machine given an event.\n        This function executes the processing logic associated with a given state. If the state is not active, it immediately returns an incomplete step indicator. Otherwise, it proceeds to check if the state has regions and processes them asynchronously, waiting for all to complete before continuing.\n        If all regions return an incomplete processing result, or there are no regions, it attempts to process the state itself as a vertex. Finally, it returns the result of the processing, whether that be the processing of the regions or the state as a vertex.\n\n        Args:\n            state (core.elements.State):\n                 The state that needs to be processed.\n            event (core.elements.Event):\n                 The event that may trigger state transitions or actions.\n\n        Returns:\n            (InterpreterStep):\n                 The result of the state processing, which can indicate whether the processing is complete, incomplete, or has resulted in a transition.\n\n        \"\"\"\n        if not self.is_active(state):\n            return InterpreterStep.incomplete\n        elif state.regions is not None:\n            result = next(\n                (\n                    result\n                    for result in (\n                        await asyncio.gather(\n                            *(\n                                self.exec_region_processing(region, event)\n                                for region in state.regions\n                            )\n                        )\n                    )\n                    if result is not InterpreterStep.incomplete\n                ),\n                InterpreterStep.incomplete,\n            )\n        else:\n            result = InterpreterStep.incomplete\n        if result is InterpreterStep.incomplete:\n            result = await self.exec_vertex_processing(state, event)\n        return result\n\n    async def exec_vertex_processing(self, vertex: core.Vertex, event: core.Event):\n        \"\"\"\n        Asynchronously processes a given vertex in the state machine with respect to an incoming event.\n        This method iteratively examines all outgoing transitions from the provided vertex. It attempts to process each transition with the given event by invoking the exec_transition_processing method. The processing of transitions continues until either the processing of a transition results in a 'complete' state or all transitions have been processed without reaching a 'complete' state.\n\n        Args:\n            vertex (core.Vertex):\n                 The vertex to process which contains the outgoing transitions.\n            event (core.Event):\n                 The event that triggered the processing of the vertex.\n\n        Returns:\n            (InterpreterStep):\n                 An enum value indicating whether the processing of the vertex resulted in a 'complete' or 'incomplete' state. 'complete' is returned if any of the transitions reached completion, otherwise 'incomplete' is returned if all transitions were processed and none was completed.\n\n        \"\"\"\n        for transition in vertex.outgoing:\n            if (\n                await self.exec_transition_processing(transition, event)\n                == InterpreterStep.complete\n            ):\n                return InterpreterStep.complete\n        return InterpreterStep.incomplete\n\n    async def exec_transition_processing(\n        self, transition: core.Transition, event: core.Event\n    ):\n        \"\"\"\n        Performs the processing of a given state transition based on an event.\n        This asynchronous method checks if the specified event matches one of the expected events for the transition, and whether the transition's guard condition (if any) is satisfied. If the conditions are met, the method executes the transition and indicates that the process is complete. If the conditions are not met, the processing is incomplete.\n\n        Args:\n            transition (core.Transition):\n                 The transition to be processed.\n            event (core.Event):\n                 The event that is triggering the transition.\n\n        Returns:\n            (InterpreterStep):\n                 An enum indicating whether the transition processing is 'complete' or 'incomplete'.\n\n        \"\"\"\n        if any(\n            isinstance(_event, (type(event), core.AnyEvent))\n            for _event in transition.events\n        ) and (\n            transition.guard is None\n            or await self.exec_constraint_evaluate(transition.guard, event)\n        ):\n            await self.exec_transition(transition, event)\n            return InterpreterStep.complete\n        return InterpreterStep.incomplete\n\n        # could possibly improve this with using state in reverse\n\n    async def exec_constraint_evaluate_condition(\n        self, constraint: core.Constraint, event: core.Event\n    ) -&gt; bool:\n        \"\"\"\n        Async method to evaluate a condition of a given constraint in the context of an event.\n        This function takes a constraint object and an event object. It executes the condition\n        associated with the constraint by passing the event to it. If the condition function\n        returns a Future or is a coroutine, the function awaits the result. Logging is performed\n        after the evaluation to indicate that the evaluation is completed, including the result of the evaluation.\n\n        Args:\n            constraint (core.Constraint):\n                 The constraint whose condition must be evaluated.\n            event (core.Event):\n                 The event which is passed to the constraint's condition for evaluation.\n\n        Returns:\n            (bool):\n                 The result of the constraint's condition evaluation.\n\n        \"\"\"\n        result = constraint.condition(event)\n        if asyncio.isfuture(result) or asyncio.iscoroutine(result):\n            result = await result\n        self.log.debug(\n            f\"done evaluating constraint {model.qualified_name_of(constraint)} results are {result}\"\n        )\n        return result\n\n    async def exec_constraint_evaluate(\n        self, constraint: core.Constraint, event: core.Event\n    ) -&gt; bool:\n        \"\"\"\n        Evaluates a given constraint in the context of a specific event asynchronously.\n        This function logs the evaluation process, indicates that it is evaluating a particular constraint for a specified event, and then proceeds to evaluate the condition associated with the constraint.\n\n        Args:\n            constraint (core.Constraint):\n                 The constraint object that needs to be evaluated.\n            event (core.Event):\n                 The event object that will be used in the context of the constraint evaluation.\n\n        Returns:\n            (bool):\n                 A boolean value indicating the result of the constraint evaluation.\n\n        \"\"\"\n        self.log.debug(\n            f\"evaluating constraint {model.qualified_name_of(constraint)} for event {model.qualified_name_of(event)}\"\n        )\n        return await self.exec_constraint_evaluate_condition(constraint, event)\n\n    async def exec_transition(\n        self, transition: core.Transition, event: core.Event = None\n    ):\n        \"\"\"\n        Performs the execution of a given transition within a state machine.\n        This coroutine executes the actions associated with leaving the current state vertices, executing transition's effect if any, and entering the target state vertices. It logs the process of executing each transition for debugging purposes.\n\n        Args:\n            transition (core.Transition):\n                 The transition to be executed.\n            event (core.Event, optional):\n                 The event that may have triggered the transition. Defaults to None.\n\n        \"\"\"\n        self.log.debug(f\"executing transition {model.qualified_name_of(transition)}\")\n        for vertex in transition.path.leave:\n            await self.exec_vertex_exit(vertex, event)\n        if transition.effect is not None:\n            await self.exec_behavior(transition.effect, event)\n        for index, vertex in enumerate(transition.path.enter):\n            await self.exec_vertex_entry(\n                vertex,\n                event,\n                core.EntryKind.default\n                if index == transition.path.enter.length - 1\n                else core.EntryKind.explicit,\n            )\n\n    async def exec_vertex_exit(self, vertex: core.Vertex, event: core.Event):\n        \"\"\"\n        Asynchronously executes the exit behavior for a given vertex in a state machine.\n        This coroutine checks if the provided vertex is an instance of `core.State` or any other type. If the vertex is a `core.State`, it performs two main tasks, executed concurrently for efficiency: it calls `exec_transition_exit` for all outgoing transitions, followed by `exec_state_exit` for the state itself. For other types of vertices, identified here as `core.Pseudostate`, it calls `exec_pseudostate_exit`. After executing the appropriate exit behavior, it then removes the vertex from consideration within the current flow by calling the `pop` method.\n\n        Args:\n            vertex (core.Vertex):\n                 The vertex that is exiting and requires the execution of its exit behavior.\n            event (core.Event):\n                 The event that triggered the vertex's exit.\n\n        \"\"\"\n        if isinstance(vertex, core.State):\n            await asyncio.gather(\n                *(\n                    self.exec_transition_exit(transition)\n                    for transition in vertex.outgoing\n                )\n            )\n            await self.exec_state_exit(vertex, event)\n        else:\n            await self.exec_pseudostate_exit(\n                typing.cast(core.Pseudostate, vertex), event\n            )\n        self.pop(vertex)\n\n    async def exec_transition_exit(self, transition: core.Transition):\n        \"\"\"\n        Asynchronously executes the exit logic for a given state machine transition.\n        This method is responsible for handling the exit process when a state machine transition occurs. It iterates over both events associated with the transition and the transition itself, and for each element, it checks whether the element exists in the state machine's stack. If any element is found within the stack, the method will asynchronously pop the element from the stack.\n\n        Args:\n            transition (core.Transition):\n                 The transition object that is undergoing the exit process.\n\n        Raises:\n            Any exceptions that could occur while popping elements from the stack are implicitly raised and not caught within this function.\n\n        \"\"\"\n        for element in (*transition.events, transition.events, transition):\n            if element in self.stack:\n                self.pop(element)\n\n    async def exec_vertex_entry(\n        self, vertex: core.Vertex, event: core.Event, kind: core.EntryKind\n    ):\n        \"\"\"\n        Executes entry logic for a given vertex within a state machine.\n        This asynchronous method handles the entry logic for different vertex types present in a state machine. Depending on the type of the vertex (core.State, core.FinalState, or core.Pseudostate), it will perform the appropriate entry actions and execute any outgoing transitions related to that vertex. It also manages the vertex stack by pushing the current vertex into it before proceeding with the entry actions.\n\n        Args:\n            vertex (core.Vertex):\n                 The vertex at which to start executing the entry logic.\n            event (core.Event):\n                 The event instance that triggered the state transition.\n            kind (core.EntryKind):\n                 The kind of entry action to be performed. This helps determine how deep the entry logic should go; for instance, it could specify entering only the top state or recursive entry to all substates.\n\n        Returns:\n            (List[object]):\n                 A list of results from execution of entry logic and transitions originating from the vertex. The content of this list can vary depending on the type of vertex and number of transitions.\n\n        Raises:\n            TypeError:\n                 If the provided vertex is not castable to one of the expected vertex types (core.State, core.FinalState, or core.Pseudostate).\n\n        \"\"\"\n        self.push(vertex)\n        if isinstance(vertex, core.State):\n            await self.exec_state_entry(vertex, event, kind)\n            results = await asyncio.gather(\n                *(\n                    self.exec_transition_entry(transition)\n                    for transition in vertex.outgoing\n                )\n            )\n\n        elif isinstance(vertex, core.FinalState):\n            results = await self.exec_final_state_entry(vertex, event)\n        else:\n            results = await self.exec_pseudostate_entry(\n                typing.cast(core.Pseudostate, vertex), event\n            )\n        return results\n\n    async def exec_final_state_entry(\n        self, final_state: core.FinalState, event: core.Event\n    ):\n        \"\"\"\n        Asynchronously executes the entry actions for a final state of a state machine.\n        This method handles the actions that should be taken when entering the final state of\n        a state machine or a specific region within the state machine. It ensures that all exit\n        actions are completed for the regions that are being left behind. Additionally, if\n        the state machine associated with the final state's container has no active regions\n        left on the stack, it also terminates the super state (inferred to be a higher level state machine).\n\n        Args:\n            final_state (core.FinalState):\n                 The final state object representing the state machine's\n                final state or a specific region's final state to which the state machine is\n                transitioning.\n            event (core.Event):\n                 The event that triggered the transition to the final state.\n\n        \"\"\"\n        await self.exec_region_exit(final_state.container, event)\n\n        if final_state.container.state_machine is not None and all(\n            region not in self.stack\n            for region in final_state.container.state_machine.regions\n        ):\n            super().terminate()\n\n    async def exec_event_exit(self, event: core.Event):\n        \"\"\"\n        A coroutine that handles the exit event for the current state in the state machine.\n        This coroutine pops an event from the state context, effectively facilitating a transition\n        from the current state by handling the exit logic associated with that state.\n\n        Args:\n            event (core.Event):\n                 The event that triggers the exit operation from the current state.\n\n        \"\"\"\n        self.pop(event)\n\n    async def exec_change_event_wait(self, event: core.ChangeEvent):\n        \"\"\"\n        Performs an asynchronous wait for a change event to meet a certain condition before sending the event class associated with the event.\n        This function enters an infinite loop that continuously checks if the condition specified by the `expr` attribute of the `event` argument is met. If the condition evaluates to `True`, the function sends an instance of the event's class using the `send` coroutine and then breaks out of the loop. Otherwise, it awaits asynchronously for a very brief time (`0` seconds) before checking the condition again, allowing other asynchronous operations to proceed in the meantime.\n\n        Args:\n            event (core.ChangeEvent):\n                 The change event instance containing the condition expression to be evaluated and the event class to be sent once the condition is met.\n\n        Raises:\n            This function does not explicitly raise any exceptions, but exceptions may be raised by the `expr` evaluation or the `send` coroutine.\n\n        Returns:\n            (None):\n                 This function does not return a value.\n\n        \"\"\"\n        while True:\n            if event.expr(event):\n                await self.send(event.__class__())\n                break\n            await asyncio.sleep(0)\n\n    def exec_change_event_entry(self, event: core.ChangeEvent) -&gt; asyncio.Task:\n        \"\"\"\n        Schedules the execution of an `exec_change_event_wait` coroutine for a given change event.\n        This function creates an asyncio Task to asynchronously wait for a change event to be processed. It assigns a unique name to the task based on the qualified name of the event.\n\n        Args:\n            event (core.ChangeEvent):\n                 The change event to be processed asynchronously.\n\n        Returns:\n            (asyncio.Task):\n                 The asyncio Task object created for the change event.\n\n        \"\"\"\n        return asyncio.create_task(\n            self.exec_change_event_wait(event), name=model.qualified_name_of(event)\n        )\n\n    async def exec_time_event_wait(self, event: core.TimeEvent) -&gt; None:\n        \"\"\"\n        Async function to wait for a specific time event and then send the event.\n        This asynchronous method takes a time event object and performs a sleep operation for the duration specified by the `when` attribute of the time event. After the wait period is over, it sends the event.\n\n        Args:\n            event (core.TimeEvent):\n                 The time event object containing the `when` attribute, which specifies the duration to wait before sending the event.\n\n        Returns:\n            None\n\n        \"\"\"\n        await asyncio.sleep(event.when.total_seconds())\n        await self.send(event.__class__())\n\n    def exec_time_event_entry(self, event: core.TimeEvent):\n        \"\"\"\n        Schedules the execution of a time-based event.\n        This function initiates an asynchronous task to handle a time-event in the context of the current model's state machine.\n        It uses the asyncio library to create a new task which will await the execution of the 'exec_time_event_wait' coroutine.\n        The task is assigned a name that corresponds to the fully qualified name of the event, which is retrieved using the 'model.qualified_name_of' method.\n\n        Args:\n            event (core.TimeEvent):\n                 An instance of a time-based event that is to be handled by the state machine.\n\n        Returns:\n            (asyncio.Task):\n                 The newly created asyncio task object that is responsible for executing the time-event.\n\n        \"\"\"\n        return asyncio.create_task(\n            self.exec_time_event_wait(event), name=model.qualified_name_of(event)\n        )\n\n    async def exec_completion_event_wait(self, event: core.CompletionEvent):\n        \"\"\"\n        Awaits the completion of an event within a state machine, gathering futures related to activities in descendant states.\n        This asynchronous method is designed to handle the completion of a given event within the context of a state machine.\n        It first retrieves the state that owns the provided event and then awaits the future associated with the activity of that state. Once the awaited future completes, its value is stored within the event's value attribute. Subsequently, the method identifies all activities associated with descendant states of the source state and collects their associated futures. It awaits the completion of all these futures concurrently using `asyncio.gather`. Finally, the event is pushed to an internal stack for further processing.\n\n        Args:\n            event (core.CompletionEvent):\n                 The event for which the completion is being awaited. It is assumed to have originated from a state within the state machine.\n\n        \"\"\"\n        source: core.State = model.owner_of(event)\n        future = self.stack.get(source.activity)\n        event.value = await future\n        activities = tuple(\n            self.stack.get(typing.cast(core.State, state).activity)\n            for state in self.stack\n            if model.element.is_subtype(state, core.State)\n            and model.element.is_descendant_of(source, state)\n        )\n        await asyncio.gather(*activities)\n        self.push(event)\n\n    def exec_completion_event_entry(self, event: core.CompletionEvent) -&gt; asyncio.Task:\n        \"\"\"\n        Executes the entry logic for a completion event by creating an asyncio task to wait for the event completion.\n        This method is responsible for logging the entry of the completion event, resetting the event's value to None,\n        and spawning an asyncio task to await the event's completion. It returns the created task object.\n\n        Args:\n            event (core.CompletionEvent):\n                 The completion event for which to execute the entry logic.\n\n        Returns:\n            (asyncio.Task):\n                 The asyncio task created to wait for the event to complete.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(event)\n        self.log.debug(f\"entering completion event {qualified_name}\")\n        event.value = None\n        task = asyncio.create_task(\n            self.exec_completion_event_wait(event), name=qualified_name\n        )\n        return task\n\n    def exec_event_entry(self, event: core.Event) -&gt; typing.Optional[asyncio.Task]:\n        \"\"\"\n        Executes the entry logic for a given event in the state machine.\n        This method dispatches the execution based on the type of event received. Depending on the type of the event,\n        different execution paths are taken:\n        - `core.TimeEvent`: Executes the logic specific for time-triggered events.\n        - `core.CompletionEvent`: Executes the logic specific for completion-triggered events.\n        - `core.ChangeEvent`: Executes the logic specific for change-triggered events.\n\n        Args:\n            event (core.Event):\n                 The event that is currently being processed by the state machine.\n\n        Returns:\n            (typing.Optional[asyncio.Task]):\n                 An optional asyncio Task object if the event processing\n                results in an asynchronous task that needs to be awaited by the caller. None if the processing\n                of the event doesn't create an asynchronous task.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(event)\n        self.log.debug(f\"entering event {qualified_name}\")\n        if isinstance(event, core.TimeEvent):\n            return self.exec_time_event_entry(event)\n\n        elif isinstance(event, core.CompletionEvent):\n            return self.exec_completion_event_entry(event)\n\n        elif isinstance(event, core.ChangeEvent):\n            return self.exec_change_event_entry(event)\n\n    async def exec_transition_entry(self, transition: core.Transition) -&gt; None:\n        \"\"\"\n        Performs entry operations for a given state transition in an asynchronous state machine.\n        This method logs the entering of a transition, then pushes the transition onto the state stack. It\n        proceeds to gather tasks associated with the entry events of the transition, executes them asynchronously,\n        and waits for their completion before advancing.\n\n        Args:\n            transition (core.Transition):\n                 The transition object representing the state transition\n                that is being entered.\n\n        Returns:\n            (None):\n                 This method does not return a value and is intended to be used for its side effects.\n\n        Raises:\n            This method does not explicitly raise any exceptions, but exceptions could be raised by\n            the tasks executed during transition entry, which should be handled by the calling context.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(transition)\n        self.log.debug(f\"entering transition {qualified_name}\")\n        self.push(transition)\n        tasks = []\n        for event in transition.events:\n            task = self.exec_event_entry(event)\n            if task is not None:\n                tasks.append(task)\n        if tasks:\n            self.push(\n                transition.events,\n                self.wait(*tasks),\n            )\n\n    async def exec_state_entry(\n        self, state: core.State, event: core.Event, kind: core.EntryKind\n    ):\n        \"\"\"\n        Asynchronously executes the entry logic for the given state in a State Machine.\n        This coroutine manages the transition into a state by performing several actions:\n        - It logs the entry into the state.\n        - Executes the 'entry' behavior for the state, if it exists.\n        - Initiates and manages the state's 'activity', if it exists, by scheduling it to run asynchronously.\n        - Skips further actions if the state contains a submachine (a nested State Machine).\n        - Recursively invokes entry logic for each contained region within the state.\n\n        Args:\n            state (core.State):\n                 The state object that is being entered.\n            event (core.Event):\n                 The event object that triggered the state transition.\n            kind (core.EntryKind):\n                 The enumeration value representing the kind of entry action to be executed.\n\n        Returns:\n            None\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(state)\n        self.log.debug(f\"entering state {qualified_name}\")\n        if state.entry is not None:\n            await self.exec_behavior(state.entry, event)\n        if state.activity is not None:\n            self.push(\n                state.activity,\n                self.loop.create_task(self.exec_behavior(state.activity, event)),\n            )\n        if state.submachine is not None:\n            return\n        await asyncio.gather(\n            *(\n                self.exec_region_entry(region, event, kind)\n                for region in state.regions or []\n            )\n        )\n\n    async def exec_state_machine_entry(\n        self,\n        state_machine: \"core.StateMachine\",\n        event: typing.Optional[core.Event],\n        kind: core.EntryKind,\n    ):\n        \"\"\"\n        Asynchronously executes the entry behavior for a given state machine.\n        This method is responsible for logging the entry into the state machine and\n        then concurrently executing the entry behavior of all regions within the\n        state machine. It uses asynchronous gathering to ensure that all regions\n        start their entry behavior concurrently.\n\n        Args:\n            state_machine (core.StateMachine):\n                 The state machine instance for which entry behavior needs to be executed.\n            event (typing.Optional[core.Event]):\n                 The event that triggered the entry into the state machine, if any.\n            kind (core.EntryKind):\n                 The kind of entry to be performed for the state machine.\n\n        Returns:\n            A coroutine that, when awaited, results in the concurrent execution of entry\n            behavior for all regions within the state machine.\n\n        \"\"\"\n        self.log.debug(\n            f'entering state machine \"{model.qualified_name_of(state_machine)}\" with {state_machine.regions.length} regions'\n        )\n        return await asyncio.gather(\n            *(\n                self.exec_region_entry(region, event, kind)\n                for region in state_machine.regions\n            )\n        )\n\n    async def exec_region_entry(\n        self, region: core.Region, event: core.Event, kind: core.EntryKind\n    ):\n        \"\"\"\n        Executes the entry logic for a given state machine region.\n        This asynchronous method is responsible for entering a region of the state machine. Based on the\n        entry kind specified, it either proceeds with the default entry logic by initiating the region's\n        initial pseudostate or simply prepares for entry into the region without further action.\n\n        Args:\n            region (core.Region):\n                 The region of the state machine that is being entered.\n            event (core.Event):\n                 The event that triggered the entry into the region.\n            kind (core.EntryKind):\n                 The kind of entry into the region, which determines the behavior\n                on region entry. A 'default' kind leads to executing the initial pseudostate, while other kinds may\n                alter this behavior.\n\n        Returns:\n            (tuple):\n                 A tuple representing the states that have been entered as a result of the entry\n                process. For 'default' kind with an initial pseudostate, it's the result of the pseudostate entry;\n                otherwise, it's an empty tuple.\n\n        Raises:\n            Any exceptions raised by the `exec_pseudostate_entry` if 'default' kind entry is being processed\n            and the region has an initial pseudostate.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(region)\n        self.log.debug(f\"entering region {qualified_name}\")\n        states = ()\n        if kind == core.EntryKind.default:\n            if region.initial is None:\n                return states\n            self.push(region)\n            return await self.exec_pseudostate_entry(region.initial, event)\n        self.push(region)\n        return states\n\n    async def exec_region_exit(self, region: core.Region, event: core.Event):\n        \"\"\"\n        Asynchronously exits a region within a state machine.\n        This method handles the process of exiting a region by first determining the region's qualified name and logging the exit action. It then identifies the active vertex (state) of the region currently on the stack, if any. If an active vertex exists, the method ensures its proper exit sequence is executed. Finally, the region is popped from the internal state stack.\n        This method is an asynchronous coroutine and should be awaited.\n\n        Args:\n            region (core.Region):\n                 The region to exit from within the state machine.\n            event (core.Event):\n                 The event instance that triggered the exit.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(region)\n        self.log.debug(f'leaving region \"{qualified_name}\"')\n        active_vertex = next(\n            (vertex for vertex in region.subvertex if vertex in self.stack),\n            None,\n        )\n        if active_vertex is not None:\n            await self.exec_vertex_exit(active_vertex, event)\n        self.pop(region)\n\n    async def exec_pseudostate_exit(\n        self, psuedostate: core.Pseudostate, event: core.Event\n    ):\n        \"\"\"\n        Async function to execute the exit process of a given pseudostate in response to an event.\n        This function is designed to handle the exiting of a pseudostate, which is typically\n        a state in a state machine that does not correspond to a condition or action in the\n        traditional sense, but instead is used to represent an abstract state or a state that\n        serves as a transition to other states. The function takes as input the pseudostate\n        to be exited and the event that triggered the exit process.\n\n        Args:\n            psuedostate (core.Pseudostate):\n                 The pseudostate object to be exited.\n            event (core.Event):\n                 The event object that has triggered the exit of the pseudostate.\n\n\n        \"\"\"\n        pass\n\n    async def exec_state_exit(self, state: core.State, event: core.Event):\n        \"\"\"\n        Performs the exit sequence for a given state in the context of a state machine.\n        This asynchronous method handles the exit behavior of a state before a transition to another state. It will go through any nested state machines or regions associated with the given state, triggering their own exit sequences. If the state has an associated activity, and it's still running, it will be canceled. Lastly, if the state has defined an exit behavior, it is executed.\n\n        Args:\n            state (core.State):\n                 The state from which to exit.\n            event (core.Event):\n                 The event that triggered the state exit, if any.\n\n        \"\"\"\n        qualified_name = model.qualified_name_of(state)\n        if state.submachine is not None:\n            await self.exec_state_machine_exit(state.submachine, event)\n        else:\n            await asyncio.gather(\n                *(\n                    self.exec_region_exit(region, event)\n                    for region in state.regions or []\n                )\n            )\n        if state.activity is not None:\n            activity = self.pop(state.activity)\n            if not activity.done():\n                activity.cancel()\n        if state.exit is not None:\n            await self.exec_behavior(state.exit, event)\n        self.log.debug(f'leaving state \"{qualified_name}\"')\n\n    async def exec_state_machine_exit(\n        self,\n        state_machine: \"core.StateMachine\",\n        event: typing.Optional[core.Event],\n    ):\n        \"\"\"\n        Asynchronously leaves the state machine and executes the cleanup for each region within it.\n        This method is responsible for triggering the exit process from a given state machine and ensuring\n        that each of the regions within the state machine has its exit process executed. It logs the\n        activity and utilizes asynchronous gathering to handle the exiting of multiple regions concurrently.\n\n        Args:\n            state_machine (core.StateMachine):\n                 The state machine instance that is being exited.\n            event (typing.Optional[core.Event]):\n                 An optional event that might have triggered the state machine exit.\n                This parameter may be None, indicating that no specific event is associated with the exit action.\n\n        \"\"\"\n        self.log.debug(\n            f'leaving state machine \"{model.qualified_name_of(state_machine)}\"'\n        )\n        await asyncio.gather(\n            *(self.exec_region_exit(region, event) for region in state_machine.regions)\n        )\n\n    async def exec_pseudostate_entry(\n        self, pseudostate: core.Pseudostate, event: core.Event\n    ):\n        \"\"\"\n        Executes the entry behavior of a pseudostate based on its kind.\n        This asynchronous method processes the entry of a pseudostate and performs\n        actions based on its type (e.g., initial, choice, join, fork). It logs the entry,\n        determines the proper transition(s) based on the pseudostate kind and the given\n        event, and asynchronously executes the appropriate transition(s).\n\n        Args:\n            pseudostate (core.Pseudostate):\n                 The pseudostate that is being entered.\n            event (core.Event):\n                 The event that triggered the entry into the pseudostate.\n\n        Raises:\n            Exception:\n                 If the pseudostate is of kind 'choice' and no valid transition can be\n                determined (i.e., no transition guard is satisfied), an Exception is\n                raised indicating a model error.\n\n        Returns:\n            An awaitable object that, when awaited, yields the result of the executed\n            transition(s). Depending on the pseudostate kind, this could be the result from\n            a single transition or a collection of results from multiple transitions (in\n            the case of a 'fork' pseudostate).\n\n        \"\"\"\n        self.log.debug(\n            f\"entering {pseudostate.kind.value} psuedostate {model.qualified_name_of(pseudostate)}\"\n        )\n        if pseudostate.kind == core.PseudostateKind.initial:\n            return await self.exec_transition(pseudostate.outgoing[0], event)\n        elif pseudostate.kind == core.PseudostateKind.choice:\n            for transition in pseudostate.outgoing:\n                if transition.guard is None or await self.exec_constraint_evaluate(\n                    transition.guard, event\n                ):\n                    return await self.exec_transition(transition, event)\n            raise Exception(\"no valid transition this should never throw\")\n        elif pseudostate.kind == core.PseudostateKind.join:\n            if all(\n                transition.source not in self.stack\n                for transition in pseudostate.incoming\n            ):\n                return await self.exec_transition(pseudostate.outgoing[0], event)\n        elif pseudostate.kind == core.PseudostateKind.fork:\n            return await asyncio.gather(\n                *(\n                    self.exec_transition(transition, event)\n                    for transition in pseudostate.outgoing\n                )\n            )\n\n    async def run(self):\n        \"\"\"\n        Async function to start and manage the execution of the state machine.\n        This method initiates the run process of the state machine by logging its execution and handling\n        its entry operations. It proceeds to call the `step` method to perform the state machine's\n        transitions. If an `asyncio.CancelledError` occurs, it logs that the state machine is stopping.\n        In the absence of exceptions, it delegates to the superclass's `run` method to continue the\n        running process.\n\n        Raises:\n            asyncio.CancelledError:\n                 If the asynchronous task that called `run` is cancelled.\n\n        \"\"\"\n        self.log.debug(f'running state machine \"{model.qualified_name_of(self.model)}\"')\n        await self.exec_state_machine_entry(self.model, None, core.EntryKind.default)\n        try:\n            await self.step()\n        except asyncio.CancelledError:\n            self.log.debug(\n                f'stopping state machine \"{model.qualified_name_of(self.model)}\"'\n            )\n            return\n        return await super().run()\n\n    async def terminate(self):\n        \"\"\"\n        Asynchronously terminates the current object's operations by executing the state machine exit process and then calling the terminate method of the superclass.\n        This method performs two main actions in sequence. First, it calls 'exec_state_machine_exit' with the current model instance and 'None' as arguments to properly exit any state the object might be in. After that, it awaits the termination method of the superclass to ensure any additional superclass-specific termination procedures are carried out.\n\n        Args:\n            None\n\n        Returns:\n            (None):\n                 This method does not return any value. Its purpose is to perform an asynchronous cleanup.\n\n        Raises:\n            Any exception raised by 'exec_state_machine_exit' or the superclass termination method will propagate upwards, potentially to the invoker of this method.\n\n        \"\"\"\n        await self.exec_state_machine_exit(self.model, None)\n        await super().terminate()\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_change_event_entry","title":"<code>exec_change_event_entry(event)</code>","text":"<p>Schedules the execution of an <code>exec_change_event_wait</code> coroutine for a given change event. This function creates an asyncio Task to asynchronously wait for a change event to be processed. It assigns a unique name to the task based on the qualified name of the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ChangeEvent</code> <p>The change event to be processed asynchronously.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The asyncio Task object created for the change event.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>def exec_change_event_entry(self, event: core.ChangeEvent) -&gt; asyncio.Task:\n    \"\"\"\n    Schedules the execution of an `exec_change_event_wait` coroutine for a given change event.\n    This function creates an asyncio Task to asynchronously wait for a change event to be processed. It assigns a unique name to the task based on the qualified name of the event.\n\n    Args:\n        event (core.ChangeEvent):\n             The change event to be processed asynchronously.\n\n    Returns:\n        (asyncio.Task):\n             The asyncio Task object created for the change event.\n\n    \"\"\"\n    return asyncio.create_task(\n        self.exec_change_event_wait(event), name=model.qualified_name_of(event)\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_change_event_wait","title":"<code>exec_change_event_wait(event)</code>  <code>async</code>","text":"<p>Performs an asynchronous wait for a change event to meet a certain condition before sending the event class associated with the event. This function enters an infinite loop that continuously checks if the condition specified by the <code>expr</code> attribute of the <code>event</code> argument is met. If the condition evaluates to <code>True</code>, the function sends an instance of the event's class using the <code>send</code> coroutine and then breaks out of the loop. Otherwise, it awaits asynchronously for a very brief time (<code>0</code> seconds) before checking the condition again, allowing other asynchronous operations to proceed in the meantime.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ChangeEvent</code> <p>The change event instance containing the condition expression to be evaluated and the event class to be sent once the condition is met.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_change_event_wait(self, event: core.ChangeEvent):\n    \"\"\"\n    Performs an asynchronous wait for a change event to meet a certain condition before sending the event class associated with the event.\n    This function enters an infinite loop that continuously checks if the condition specified by the `expr` attribute of the `event` argument is met. If the condition evaluates to `True`, the function sends an instance of the event's class using the `send` coroutine and then breaks out of the loop. Otherwise, it awaits asynchronously for a very brief time (`0` seconds) before checking the condition again, allowing other asynchronous operations to proceed in the meantime.\n\n    Args:\n        event (core.ChangeEvent):\n             The change event instance containing the condition expression to be evaluated and the event class to be sent once the condition is met.\n\n    Raises:\n        This function does not explicitly raise any exceptions, but exceptions may be raised by the `expr` evaluation or the `send` coroutine.\n\n    Returns:\n        (None):\n             This function does not return a value.\n\n    \"\"\"\n    while True:\n        if event.expr(event):\n            await self.send(event.__class__())\n            break\n        await asyncio.sleep(0)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_completion_event_entry","title":"<code>exec_completion_event_entry(event)</code>","text":"<p>Executes the entry logic for a completion event by creating an asyncio task to wait for the event completion. This method is responsible for logging the entry of the completion event, resetting the event's value to None, and spawning an asyncio task to await the event's completion. It returns the created task object.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>CompletionEvent</code> <p>The completion event for which to execute the entry logic.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The asyncio task created to wait for the event to complete.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>def exec_completion_event_entry(self, event: core.CompletionEvent) -&gt; asyncio.Task:\n    \"\"\"\n    Executes the entry logic for a completion event by creating an asyncio task to wait for the event completion.\n    This method is responsible for logging the entry of the completion event, resetting the event's value to None,\n    and spawning an asyncio task to await the event's completion. It returns the created task object.\n\n    Args:\n        event (core.CompletionEvent):\n             The completion event for which to execute the entry logic.\n\n    Returns:\n        (asyncio.Task):\n             The asyncio task created to wait for the event to complete.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(event)\n    self.log.debug(f\"entering completion event {qualified_name}\")\n    event.value = None\n    task = asyncio.create_task(\n        self.exec_completion_event_wait(event), name=qualified_name\n    )\n    return task\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_completion_event_wait","title":"<code>exec_completion_event_wait(event)</code>  <code>async</code>","text":"<p>Awaits the completion of an event within a state machine, gathering futures related to activities in descendant states. This asynchronous method is designed to handle the completion of a given event within the context of a state machine. It first retrieves the state that owns the provided event and then awaits the future associated with the activity of that state. Once the awaited future completes, its value is stored within the event's value attribute. Subsequently, the method identifies all activities associated with descendant states of the source state and collects their associated futures. It awaits the completion of all these futures concurrently using <code>asyncio.gather</code>. Finally, the event is pushed to an internal stack for further processing.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>CompletionEvent</code> <p>The event for which the completion is being awaited. It is assumed to have originated from a state within the state machine.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_completion_event_wait(self, event: core.CompletionEvent):\n    \"\"\"\n    Awaits the completion of an event within a state machine, gathering futures related to activities in descendant states.\n    This asynchronous method is designed to handle the completion of a given event within the context of a state machine.\n    It first retrieves the state that owns the provided event and then awaits the future associated with the activity of that state. Once the awaited future completes, its value is stored within the event's value attribute. Subsequently, the method identifies all activities associated with descendant states of the source state and collects their associated futures. It awaits the completion of all these futures concurrently using `asyncio.gather`. Finally, the event is pushed to an internal stack for further processing.\n\n    Args:\n        event (core.CompletionEvent):\n             The event for which the completion is being awaited. It is assumed to have originated from a state within the state machine.\n\n    \"\"\"\n    source: core.State = model.owner_of(event)\n    future = self.stack.get(source.activity)\n    event.value = await future\n    activities = tuple(\n        self.stack.get(typing.cast(core.State, state).activity)\n        for state in self.stack\n        if model.element.is_subtype(state, core.State)\n        and model.element.is_descendant_of(source, state)\n    )\n    await asyncio.gather(*activities)\n    self.push(event)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_constraint_evaluate","title":"<code>exec_constraint_evaluate(constraint, event)</code>  <code>async</code>","text":"<p>Evaluates a given constraint in the context of a specific event asynchronously. This function logs the evaluation process, indicates that it is evaluating a particular constraint for a specified event, and then proceeds to evaluate the condition associated with the constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The constraint object that needs to be evaluated.</p> required <code>event</code> <code>Event</code> <p>The event object that will be used in the context of the constraint evaluation.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean value indicating the result of the constraint evaluation.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_constraint_evaluate(\n    self, constraint: core.Constraint, event: core.Event\n) -&gt; bool:\n    \"\"\"\n    Evaluates a given constraint in the context of a specific event asynchronously.\n    This function logs the evaluation process, indicates that it is evaluating a particular constraint for a specified event, and then proceeds to evaluate the condition associated with the constraint.\n\n    Args:\n        constraint (core.Constraint):\n             The constraint object that needs to be evaluated.\n        event (core.Event):\n             The event object that will be used in the context of the constraint evaluation.\n\n    Returns:\n        (bool):\n             A boolean value indicating the result of the constraint evaluation.\n\n    \"\"\"\n    self.log.debug(\n        f\"evaluating constraint {model.qualified_name_of(constraint)} for event {model.qualified_name_of(event)}\"\n    )\n    return await self.exec_constraint_evaluate_condition(constraint, event)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_constraint_evaluate_condition","title":"<code>exec_constraint_evaluate_condition(constraint, event)</code>  <code>async</code>","text":"<p>Async method to evaluate a condition of a given constraint in the context of an event. This function takes a constraint object and an event object. It executes the condition associated with the constraint by passing the event to it. If the condition function returns a Future or is a coroutine, the function awaits the result. Logging is performed after the evaluation to indicate that the evaluation is completed, including the result of the evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The constraint whose condition must be evaluated.</p> required <code>event</code> <code>Event</code> <p>The event which is passed to the constraint's condition for evaluation.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result of the constraint's condition evaluation.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_constraint_evaluate_condition(\n    self, constraint: core.Constraint, event: core.Event\n) -&gt; bool:\n    \"\"\"\n    Async method to evaluate a condition of a given constraint in the context of an event.\n    This function takes a constraint object and an event object. It executes the condition\n    associated with the constraint by passing the event to it. If the condition function\n    returns a Future or is a coroutine, the function awaits the result. Logging is performed\n    after the evaluation to indicate that the evaluation is completed, including the result of the evaluation.\n\n    Args:\n        constraint (core.Constraint):\n             The constraint whose condition must be evaluated.\n        event (core.Event):\n             The event which is passed to the constraint's condition for evaluation.\n\n    Returns:\n        (bool):\n             The result of the constraint's condition evaluation.\n\n    \"\"\"\n    result = constraint.condition(event)\n    if asyncio.isfuture(result) or asyncio.iscoroutine(result):\n        result = await result\n    self.log.debug(\n        f\"done evaluating constraint {model.qualified_name_of(constraint)} results are {result}\"\n    )\n    return result\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_event_entry","title":"<code>exec_event_entry(event)</code>","text":"<p>Executes the entry logic for a given event in the state machine. This method dispatches the execution based on the type of event received. Depending on the type of the event, different execution paths are taken: - <code>core.TimeEvent</code>: Executes the logic specific for time-triggered events. - <code>core.CompletionEvent</code>: Executes the logic specific for completion-triggered events. - <code>core.ChangeEvent</code>: Executes the logic specific for change-triggered events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that is currently being processed by the state machine.</p> required <p>Returns:</p> Type Description <code>Optional[Task]</code> <p>An optional asyncio Task object if the event processing results in an asynchronous task that needs to be awaited by the caller. None if the processing of the event doesn't create an asynchronous task.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>def exec_event_entry(self, event: core.Event) -&gt; typing.Optional[asyncio.Task]:\n    \"\"\"\n    Executes the entry logic for a given event in the state machine.\n    This method dispatches the execution based on the type of event received. Depending on the type of the event,\n    different execution paths are taken:\n    - `core.TimeEvent`: Executes the logic specific for time-triggered events.\n    - `core.CompletionEvent`: Executes the logic specific for completion-triggered events.\n    - `core.ChangeEvent`: Executes the logic specific for change-triggered events.\n\n    Args:\n        event (core.Event):\n             The event that is currently being processed by the state machine.\n\n    Returns:\n        (typing.Optional[asyncio.Task]):\n             An optional asyncio Task object if the event processing\n            results in an asynchronous task that needs to be awaited by the caller. None if the processing\n            of the event doesn't create an asynchronous task.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(event)\n    self.log.debug(f\"entering event {qualified_name}\")\n    if isinstance(event, core.TimeEvent):\n        return self.exec_time_event_entry(event)\n\n    elif isinstance(event, core.CompletionEvent):\n        return self.exec_completion_event_entry(event)\n\n    elif isinstance(event, core.ChangeEvent):\n        return self.exec_change_event_entry(event)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_event_exit","title":"<code>exec_event_exit(event)</code>  <code>async</code>","text":"<p>A coroutine that handles the exit event for the current state in the state machine. This coroutine pops an event from the state context, effectively facilitating a transition from the current state by handling the exit logic associated with that state.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that triggers the exit operation from the current state.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_event_exit(self, event: core.Event):\n    \"\"\"\n    A coroutine that handles the exit event for the current state in the state machine.\n    This coroutine pops an event from the state context, effectively facilitating a transition\n    from the current state by handling the exit logic associated with that state.\n\n    Args:\n        event (core.Event):\n             The event that triggers the exit operation from the current state.\n\n    \"\"\"\n    self.pop(event)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_event_processing","title":"<code>exec_event_processing(event)</code>  <code>async</code>","text":"<p>Asynchronously processes an event across all regions within a model. This method takes a single event and concurrently processes it through all regions defined in the model. It uses asyncio.gather to asynchronously execute region processing for each region. After all regions have processed the event, the method determines the overall processing result based on the outcomes of the regional processing. The method returns an instance of InterpreterStep to indicate whether event processing is complete, deferred, or incomplete.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to be processed by the state machine.</p> required <p>Returns:</p> Type Description <code>InterpreterStep</code> <p>An enum value indicating the completion state of the event processing. It can either be InterpreterStep.complete if the processing is finished across all regions, InterpreterStep.deferred if at least one region deferred the event, or InterpreterStep.incomplete if all regions are incomplete in processing the event.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_event_processing(self, event: core.elements.Event):\n    \"\"\"\n    Asynchronously processes an event across all regions within a model.\n    This method takes a single event and concurrently processes it through all regions defined in the model. It uses asyncio.gather to asynchronously execute region processing for each region. After all regions have processed the event, the method determines the overall processing result based on the outcomes of the regional processing. The method returns an instance of InterpreterStep to indicate whether event processing is complete, deferred, or incomplete.\n\n    Args:\n        event (core.elements.Event):\n             The event to be processed by the state machine.\n\n    Returns:\n        (InterpreterStep):\n             An enum value indicating the completion state of the event processing. It can either be InterpreterStep.complete if the processing is finished across all regions, InterpreterStep.deferred if at least one region deferred the event, or InterpreterStep.incomplete if all regions are incomplete in processing the event.\n\n    \"\"\"\n    results = await asyncio.gather(\n        *(\n            self.exec_region_processing(region, event)\n            for region in self.model.regions\n        )\n    )\n    if InterpreterStep.complete in results:\n        return InterpreterStep.complete\n    return (\n        InterpreterStep.deferred\n        if InterpreterStep.deferred in results\n        else InterpreterStep.incomplete\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_final_state_entry","title":"<code>exec_final_state_entry(final_state, event)</code>  <code>async</code>","text":"<p>Asynchronously executes the entry actions for a final state of a state machine. This method handles the actions that should be taken when entering the final state of a state machine or a specific region within the state machine. It ensures that all exit actions are completed for the regions that are being left behind. Additionally, if the state machine associated with the final state's container has no active regions left on the stack, it also terminates the super state (inferred to be a higher level state machine).</p> <p>Parameters:</p> Name Type Description Default <code>final_state</code> <code>FinalState</code> <p>The final state object representing the state machine's final state or a specific region's final state to which the state machine is transitioning.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the transition to the final state.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_final_state_entry(\n    self, final_state: core.FinalState, event: core.Event\n):\n    \"\"\"\n    Asynchronously executes the entry actions for a final state of a state machine.\n    This method handles the actions that should be taken when entering the final state of\n    a state machine or a specific region within the state machine. It ensures that all exit\n    actions are completed for the regions that are being left behind. Additionally, if\n    the state machine associated with the final state's container has no active regions\n    left on the stack, it also terminates the super state (inferred to be a higher level state machine).\n\n    Args:\n        final_state (core.FinalState):\n             The final state object representing the state machine's\n            final state or a specific region's final state to which the state machine is\n            transitioning.\n        event (core.Event):\n             The event that triggered the transition to the final state.\n\n    \"\"\"\n    await self.exec_region_exit(final_state.container, event)\n\n    if final_state.container.state_machine is not None and all(\n        region not in self.stack\n        for region in final_state.container.state_machine.regions\n    ):\n        super().terminate()\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_pseudostate_entry","title":"<code>exec_pseudostate_entry(pseudostate, event)</code>  <code>async</code>","text":"<p>Executes the entry behavior of a pseudostate based on its kind. This asynchronous method processes the entry of a pseudostate and performs actions based on its type (e.g., initial, choice, join, fork). It logs the entry, determines the proper transition(s) based on the pseudostate kind and the given event, and asynchronously executes the appropriate transition(s).</p> <p>Parameters:</p> Name Type Description Default <code>pseudostate</code> <code>Pseudostate</code> <p>The pseudostate that is being entered.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the entry into the pseudostate.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the pseudostate is of kind 'choice' and no valid transition can be determined (i.e., no transition guard is satisfied), an Exception is raised indicating a model error.</p> <p>Returns:</p> Type Description <p>An awaitable object that, when awaited, yields the result of the executed</p> <p>transition(s). Depending on the pseudostate kind, this could be the result from</p> <p>a single transition or a collection of results from multiple transitions (in</p> <p>the case of a 'fork' pseudostate).</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_pseudostate_entry(\n    self, pseudostate: core.Pseudostate, event: core.Event\n):\n    \"\"\"\n    Executes the entry behavior of a pseudostate based on its kind.\n    This asynchronous method processes the entry of a pseudostate and performs\n    actions based on its type (e.g., initial, choice, join, fork). It logs the entry,\n    determines the proper transition(s) based on the pseudostate kind and the given\n    event, and asynchronously executes the appropriate transition(s).\n\n    Args:\n        pseudostate (core.Pseudostate):\n             The pseudostate that is being entered.\n        event (core.Event):\n             The event that triggered the entry into the pseudostate.\n\n    Raises:\n        Exception:\n             If the pseudostate is of kind 'choice' and no valid transition can be\n            determined (i.e., no transition guard is satisfied), an Exception is\n            raised indicating a model error.\n\n    Returns:\n        An awaitable object that, when awaited, yields the result of the executed\n        transition(s). Depending on the pseudostate kind, this could be the result from\n        a single transition or a collection of results from multiple transitions (in\n        the case of a 'fork' pseudostate).\n\n    \"\"\"\n    self.log.debug(\n        f\"entering {pseudostate.kind.value} psuedostate {model.qualified_name_of(pseudostate)}\"\n    )\n    if pseudostate.kind == core.PseudostateKind.initial:\n        return await self.exec_transition(pseudostate.outgoing[0], event)\n    elif pseudostate.kind == core.PseudostateKind.choice:\n        for transition in pseudostate.outgoing:\n            if transition.guard is None or await self.exec_constraint_evaluate(\n                transition.guard, event\n            ):\n                return await self.exec_transition(transition, event)\n        raise Exception(\"no valid transition this should never throw\")\n    elif pseudostate.kind == core.PseudostateKind.join:\n        if all(\n            transition.source not in self.stack\n            for transition in pseudostate.incoming\n        ):\n            return await self.exec_transition(pseudostate.outgoing[0], event)\n    elif pseudostate.kind == core.PseudostateKind.fork:\n        return await asyncio.gather(\n            *(\n                self.exec_transition(transition, event)\n                for transition in pseudostate.outgoing\n            )\n        )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_pseudostate_exit","title":"<code>exec_pseudostate_exit(psuedostate, event)</code>  <code>async</code>","text":"<p>Async function to execute the exit process of a given pseudostate in response to an event. This function is designed to handle the exiting of a pseudostate, which is typically a state in a state machine that does not correspond to a condition or action in the traditional sense, but instead is used to represent an abstract state or a state that serves as a transition to other states. The function takes as input the pseudostate to be exited and the event that triggered the exit process.</p> <p>Parameters:</p> Name Type Description Default <code>psuedostate</code> <code>Pseudostate</code> <p>The pseudostate object to be exited.</p> required <code>event</code> <code>Event</code> <p>The event object that has triggered the exit of the pseudostate.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_pseudostate_exit(\n    self, psuedostate: core.Pseudostate, event: core.Event\n):\n    \"\"\"\n    Async function to execute the exit process of a given pseudostate in response to an event.\n    This function is designed to handle the exiting of a pseudostate, which is typically\n    a state in a state machine that does not correspond to a condition or action in the\n    traditional sense, but instead is used to represent an abstract state or a state that\n    serves as a transition to other states. The function takes as input the pseudostate\n    to be exited and the event that triggered the exit process.\n\n    Args:\n        psuedostate (core.Pseudostate):\n             The pseudostate object to be exited.\n        event (core.Event):\n             The event object that has triggered the exit of the pseudostate.\n\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_region_entry","title":"<code>exec_region_entry(region, event, kind)</code>  <code>async</code>","text":"<p>Executes the entry logic for a given state machine region. This asynchronous method is responsible for entering a region of the state machine. Based on the entry kind specified, it either proceeds with the default entry logic by initiating the region's initial pseudostate or simply prepares for entry into the region without further action.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>Region</code> <p>The region of the state machine that is being entered.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the entry into the region.</p> required <code>kind</code> <code>EntryKind</code> <p>The kind of entry into the region, which determines the behavior on region entry. A 'default' kind leads to executing the initial pseudostate, while other kinds may alter this behavior.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the states that have been entered as a result of the entry process. For 'default' kind with an initial pseudostate, it's the result of the pseudostate entry; otherwise, it's an empty tuple.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_region_entry(\n    self, region: core.Region, event: core.Event, kind: core.EntryKind\n):\n    \"\"\"\n    Executes the entry logic for a given state machine region.\n    This asynchronous method is responsible for entering a region of the state machine. Based on the\n    entry kind specified, it either proceeds with the default entry logic by initiating the region's\n    initial pseudostate or simply prepares for entry into the region without further action.\n\n    Args:\n        region (core.Region):\n             The region of the state machine that is being entered.\n        event (core.Event):\n             The event that triggered the entry into the region.\n        kind (core.EntryKind):\n             The kind of entry into the region, which determines the behavior\n            on region entry. A 'default' kind leads to executing the initial pseudostate, while other kinds may\n            alter this behavior.\n\n    Returns:\n        (tuple):\n             A tuple representing the states that have been entered as a result of the entry\n            process. For 'default' kind with an initial pseudostate, it's the result of the pseudostate entry;\n            otherwise, it's an empty tuple.\n\n    Raises:\n        Any exceptions raised by the `exec_pseudostate_entry` if 'default' kind entry is being processed\n        and the region has an initial pseudostate.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(region)\n    self.log.debug(f\"entering region {qualified_name}\")\n    states = ()\n    if kind == core.EntryKind.default:\n        if region.initial is None:\n            return states\n        self.push(region)\n        return await self.exec_pseudostate_entry(region.initial, event)\n    self.push(region)\n    return states\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_region_exit","title":"<code>exec_region_exit(region, event)</code>  <code>async</code>","text":"<p>Asynchronously exits a region within a state machine. This method handles the process of exiting a region by first determining the region's qualified name and logging the exit action. It then identifies the active vertex (state) of the region currently on the stack, if any. If an active vertex exists, the method ensures its proper exit sequence is executed. Finally, the region is popped from the internal state stack. This method is an asynchronous coroutine and should be awaited.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>Region</code> <p>The region to exit from within the state machine.</p> required <code>event</code> <code>Event</code> <p>The event instance that triggered the exit.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_region_exit(self, region: core.Region, event: core.Event):\n    \"\"\"\n    Asynchronously exits a region within a state machine.\n    This method handles the process of exiting a region by first determining the region's qualified name and logging the exit action. It then identifies the active vertex (state) of the region currently on the stack, if any. If an active vertex exists, the method ensures its proper exit sequence is executed. Finally, the region is popped from the internal state stack.\n    This method is an asynchronous coroutine and should be awaited.\n\n    Args:\n        region (core.Region):\n             The region to exit from within the state machine.\n        event (core.Event):\n             The event instance that triggered the exit.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(region)\n    self.log.debug(f'leaving region \"{qualified_name}\"')\n    active_vertex = next(\n        (vertex for vertex in region.subvertex if vertex in self.stack),\n        None,\n    )\n    if active_vertex is not None:\n        await self.exec_vertex_exit(active_vertex, event)\n    self.pop(region)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_region_processing","title":"<code>exec_region_processing(region, event)</code>  <code>async</code>","text":"<p>Performs the execution processing of a given region within a state machine, handling an incoming event. This asynchronous method checks if the region is currently active and proceeds to process the specified event by executing its corresponding active state. It is part of the state machine's execution logic which would typically be involved in the workflow of state transitions and event handling.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>Region</code> <p>The region of the state machine to be processed.</p> required <code>event</code> <code>Event</code> <p>The event to be handled within the region's active state.</p> required <p>Returns:</p> Type Description <code>InterpreterStep</code> <p>An enumeration value representing the completion status of the region processing. This could either be <code>InterpreterStep.incomplete</code> indicating that the processing is not yet complete, due to either the region not being active or the absence of an active state within the region.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the region or event parameters are not instances of their respective expected types.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_region_processing(\n    self, region: core.elements.Region, event: core.elements.Event\n):\n    \"\"\"\n    Performs the execution processing of a given region within a state machine, handling an incoming event.\n    This asynchronous method checks if the region is currently active and proceeds to process the\n    specified event by executing its corresponding active state. It is part of the state machine's\n    execution logic which would typically be involved in the workflow of state transitions and event handling.\n\n    Args:\n        region (core.elements.Region):\n             The region of the state machine to be processed.\n        event (core.elements.Event):\n             The event to be handled within the region's active state.\n\n    Returns:\n        (InterpreterStep):\n             An enumeration value representing the completion status of the region processing.\n            This could either be `InterpreterStep.incomplete` indicating that the processing is not yet complete,\n            due to either the region not being active or the absence of an active state within the region.\n\n    Raises:\n        TypeError:\n             If the region or event parameters are not instances of their respective expected types.\n\n    \"\"\"\n    if not self.is_active(region):\n        return InterpreterStep.incomplete\n    active_state = next(\n        (state for state in region.subvertex if self.is_active(state)), None\n    )\n    if active_state is None:\n        return InterpreterStep.incomplete\n    return await self.exec_state_processing(active_state, event)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_state_entry","title":"<code>exec_state_entry(state, event, kind)</code>  <code>async</code>","text":"<p>Asynchronously executes the entry logic for the given state in a State Machine. This coroutine manages the transition into a state by performing several actions: - It logs the entry into the state. - Executes the 'entry' behavior for the state, if it exists. - Initiates and manages the state's 'activity', if it exists, by scheduling it to run asynchronously. - Skips further actions if the state contains a submachine (a nested State Machine). - Recursively invokes entry logic for each contained region within the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The state object that is being entered.</p> required <code>event</code> <code>Event</code> <p>The event object that triggered the state transition.</p> required <code>kind</code> <code>EntryKind</code> <p>The enumeration value representing the kind of entry action to be executed.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_state_entry(\n    self, state: core.State, event: core.Event, kind: core.EntryKind\n):\n    \"\"\"\n    Asynchronously executes the entry logic for the given state in a State Machine.\n    This coroutine manages the transition into a state by performing several actions:\n    - It logs the entry into the state.\n    - Executes the 'entry' behavior for the state, if it exists.\n    - Initiates and manages the state's 'activity', if it exists, by scheduling it to run asynchronously.\n    - Skips further actions if the state contains a submachine (a nested State Machine).\n    - Recursively invokes entry logic for each contained region within the state.\n\n    Args:\n        state (core.State):\n             The state object that is being entered.\n        event (core.Event):\n             The event object that triggered the state transition.\n        kind (core.EntryKind):\n             The enumeration value representing the kind of entry action to be executed.\n\n    Returns:\n        None\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(state)\n    self.log.debug(f\"entering state {qualified_name}\")\n    if state.entry is not None:\n        await self.exec_behavior(state.entry, event)\n    if state.activity is not None:\n        self.push(\n            state.activity,\n            self.loop.create_task(self.exec_behavior(state.activity, event)),\n        )\n    if state.submachine is not None:\n        return\n    await asyncio.gather(\n        *(\n            self.exec_region_entry(region, event, kind)\n            for region in state.regions or []\n        )\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_state_exit","title":"<code>exec_state_exit(state, event)</code>  <code>async</code>","text":"<p>Performs the exit sequence for a given state in the context of a state machine. This asynchronous method handles the exit behavior of a state before a transition to another state. It will go through any nested state machines or regions associated with the given state, triggering their own exit sequences. If the state has an associated activity, and it's still running, it will be canceled. Lastly, if the state has defined an exit behavior, it is executed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The state from which to exit.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the state exit, if any.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_state_exit(self, state: core.State, event: core.Event):\n    \"\"\"\n    Performs the exit sequence for a given state in the context of a state machine.\n    This asynchronous method handles the exit behavior of a state before a transition to another state. It will go through any nested state machines or regions associated with the given state, triggering their own exit sequences. If the state has an associated activity, and it's still running, it will be canceled. Lastly, if the state has defined an exit behavior, it is executed.\n\n    Args:\n        state (core.State):\n             The state from which to exit.\n        event (core.Event):\n             The event that triggered the state exit, if any.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(state)\n    if state.submachine is not None:\n        await self.exec_state_machine_exit(state.submachine, event)\n    else:\n        await asyncio.gather(\n            *(\n                self.exec_region_exit(region, event)\n                for region in state.regions or []\n            )\n        )\n    if state.activity is not None:\n        activity = self.pop(state.activity)\n        if not activity.done():\n            activity.cancel()\n    if state.exit is not None:\n        await self.exec_behavior(state.exit, event)\n    self.log.debug(f'leaving state \"{qualified_name}\"')\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_state_machine_entry","title":"<code>exec_state_machine_entry(state_machine, event, kind)</code>  <code>async</code>","text":"<p>Asynchronously executes the entry behavior for a given state machine. This method is responsible for logging the entry into the state machine and then concurrently executing the entry behavior of all regions within the state machine. It uses asynchronous gathering to ensure that all regions start their entry behavior concurrently.</p> <p>Parameters:</p> Name Type Description Default <code>state_machine</code> <code>StateMachine</code> <p>The state machine instance for which entry behavior needs to be executed.</p> required <code>event</code> <code>Optional[Event]</code> <p>The event that triggered the entry into the state machine, if any.</p> required <code>kind</code> <code>EntryKind</code> <p>The kind of entry to be performed for the state machine.</p> required <p>Returns:</p> Type Description <p>A coroutine that, when awaited, results in the concurrent execution of entry</p> <p>behavior for all regions within the state machine.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_state_machine_entry(\n    self,\n    state_machine: \"core.StateMachine\",\n    event: typing.Optional[core.Event],\n    kind: core.EntryKind,\n):\n    \"\"\"\n    Asynchronously executes the entry behavior for a given state machine.\n    This method is responsible for logging the entry into the state machine and\n    then concurrently executing the entry behavior of all regions within the\n    state machine. It uses asynchronous gathering to ensure that all regions\n    start their entry behavior concurrently.\n\n    Args:\n        state_machine (core.StateMachine):\n             The state machine instance for which entry behavior needs to be executed.\n        event (typing.Optional[core.Event]):\n             The event that triggered the entry into the state machine, if any.\n        kind (core.EntryKind):\n             The kind of entry to be performed for the state machine.\n\n    Returns:\n        A coroutine that, when awaited, results in the concurrent execution of entry\n        behavior for all regions within the state machine.\n\n    \"\"\"\n    self.log.debug(\n        f'entering state machine \"{model.qualified_name_of(state_machine)}\" with {state_machine.regions.length} regions'\n    )\n    return await asyncio.gather(\n        *(\n            self.exec_region_entry(region, event, kind)\n            for region in state_machine.regions\n        )\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_state_machine_exit","title":"<code>exec_state_machine_exit(state_machine, event)</code>  <code>async</code>","text":"<p>Asynchronously leaves the state machine and executes the cleanup for each region within it. This method is responsible for triggering the exit process from a given state machine and ensuring that each of the regions within the state machine has its exit process executed. It logs the activity and utilizes asynchronous gathering to handle the exiting of multiple regions concurrently.</p> <p>Parameters:</p> Name Type Description Default <code>state_machine</code> <code>StateMachine</code> <p>The state machine instance that is being exited.</p> required <code>event</code> <code>Optional[Event]</code> <p>An optional event that might have triggered the state machine exit. This parameter may be None, indicating that no specific event is associated with the exit action.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_state_machine_exit(\n    self,\n    state_machine: \"core.StateMachine\",\n    event: typing.Optional[core.Event],\n):\n    \"\"\"\n    Asynchronously leaves the state machine and executes the cleanup for each region within it.\n    This method is responsible for triggering the exit process from a given state machine and ensuring\n    that each of the regions within the state machine has its exit process executed. It logs the\n    activity and utilizes asynchronous gathering to handle the exiting of multiple regions concurrently.\n\n    Args:\n        state_machine (core.StateMachine):\n             The state machine instance that is being exited.\n        event (typing.Optional[core.Event]):\n             An optional event that might have triggered the state machine exit.\n            This parameter may be None, indicating that no specific event is associated with the exit action.\n\n    \"\"\"\n    self.log.debug(\n        f'leaving state machine \"{model.qualified_name_of(state_machine)}\"'\n    )\n    await asyncio.gather(\n        *(self.exec_region_exit(region, event) for region in state_machine.regions)\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_state_processing","title":"<code>exec_state_processing(state, event)</code>  <code>async</code>","text":"<p>Performs processing on a state within the state machine given an event. This function executes the processing logic associated with a given state. If the state is not active, it immediately returns an incomplete step indicator. Otherwise, it proceeds to check if the state has regions and processes them asynchronously, waiting for all to complete before continuing. If all regions return an incomplete processing result, or there are no regions, it attempts to process the state itself as a vertex. Finally, it returns the result of the processing, whether that be the processing of the regions or the state as a vertex.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The state that needs to be processed.</p> required <code>event</code> <code>Event</code> <p>The event that may trigger state transitions or actions.</p> required <p>Returns:</p> Type Description <code>InterpreterStep</code> <p>The result of the state processing, which can indicate whether the processing is complete, incomplete, or has resulted in a transition.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_state_processing(\n    self, state: core.elements.State, event: core.elements.Event\n):\n    \"\"\"\n    Performs processing on a state within the state machine given an event.\n    This function executes the processing logic associated with a given state. If the state is not active, it immediately returns an incomplete step indicator. Otherwise, it proceeds to check if the state has regions and processes them asynchronously, waiting for all to complete before continuing.\n    If all regions return an incomplete processing result, or there are no regions, it attempts to process the state itself as a vertex. Finally, it returns the result of the processing, whether that be the processing of the regions or the state as a vertex.\n\n    Args:\n        state (core.elements.State):\n             The state that needs to be processed.\n        event (core.elements.Event):\n             The event that may trigger state transitions or actions.\n\n    Returns:\n        (InterpreterStep):\n             The result of the state processing, which can indicate whether the processing is complete, incomplete, or has resulted in a transition.\n\n    \"\"\"\n    if not self.is_active(state):\n        return InterpreterStep.incomplete\n    elif state.regions is not None:\n        result = next(\n            (\n                result\n                for result in (\n                    await asyncio.gather(\n                        *(\n                            self.exec_region_processing(region, event)\n                            for region in state.regions\n                        )\n                    )\n                )\n                if result is not InterpreterStep.incomplete\n            ),\n            InterpreterStep.incomplete,\n        )\n    else:\n        result = InterpreterStep.incomplete\n    if result is InterpreterStep.incomplete:\n        result = await self.exec_vertex_processing(state, event)\n    return result\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_time_event_entry","title":"<code>exec_time_event_entry(event)</code>","text":"<p>Schedules the execution of a time-based event. This function initiates an asynchronous task to handle a time-event in the context of the current model's state machine. It uses the asyncio library to create a new task which will await the execution of the 'exec_time_event_wait' coroutine. The task is assigned a name that corresponds to the fully qualified name of the event, which is retrieved using the 'model.qualified_name_of' method.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>TimeEvent</code> <p>An instance of a time-based event that is to be handled by the state machine.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The newly created asyncio task object that is responsible for executing the time-event.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>def exec_time_event_entry(self, event: core.TimeEvent):\n    \"\"\"\n    Schedules the execution of a time-based event.\n    This function initiates an asynchronous task to handle a time-event in the context of the current model's state machine.\n    It uses the asyncio library to create a new task which will await the execution of the 'exec_time_event_wait' coroutine.\n    The task is assigned a name that corresponds to the fully qualified name of the event, which is retrieved using the 'model.qualified_name_of' method.\n\n    Args:\n        event (core.TimeEvent):\n             An instance of a time-based event that is to be handled by the state machine.\n\n    Returns:\n        (asyncio.Task):\n             The newly created asyncio task object that is responsible for executing the time-event.\n\n    \"\"\"\n    return asyncio.create_task(\n        self.exec_time_event_wait(event), name=model.qualified_name_of(event)\n    )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_time_event_wait","title":"<code>exec_time_event_wait(event)</code>  <code>async</code>","text":"<p>Async function to wait for a specific time event and then send the event. This asynchronous method takes a time event object and performs a sleep operation for the duration specified by the <code>when</code> attribute of the time event. After the wait period is over, it sends the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>TimeEvent</code> <p>The time event object containing the <code>when</code> attribute, which specifies the duration to wait before sending the event.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_time_event_wait(self, event: core.TimeEvent) -&gt; None:\n    \"\"\"\n    Async function to wait for a specific time event and then send the event.\n    This asynchronous method takes a time event object and performs a sleep operation for the duration specified by the `when` attribute of the time event. After the wait period is over, it sends the event.\n\n    Args:\n        event (core.TimeEvent):\n             The time event object containing the `when` attribute, which specifies the duration to wait before sending the event.\n\n    Returns:\n        None\n\n    \"\"\"\n    await asyncio.sleep(event.when.total_seconds())\n    await self.send(event.__class__())\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_transition","title":"<code>exec_transition(transition, event=None)</code>  <code>async</code>","text":"<p>Performs the execution of a given transition within a state machine. This coroutine executes the actions associated with leaving the current state vertices, executing transition's effect if any, and entering the target state vertices. It logs the process of executing each transition for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>Transition</code> <p>The transition to be executed.</p> required <code>event</code> <code>Event</code> <p>The event that may have triggered the transition. Defaults to None.</p> <code>None</code> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_transition(\n    self, transition: core.Transition, event: core.Event = None\n):\n    \"\"\"\n    Performs the execution of a given transition within a state machine.\n    This coroutine executes the actions associated with leaving the current state vertices, executing transition's effect if any, and entering the target state vertices. It logs the process of executing each transition for debugging purposes.\n\n    Args:\n        transition (core.Transition):\n             The transition to be executed.\n        event (core.Event, optional):\n             The event that may have triggered the transition. Defaults to None.\n\n    \"\"\"\n    self.log.debug(f\"executing transition {model.qualified_name_of(transition)}\")\n    for vertex in transition.path.leave:\n        await self.exec_vertex_exit(vertex, event)\n    if transition.effect is not None:\n        await self.exec_behavior(transition.effect, event)\n    for index, vertex in enumerate(transition.path.enter):\n        await self.exec_vertex_entry(\n            vertex,\n            event,\n            core.EntryKind.default\n            if index == transition.path.enter.length - 1\n            else core.EntryKind.explicit,\n        )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_transition_entry","title":"<code>exec_transition_entry(transition)</code>  <code>async</code>","text":"<p>Performs entry operations for a given state transition in an asynchronous state machine. This method logs the entering of a transition, then pushes the transition onto the state stack. It proceeds to gather tasks associated with the entry events of the transition, executes them asynchronously, and waits for their completion before advancing.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>Transition</code> <p>The transition object representing the state transition that is being entered.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return a value and is intended to be used for its side effects.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_transition_entry(self, transition: core.Transition) -&gt; None:\n    \"\"\"\n    Performs entry operations for a given state transition in an asynchronous state machine.\n    This method logs the entering of a transition, then pushes the transition onto the state stack. It\n    proceeds to gather tasks associated with the entry events of the transition, executes them asynchronously,\n    and waits for their completion before advancing.\n\n    Args:\n        transition (core.Transition):\n             The transition object representing the state transition\n            that is being entered.\n\n    Returns:\n        (None):\n             This method does not return a value and is intended to be used for its side effects.\n\n    Raises:\n        This method does not explicitly raise any exceptions, but exceptions could be raised by\n        the tasks executed during transition entry, which should be handled by the calling context.\n\n    \"\"\"\n    qualified_name = model.qualified_name_of(transition)\n    self.log.debug(f\"entering transition {qualified_name}\")\n    self.push(transition)\n    tasks = []\n    for event in transition.events:\n        task = self.exec_event_entry(event)\n        if task is not None:\n            tasks.append(task)\n    if tasks:\n        self.push(\n            transition.events,\n            self.wait(*tasks),\n        )\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_transition_exit","title":"<code>exec_transition_exit(transition)</code>  <code>async</code>","text":"<p>Asynchronously executes the exit logic for a given state machine transition. This method is responsible for handling the exit process when a state machine transition occurs. It iterates over both events associated with the transition and the transition itself, and for each element, it checks whether the element exists in the state machine's stack. If any element is found within the stack, the method will asynchronously pop the element from the stack.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>Transition</code> <p>The transition object that is undergoing the exit process.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_transition_exit(self, transition: core.Transition):\n    \"\"\"\n    Asynchronously executes the exit logic for a given state machine transition.\n    This method is responsible for handling the exit process when a state machine transition occurs. It iterates over both events associated with the transition and the transition itself, and for each element, it checks whether the element exists in the state machine's stack. If any element is found within the stack, the method will asynchronously pop the element from the stack.\n\n    Args:\n        transition (core.Transition):\n             The transition object that is undergoing the exit process.\n\n    Raises:\n        Any exceptions that could occur while popping elements from the stack are implicitly raised and not caught within this function.\n\n    \"\"\"\n    for element in (*transition.events, transition.events, transition):\n        if element in self.stack:\n            self.pop(element)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_transition_processing","title":"<code>exec_transition_processing(transition, event)</code>  <code>async</code>","text":"<p>Performs the processing of a given state transition based on an event. This asynchronous method checks if the specified event matches one of the expected events for the transition, and whether the transition's guard condition (if any) is satisfied. If the conditions are met, the method executes the transition and indicates that the process is complete. If the conditions are not met, the processing is incomplete.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>Transition</code> <p>The transition to be processed.</p> required <code>event</code> <code>Event</code> <p>The event that is triggering the transition.</p> required <p>Returns:</p> Type Description <code>InterpreterStep</code> <p>An enum indicating whether the transition processing is 'complete' or 'incomplete'.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_transition_processing(\n    self, transition: core.Transition, event: core.Event\n):\n    \"\"\"\n    Performs the processing of a given state transition based on an event.\n    This asynchronous method checks if the specified event matches one of the expected events for the transition, and whether the transition's guard condition (if any) is satisfied. If the conditions are met, the method executes the transition and indicates that the process is complete. If the conditions are not met, the processing is incomplete.\n\n    Args:\n        transition (core.Transition):\n             The transition to be processed.\n        event (core.Event):\n             The event that is triggering the transition.\n\n    Returns:\n        (InterpreterStep):\n             An enum indicating whether the transition processing is 'complete' or 'incomplete'.\n\n    \"\"\"\n    if any(\n        isinstance(_event, (type(event), core.AnyEvent))\n        for _event in transition.events\n    ) and (\n        transition.guard is None\n        or await self.exec_constraint_evaluate(transition.guard, event)\n    ):\n        await self.exec_transition(transition, event)\n        return InterpreterStep.complete\n    return InterpreterStep.incomplete\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_vertex_entry","title":"<code>exec_vertex_entry(vertex, event, kind)</code>  <code>async</code>","text":"<p>Executes entry logic for a given vertex within a state machine. This asynchronous method handles the entry logic for different vertex types present in a state machine. Depending on the type of the vertex (core.State, core.FinalState, or core.Pseudostate), it will perform the appropriate entry actions and execute any outgoing transitions related to that vertex. It also manages the vertex stack by pushing the current vertex into it before proceeding with the entry actions.</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>Vertex</code> <p>The vertex at which to start executing the entry logic.</p> required <code>event</code> <code>Event</code> <p>The event instance that triggered the state transition.</p> required <code>kind</code> <code>EntryKind</code> <p>The kind of entry action to be performed. This helps determine how deep the entry logic should go; for instance, it could specify entering only the top state or recursive entry to all substates.</p> required <p>Returns:</p> Type Description <code>List[object]</code> <p>A list of results from execution of entry logic and transitions originating from the vertex. The content of this list can vary depending on the type of vertex and number of transitions.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided vertex is not castable to one of the expected vertex types (core.State, core.FinalState, or core.Pseudostate).</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_vertex_entry(\n    self, vertex: core.Vertex, event: core.Event, kind: core.EntryKind\n):\n    \"\"\"\n    Executes entry logic for a given vertex within a state machine.\n    This asynchronous method handles the entry logic for different vertex types present in a state machine. Depending on the type of the vertex (core.State, core.FinalState, or core.Pseudostate), it will perform the appropriate entry actions and execute any outgoing transitions related to that vertex. It also manages the vertex stack by pushing the current vertex into it before proceeding with the entry actions.\n\n    Args:\n        vertex (core.Vertex):\n             The vertex at which to start executing the entry logic.\n        event (core.Event):\n             The event instance that triggered the state transition.\n        kind (core.EntryKind):\n             The kind of entry action to be performed. This helps determine how deep the entry logic should go; for instance, it could specify entering only the top state or recursive entry to all substates.\n\n    Returns:\n        (List[object]):\n             A list of results from execution of entry logic and transitions originating from the vertex. The content of this list can vary depending on the type of vertex and number of transitions.\n\n    Raises:\n        TypeError:\n             If the provided vertex is not castable to one of the expected vertex types (core.State, core.FinalState, or core.Pseudostate).\n\n    \"\"\"\n    self.push(vertex)\n    if isinstance(vertex, core.State):\n        await self.exec_state_entry(vertex, event, kind)\n        results = await asyncio.gather(\n            *(\n                self.exec_transition_entry(transition)\n                for transition in vertex.outgoing\n            )\n        )\n\n    elif isinstance(vertex, core.FinalState):\n        results = await self.exec_final_state_entry(vertex, event)\n    else:\n        results = await self.exec_pseudostate_entry(\n            typing.cast(core.Pseudostate, vertex), event\n        )\n    return results\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_vertex_exit","title":"<code>exec_vertex_exit(vertex, event)</code>  <code>async</code>","text":"<p>Asynchronously executes the exit behavior for a given vertex in a state machine. This coroutine checks if the provided vertex is an instance of <code>core.State</code> or any other type. If the vertex is a <code>core.State</code>, it performs two main tasks, executed concurrently for efficiency: it calls <code>exec_transition_exit</code> for all outgoing transitions, followed by <code>exec_state_exit</code> for the state itself. For other types of vertices, identified here as <code>core.Pseudostate</code>, it calls <code>exec_pseudostate_exit</code>. After executing the appropriate exit behavior, it then removes the vertex from consideration within the current flow by calling the <code>pop</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>Vertex</code> <p>The vertex that is exiting and requires the execution of its exit behavior.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the vertex's exit.</p> required Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_vertex_exit(self, vertex: core.Vertex, event: core.Event):\n    \"\"\"\n    Asynchronously executes the exit behavior for a given vertex in a state machine.\n    This coroutine checks if the provided vertex is an instance of `core.State` or any other type. If the vertex is a `core.State`, it performs two main tasks, executed concurrently for efficiency: it calls `exec_transition_exit` for all outgoing transitions, followed by `exec_state_exit` for the state itself. For other types of vertices, identified here as `core.Pseudostate`, it calls `exec_pseudostate_exit`. After executing the appropriate exit behavior, it then removes the vertex from consideration within the current flow by calling the `pop` method.\n\n    Args:\n        vertex (core.Vertex):\n             The vertex that is exiting and requires the execution of its exit behavior.\n        event (core.Event):\n             The event that triggered the vertex's exit.\n\n    \"\"\"\n    if isinstance(vertex, core.State):\n        await asyncio.gather(\n            *(\n                self.exec_transition_exit(transition)\n                for transition in vertex.outgoing\n            )\n        )\n        await self.exec_state_exit(vertex, event)\n    else:\n        await self.exec_pseudostate_exit(\n            typing.cast(core.Pseudostate, vertex), event\n        )\n    self.pop(vertex)\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.exec_vertex_processing","title":"<code>exec_vertex_processing(vertex, event)</code>  <code>async</code>","text":"<p>Asynchronously processes a given vertex in the state machine with respect to an incoming event. This method iteratively examines all outgoing transitions from the provided vertex. It attempts to process each transition with the given event by invoking the exec_transition_processing method. The processing of transitions continues until either the processing of a transition results in a 'complete' state or all transitions have been processed without reaching a 'complete' state.</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>Vertex</code> <p>The vertex to process which contains the outgoing transitions.</p> required <code>event</code> <code>Event</code> <p>The event that triggered the processing of the vertex.</p> required <p>Returns:</p> Type Description <code>InterpreterStep</code> <p>An enum value indicating whether the processing of the vertex resulted in a 'complete' or 'incomplete' state. 'complete' is returned if any of the transitions reached completion, otherwise 'incomplete' is returned if all transitions were processed and none was completed.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def exec_vertex_processing(self, vertex: core.Vertex, event: core.Event):\n    \"\"\"\n    Asynchronously processes a given vertex in the state machine with respect to an incoming event.\n    This method iteratively examines all outgoing transitions from the provided vertex. It attempts to process each transition with the given event by invoking the exec_transition_processing method. The processing of transitions continues until either the processing of a transition results in a 'complete' state or all transitions have been processed without reaching a 'complete' state.\n\n    Args:\n        vertex (core.Vertex):\n             The vertex to process which contains the outgoing transitions.\n        event (core.Event):\n             The event that triggered the processing of the vertex.\n\n    Returns:\n        (InterpreterStep):\n             An enum value indicating whether the processing of the vertex resulted in a 'complete' or 'incomplete' state. 'complete' is returned if any of the transitions reached completion, otherwise 'incomplete' is returned if all transitions were processed and none was completed.\n\n    \"\"\"\n    for transition in vertex.outgoing:\n        if (\n            await self.exec_transition_processing(transition, event)\n            == InterpreterStep.complete\n        ):\n            return InterpreterStep.complete\n    return InterpreterStep.incomplete\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Async function to start and manage the execution of the state machine. This method initiates the run process of the state machine by logging its execution and handling its entry operations. It proceeds to call the <code>step</code> method to perform the state machine's transitions. If an <code>asyncio.CancelledError</code> occurs, it logs that the state machine is stopping. In the absence of exceptions, it delegates to the superclass's <code>run</code> method to continue the running process.</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If the asynchronous task that called <code>run</code> is cancelled.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Async function to start and manage the execution of the state machine.\n    This method initiates the run process of the state machine by logging its execution and handling\n    its entry operations. It proceeds to call the `step` method to perform the state machine's\n    transitions. If an `asyncio.CancelledError` occurs, it logs that the state machine is stopping.\n    In the absence of exceptions, it delegates to the superclass's `run` method to continue the\n    running process.\n\n    Raises:\n        asyncio.CancelledError:\n             If the asynchronous task that called `run` is cancelled.\n\n    \"\"\"\n    self.log.debug(f'running state machine \"{model.qualified_name_of(self.model)}\"')\n    await self.exec_state_machine_entry(self.model, None, core.EntryKind.default)\n    try:\n        await self.step()\n    except asyncio.CancelledError:\n        self.log.debug(\n            f'stopping state machine \"{model.qualified_name_of(self.model)}\"'\n        )\n        return\n    return await super().run()\n</code></pre>"},{"location":"Python/API/StateMachine/Interpreters/Async%20StateMachine%20Interpreter/#stateforward.state_machine.interpreters.asynchronous.async_state_machine_interpreter.AsyncStateMachineInterpreter.terminate","title":"<code>terminate()</code>  <code>async</code>","text":"<p>Asynchronously terminates the current object's operations by executing the state machine exit process and then calling the terminate method of the superclass. This method performs two main actions in sequence. First, it calls 'exec_state_machine_exit' with the current model instance and 'None' as arguments to properly exit any state the object might be in. After that, it awaits the termination method of the superclass to ensure any additional superclass-specific termination procedures are carried out.</p> <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value. Its purpose is to perform an asynchronous cleanup.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/async_state_machine_interpreter.py</code> <pre><code>async def terminate(self):\n    \"\"\"\n    Asynchronously terminates the current object's operations by executing the state machine exit process and then calling the terminate method of the superclass.\n    This method performs two main actions in sequence. First, it calls 'exec_state_machine_exit' with the current model instance and 'None' as arguments to properly exit any state the object might be in. After that, it awaits the termination method of the superclass to ensure any additional superclass-specific termination procedures are carried out.\n\n    Args:\n        None\n\n    Returns:\n        (None):\n             This method does not return any value. Its purpose is to perform an asynchronous cleanup.\n\n    Raises:\n        Any exception raised by 'exec_state_machine_exit' or the superclass termination method will propagate upwards, potentially to the invoker of this method.\n\n    \"\"\"\n    await self.exec_state_machine_exit(self.model, None)\n    await super().terminate()\n</code></pre>"},{"location":"Python/Examples/Complete%20StateMachine/","title":"Complete StateMachine","text":""},{"location":"Python/Examples/LightSwitch/","title":"LightSwitch","text":""},{"location":"Python/Examples/LightSwitch/#examples.light_switch--introduction","title":"Introduction","text":"<p>The <code>light_switch</code> module is part of the <code>stateforward</code> examples and showcases the implementation of an asynchronous state machine to model the behavior of a light switch. The example defines states for the light switch, such as <code>On</code>, <code>Off</code>, and <code>Flashing</code>, as well as events that trigger state transitions, such as turning the light <code>OnEvent</code> or <code>OffEvent</code>.</p> <p>Light Switch Example</p> DiagramCodeOutput <p>Here is a simple example of a light switch state machine using StateForward Python. <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / print(\"Light off entry\")\n    Off: exit / print(\"Light off exit\")\n    [*] --&gt; Off\n    On: On\n    On: entry / print(\"Light on entry\")\n    On: exit / print(\"Light on exit\")\n    Off --&gt; On : OnEvent\n    On --&gt; Off : OffEvent\n\n</code></pre></p> <pre><code>import stateforward as sf\nimport asyncio\n\n\nclass OnEvent(sf.Event):\n    pass\n\n\nclass OffEvent(sf.Event):\n    pass\n\n\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light on entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light on exit\")\n\n    class Off(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light off entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light off exit\")\n\n    initial = sf.initial(Off)\n    transitions = sf.collection(\n        sf.transition(OnEvent, source=Off, target=On),\n        sf.transition(OffEvent, source=On, target=Off),\n    )\n\n\nasync def main():\n    # instantiate a light switch\n    light_switch = LightSwitch()\n    # start the interpreter and wait for it to be settled\n    await light_switch.interpreter.start()\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OnEvent to the state machine\n    await sf.dispatch(OnEvent(), light_switch)\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OffEvent to the state machine\n    await sf.dispatch(OffEvent(), light_switch)\n    print(light_switch.state)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>Light off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\nLight on entry\n(&lt;__main__.LightSwitch.region.region_0.On object at 0x10683dd90&gt;,)\nLight on exit\nLight off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\n</code></pre>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--components-of-the-light-switch-state-machine","title":"Components of the Light Switch State Machine","text":""},{"location":"Python/Examples/LightSwitch/#examples.light_switch--events","title":"Events","text":"<ul> <li><code>OnEvent</code>: An event representing the action of turning the light on.</li> <li><code>OffEvent</code>: An event representing the action of turning the light off.</li> <li><code>FlashEvent</code>: An event that triggers the flashing mode, derived from the custom <code>ChangeEvent</code>.</li> </ul>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--states","title":"States","text":"<ul> <li><code>On</code>: The state representing the light being turned on.</li> <li><code>Off</code>: The state representing the light being turned off.</li> <li><code>Flashing</code>: The state representing the light in a flashing mode. Transition to this state is determined by the condition <code>lambda self, event=None: self.model.flashing</code>.</li> </ul>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--behaviors","title":"Behaviors","text":"<p>The module defines <code>PrintBehavior</code> as a simple behavior that prints a message to the console upon entering and exiting states.</p>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--defining-the-light-switch-state-machine","title":"Defining the Light Switch State Machine","text":"<p>The <code>LightSwitch</code> state machine is derived from <code>AsyncStateMachine</code> and specifies the states and transitions. It includes an attribute <code>flashing</code>, which is a boolean flag used to conditionally trigger the flashing state.</p>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--transitions","title":"Transitions","text":"<p>Transitions between states are defined using the <code>transition</code> function from the <code>stateforward</code> framework; it specifies what event causes the transition, the source state, and the target state, along with optional guards and effects.</p>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--asynchronous-operation","title":"Asynchronous Operation","text":"<p>The state machine is designed to operate asynchronously, making use of Python's <code>asyncio</code> library. This allows for concurrent operation within an event-driven system.</p>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--running-the-example","title":"Running the Example","text":"<p>The module includes an asynchronous <code>light_switch_main</code> function that initializes the state machine, starts it, and dispatches events to trigger state transitions. One can observe the behavior of the light switch by calling this function within an event loop.</p>"},{"location":"Python/Examples/LightSwitch/#examples.light_switch--conclusion","title":"Conclusion","text":"<p>The <code>stateforward.example.light_switch</code> module serves as an educational tool for understanding the <code>stateforward</code> framework and is an example of how to model and simulate a simple system with state machines in Python.</p> <p>To learn more about other parts of the <code>stateforward</code> framework or to adapt the light switch example for your own use case, please refer to the rest of the documentation.</p>"},{"location":"Python/Examples/Microwave/","title":"Microwave","text":""},{"location":"Python/Examples/Microwave/#examples.microwave--microwave-module-documentation","title":"Microwave Module Documentation","text":"<p>The <code>microwave</code> module defines an asynchronous state machine representing the behavior and operations of a microwave appliance using the <code>stateforward</code> (aliased as <code>sf</code>) library. This module includes the definition of various events, behaviors, and the <code>Microwave</code> class, which is an extension of <code>sf.AsyncStateMachine</code>.</p>"},{"location":"Python/Examples/Microwave/#examples.microwave--classes-and-events","title":"Classes and Events","text":"<ul> <li>Microwave: This is the main class representing a microwave. It is an asynchronous state machine with states and transitions that simulate the different functionalities of a microwave.</li> <li>Includes states such as <code>door</code>, <code>power</code>, <code>clock</code>, <code>light</code>, <code>oven_light</code>, <code>magnetron</code>, <code>turntable</code>, and <code>exhaust_fan</code>.</li> <li> <p>Contains methods <code>power_on</code> and <code>power_off</code> to simulate the power control.</p> </li> <li> <p>DoorOpenEvent, DoorCloseEvent: Represent the events of the microwave's door being opened or closed.</p> </li> <li> <p>OvenLightOnEvent, OvenLightOffEvent: Represent the events of turning the oven light on or off.</p> </li> <li> <p>ExhaustFanOnEvent, ExhaustFanOffEvent: Represent events for turning the exhaust fan on with various speeds, or turning it off.</p> </li> <li> <p>ClockSetEvent: Represents the event of setting the microwave's clock.</p> </li> <li> <p>CookStartEvent: Represents the event of starting the cooking process with a set duration.</p> </li> </ul>"},{"location":"Python/Examples/Microwave/#examples.microwave--behaviors","title":"Behaviors","text":"<ul> <li> <p>display_time: A behavior function for displaying the current time of the microwave's clock.</p> </li> <li> <p>display_clear: A behavior function for clearing the display.</p> </li> </ul>"},{"location":"Python/Examples/Microwave/#examples.microwave--helper-functions","title":"Helper Functions","text":"<ul> <li> <p>throw: A helper function that raises an exception.</p> </li> <li> <p>door_is_open: A helper function to check if the microwave's door is open.</p> </li> </ul>"},{"location":"Python/Examples/Microwave/#examples.microwave--microwave2","title":"Microwave2","text":"<ul> <li>Microwave2: A class that inherits from <code>Microwave</code>, allowing for potential extension or customization.</li> </ul>"},{"location":"Python/Examples/Microwave/#examples.microwave--module-execution","title":"Module Execution","text":"<p>If this module is run as the main program, an instance of <code>Microwave</code> is created and the state machine is started, demonstrating its initial state and behaviors after power on event.</p>"},{"location":"Python/Examples/Microwave/#examples.microwave--state-machine-description","title":"State Machine Description","text":"<p>The <code>Microwave</code> class uses nested states and regions to define the complex behavior of the microwave appliance. Each feature of a microwave, like the door, power, clock, and light, are implemented as regions with their own states and transitions. This modular design allows each feature to operate semi-independently, resulting in a comprehensive simulation of a microwave's functionalities.</p> <p>The state machine also makes use of asynchronous programming by defining states and transitions that are meant to be awaited. This means the state machine can work well with other asynchronous operations, making it suitable for integration in an event-driven or non-blocking runtime environment.</p>"},{"location":"Python/Examples/Microwave/#examples.microwave--developer-notes","title":"Developer Notes","text":"<p>While the module does not include usage and example sections, the detailed class and method definitions provide a clear indication of how the microwave state machine is intended to be used and extended. Developers can use this module as a starting point for building state machines for appliances or other systems that require complex state management with asynchronous behavior.</p>"},{"location":"Python/Examples/Microwave/#examples.microwave.ClockSetEvent","title":"<code>ClockSetEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class representing an event that triggers when the clock time is set. This class inherits from sf.Event and encapsulates functionality related to clock time-setting events. It contains a single class attribute 'time' that stores the datetime when the event is set.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>datetime</code> <p>The date and time when the clock is set. Defaults to None. This attribute is meant to be populated with the specific datetime when an instance of ClockSetEvent is created.</p> Source code in <code>examples/microwave.py</code> <pre><code>class ClockSetEvent(sf.Event):\n    \"\"\"\n    A class representing an event that triggers when the clock time is set.\n    This class inherits from sf.Event and encapsulates functionality related to clock time-setting events.\n    It contains a single class attribute 'time' that stores the datetime when the event is set.\n\n    Attributes:\n        time (datetime, optional):\n             The date and time when the clock is set. Defaults to None. This attribute\n            is meant to be populated with the specific datetime when an instance of ClockSetEvent is created.\n\n    \"\"\"\n    time: datetime = None\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.CookStartEvent","title":"<code>CookStartEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code></p> <p>A data class representing an event that triggers the start of the cooking process in a microwave.</p> <p>Attributes:</p> Name Type Description <code>duration</code> <code>timedelta</code> <p>The length of time for which the cooking process needs to run.</p> Source code in <code>examples/microwave.py</code> <pre><code>@dataclass(unsafe_hash=True)\nclass CookStartEvent(sf.Event):\n    \"\"\"\n    A data class representing an event that triggers the start of the cooking process in a microwave.\n\n    Attributes:\n        duration (timedelta, optional):\n             The length of time for which the cooking process needs to run.\n\n    \"\"\"\n    duration: timedelta = None\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.DoorCloseEvent","title":"<code>DoorCloseEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class representing an event that signifies the closing of a door. Inherits from the <code>sf.Event</code> class provided by the framework in use. This class serves as a specific type of event that can be dispatched and listened for within an event-driven architecture. It does not have any additional attributes or methods beyond what is provided by its parent class <code>sf.Event</code>.</p> Source code in <code>examples/microwave.py</code> <pre><code>class DoorCloseEvent(sf.Event):\n    \"\"\"\n    A class representing an event that signifies the closing of a door.\n    Inherits from the `sf.Event` class provided by the framework in use. This class\n    serves as a specific type of event that can be dispatched and listened for within\n    an event-driven architecture. It does not have any additional attributes or\n    methods beyond what is provided by its parent class `sf.Event`.\n\n    Attributes:\n        inherited attributes from `sf.Event`.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.DoorOpenEvent","title":"<code>DoorOpenEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A simple class that represents a 'door open' event within a system or application. This class serves as a marker or signal indicating that a door has been opened. It is intended for use as part of an event-driven architecture where components of the system respond to various events. The DoorOpenEvent does not include any additional data or functionality and is typically subclassed or instantiated by event-handling mechanisms to notify listeners or observers that a door has been opened.</p> Source code in <code>examples/microwave.py</code> <pre><code>class DoorOpenEvent(sf.Event):\n    \"\"\"\n    A simple class that represents a 'door open' event within a system or application.\n    This class serves as a marker or signal indicating that a door has been opened. It is intended for use as part of an event-driven architecture where components of the system respond to various events. The DoorOpenEvent does not include any additional data or functionality and is typically subclassed or instantiated by event-handling mechanisms to notify listeners or observers that a door has been opened.\n\n    Attributes:\n        Inherits all attributes from the `sf.Event` base class, but does not add any attributes of its own.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.ExhaustFanOffEvent","title":"<code>ExhaustFanOffEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A simple event class that signifies an exhaust fan has been turned off. This class is a subclass of <code>sf.Event</code> and does not introduce additional methods or attributes. It is used within an event-driven system to indicate when an exhaust fan has ceased operation. The class serves as a signal within systems that track or respond to exhaust fan states.</p> Note <p>This class should be used in the context of an event-driven architecture, where it can be dispatched to event listeners that handle the turning off of an exhaust fan accordingly.</p> Source code in <code>examples/microwave.py</code> <pre><code>class ExhaustFanOffEvent(sf.Event):\n    \"\"\"\n    A simple event class that signifies an exhaust fan has been turned off.\n    This class is a subclass of `sf.Event` and does not introduce additional methods or attributes. It is used within an event-driven system to indicate when an exhaust fan has ceased operation. The class serves as a signal within systems that track or respond to exhaust fan states.\n\n    Attributes:\n        Inherits all attributes from `sf.Event` without modification.\n\n    Note:\n        This class should be used in the context of an event-driven architecture, where it can be dispatched to event listeners that handle the turning off of an exhaust fan accordingly.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.ExhaustFanOnEvent","title":"<code>ExhaustFanOnEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code></p> <p>A data class representing an event to turn on the exhaust fan of a microwave. This event includes a speed attribute which denotes the desired speed level for the exhaust fan. The speed level is an integer that should correspond to a predetermined setting within the microwave's system. This class is a subclass of <code>sf.Event</code> from the library providing the state machine functionality.</p> <p>Attributes:</p> Name Type Description <code>speed</code> <code>int</code> <p>The speed level for the exhaust fan. The actual use of this value depends on implementation details of the microwave's state machine. If not specified, it defaults to <code>None</code> indicating that no specific speed level is set with this event.</p> Source code in <code>examples/microwave.py</code> <pre><code>@dataclass(unsafe_hash=True)\nclass ExhaustFanOnEvent(sf.Event):\n    \"\"\"\n    A data class representing an event to turn on the exhaust fan of a microwave.\n    This event includes a speed attribute which denotes the desired speed level for the exhaust fan.\n    The speed level is an integer that should correspond to a predetermined setting within the microwave's system.\n    This class is a subclass of `sf.Event` from the library providing the state machine functionality.\n\n    Attributes:\n        speed (int):\n             The speed level for the exhaust fan. The actual use of this value depends on implementation\n            details of the microwave's state machine. If not specified, it defaults to `None` indicating\n            that no specific speed level is set with this event.\n\n    \"\"\"\n    speed: int = None\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave","title":"<code>Microwave</code>","text":"<p>             Bases: <code>AsyncStateMachine</code></p> <p>A class representing an asynchronous state machine for a microwave oven. This class models the microwave's behavior using various regions that represent different aspects of the microwave's functionality. Each region is made up of states and transitions that define how the microwave reacts to events and changes in condition. The available regions include power, door, clock, light, oven light, magnetron, turntable, and exhaust fan, with each having its own set of states and transitions.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>datetime</code> <p>The current time of the microwave's clock, initialized to a default value.</p> <code>cook_time</code> <code>timedelta</code> <p>The duration for which cooking should occur; can be set to a specific duration.</p> <p>Methods:</p> Name Description <code>power_on</code> <p>Asynchronously triggered event which can cause a transition from the 'off' to 'on' power state.</p> <code>power_off</code> <p>Asynchronously triggered event which can cause a transition from the 'on' to 'off' power state. Each region has its own inner classes defining the states and transitions associated with that region - The power region defines the behavior of the microwave when turning on and off. - The door region manages the states related to the microwave door being open or closed. - The clock region has states for the clock being in a ticking or flashing state. - The light region controls the light inside the microwave, turning on when the door is opened. - The oven light region controls the oven's cavity light. - The magnetron region controls the state of the microwave's magnetron, responsible for generating the microwaves. - The turntable region manages the rotation of the turntable inside the microwave. - The exhaust fan region handles the operation of the exhaust fan at different speeds. Transitions between states are defined for each region, dictated by events that trigger these state changes. Guards can be applied on transitions to add conditions for the transition to occur.</p> Note <p>sf abbreviates the module used for creating the state machine framework, which is not defined in this docstring.</p> Source code in <code>examples/microwave.py</code> <pre><code>class Microwave(sf.AsyncStateMachine):\n    \"\"\"\n    A class representing an asynchronous state machine for a microwave oven.\n    This class models the microwave's behavior using various regions that represent different aspects of the microwave's functionality. Each region is made up of states and transitions that define how the microwave reacts to events and changes in condition. The available regions include power, door, clock, light, oven light, magnetron, turntable, and exhaust fan, with each having its own set of states and transitions.\n\n    Attributes:\n        time (datetime):\n             The current time of the microwave's clock, initialized to a default value.\n        cook_time (timedelta):\n             The duration for which cooking should occur; can be set to a specific duration.\n\n    Methods:\n        power_on:\n             Asynchronously triggered event which can cause a transition from the 'off' to 'on' power state.\n        power_off:\n             Asynchronously triggered event which can cause a transition from the 'on' to 'off' power state.\n            Each region has its own inner classes defining the states and transitions associated with that region\n            - The power region defines the behavior of the microwave when turning on and off.\n            - The door region manages the states related to the microwave door being open or closed.\n            - The clock region has states for the clock being in a ticking or flashing state.\n            - The light region controls the light inside the microwave, turning on when the door is opened.\n            - The oven light region controls the oven's cavity light.\n            - The magnetron region controls the state of the microwave's magnetron, responsible for generating the microwaves.\n            - The turntable region manages the rotation of the turntable inside the microwave.\n            - The exhaust fan region handles the operation of the exhaust fan at different speeds.\n            Transitions between states are defined for each region, dictated by events that trigger these state changes. Guards can be applied on transitions to add conditions for the transition to occur.\n\n    Note:\n        sf abbreviates the module used for creating the state machine framework, which is not defined in this docstring.\n\n    \"\"\"\n\n    time: datetime = datetime.fromisoformat(\"2021-01-01T00:00:00\")\n    cook_time: timedelta = None\n\n    @sf.decorators.call_event\n    async def power_on(self):\n        \"\"\"\n        Asynchronously powers on the system or device linked to the class instance.\n        This method is designed to be triggered as an event, indicated by the `call_event` decorator. It performs the necessary actions to initiate the power-on process but contains no implementation within the definition provided.\n\n        Raises:\n            This method is not documented to raise any exceptions, but since it is a placeholder, exceptions could be raised in concrete implementations depending on the actions performed while powering on the system.\n\n        Returns:\n            The return value is not specified in this context, as the implementation of the method is yet to be defined. It is expected to return a value, typically a coroutine or a future, that the async event loop can await, or it might simply execute an action without returning anything if the power on operation is instantaneous.\n\n        \"\"\"\n        pass\n\n    @sf.decorators.call_event\n    async def power_off(self):\n        \"\"\"\n        Asynchronously powers off a device or system.\n        This method serves as an event trigger for initiating a shutdown sequence.\n        It is adorned with a decorator indicating that it is meant to be treated\n        as a callable event within the system. The exact side-effects are determined by\n        the underlying implementation which should be designed to perform the\n        shutdown process asynchronously.\n        The function is a coroutine, it must be awaited when invoked, and it\n        may need to be called as part of an event loop in asynchronous workflows.\n        No arguments are required or processed, and the method does not return any value.\n        Since this function does not take any parameters and does not provide a return\n        value, the primary use-case is to signal other parts of the application that a\n        power off event is requested, upon which those parts can take the necessary\n        shutdown or cleanup actions.\n\n        \"\"\"\n        pass\n\n    class door(sf.Region):\n        \"\"\"\n        A class representing the door state within the microwave state machine.\n\n        Attributes:\n            initial:\n                 The initial state which is set to 'closed' when the microwave's door state machine is initiated.\n            States:\n            open:\n                 A state representing the door being open.\n            closed:\n                 A state representing the door being closed.\n            Transitions:\n            A collection of transitions that define the change of states:\n                - When a `DoorCloseEvent` occurs, the door transitions from the 'open' state to the 'closed' state.\n                - When a `DoorOpenEvent` occurs, the door transitions from the 'closed' state to the 'open' state.\n\n        \"\"\"\n        class open(sf.State):\n            \"\"\"\n            A class representing an open state within a state machine.\n            This class inherits from State (`sf.State`) and is used to represent a state that is considered 'open'. Typically, this would imply that the state\n            allows for certain operations to occur that may not be permissible in other states. As a subclass of `sf.State`, instances of `open` will have all the methods and attributes provided by the parent class. It serves as a template for creating more specific open states that would inherit from this class, providing a clear indication of their functionality within the system.\n\n            Attributes:\n                Inherits all attributes from the parent class `sf.State`.\n\n            Methods:\n                Inherits all methods from the parent class `sf.State`.\n\n            \"\"\"\n            pass\n\n        class closed(sf.State):\n            \"\"\"\n            Represents a state indicating that something is in a closed condition.\n            This class is derived from `sf.State` and typically represents a state in a\n            state machine or similar systems to indicate a closed status.\n\n            Attributes:\n                Inherits all attributes from the parent class `sf.State`.\n\n            \"\"\"\n            pass\n\n        initial = sf.initial(closed)\n        transitions = sf.collection(\n            sf.transition(DoorCloseEvent, source=open, target=closed),\n            sf.transition(DoorOpenEvent, source=closed, target=open),\n        )\n\n    class power(sf.Region):\n        \"\"\"\n        A class representing the power region of a state machine in the context of a microwave appliance.\n        This class encapsulates the states and transitions related to the power functionality of a microwave oven, and it is divided into several nested regions each representing a different aspect of the microwave's operation when powered on.\n\n        Attributes:\n            off (sf.State):\n                 A simple state representing the microwave being powered off.\n            on (sf.State):\n                 A state representing the microwave being powered on with several nested regions:\n            clock (sf.Region):\n                 A region to manage the state of the microwave's clock which can be ticking or flashing.\n            light (sf.Region):\n                 A region to manage the state of the microwave's internal light, which can be on or off.\n            oven_light (sf.Region):\n                 A region to manage the state of the oven light.\n            magnetron (sf.Region):\n                 A region to manage the state of the microwave's magnetron, responsible for heating the food.\n            turntable (sf.Region):\n                 A region that manages the state of the rotating turntable within the microwave.\n            exhaust_fan (sf.Region):\n                 A region to manage the exhaust fan's state which can vary in speed.\n\n        Methods:\n            - There are no public methods defined in the 'power' class as the functionality is encapsulated within.\n\n        \"\"\"\n        class off(sf.State):\n            \"\"\"\n            A state class representing the 'off' state, inheriting from `sf.State`.\n            This class is typically used to represent a state in a state machine where 'off' signifies\n            that a particular component, feature, or system is in an inactive or non-operational state.\n            Since it is an empty class, it serves as a placeholder or a default state with no\n            additional functionality beyond what is provided by the `sf.State` base class.\n\n            \"\"\"\n            pass\n\n        class on(sf.State):\n            \"\"\"\n            A state modeling class within a microwave oven control state machine that encapsulates several regions\n            representing different aspects of the oven's behavior when it is in the 'on' state.\n            The class defines regions for the clock, light, oven light, magnetron, turntable, and\n            exhaust fan. Each region further contains states and transitions that model the specific\n            behavior of that component.\n            The clock region transitions between ticking and flashing states, with the flashing state\n            providing on and off substates toggled every two seconds to flash the display.\n            The light region models the simple on/off behavior of the oven light based on\n            the door being open.\n            The oven light region also controls the on/off state of an additional light source within\n            the oven, possibly for internal lighting, based on external events.\n            The magnetron region models the on/off behavior of the component that generates microwaves.\n            The turntable region manages the behavior of the oven's rotating plate, allowing it to turn\n            clockwise, counter-clockwise, or to be off, with transitions based on cooking events and door status.\n            The exhaust fan region models more detailed behavior of the oven's fan, accounting for\n            multiple speed settings (low, medium, high), and transitions between these speeds or off\n            states based on events reflecting changes in fan speed or an event signaling the fan to turn off.\n            This class is expected to be used within a larger state machine framework for a microwave oven,\n            responding to various events such as clock setting, door opening or closing, cooking start, and\n            exhaust fan operation changes.\n\n            \"\"\"\n            class clock(sf.Region):\n                \"\"\"\n                A region that represents the clock functionality within a state machine context.\n                The clock has two main states, 'ticking' and 'flashing', which represent its behavior. The 'flashing' state itself\n                contains two substates, 'on' and 'off', which toggle to simulate the flashing effect of the clock display.\n                The flashing transition occurs every 2 seconds between the 'on' and 'off' states.\n\n                Attributes:\n                    ticking (sf.State):\n                         Represents the clock in a steady state, where time progresses normally.\n                    flashing (sf.State):\n                         Represents the clock display in a flashing mode, useful for indicating when the time is unset or should be set.\n                    Transitions:\n                        A transition from the 'flashing' to 'ticking' state is triggered by a ClockSetEvent. This transition sets the clock's time based on the event's time attribute.\n                        A self-transition on the 'ticking' state is set to occur every second, simulating the progression of time in this state.\n                    Entry Actions:\n                    display_time:\n                         A function called upon entering the 'on' substate of 'flashing' to display the current time.\n                    display_clear:\n                         A function called upon entering the 'off' substate of 'flashing' to clear the display or make it blank.\n\n                \"\"\"\n                class ticking(sf.State):\n                    \"\"\"\n                    A class that represents the 'ticking' state in a state machine.\n                    This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.\n\n                    Attributes:\n                        Inherited from sf.State, the attributes will depend on what is defined in the sf.State class. The 'ticking' class does not define any additional attributes.\n\n                    \"\"\"\n                    pass\n\n                class flashing(sf.State):\n                    \"\"\"\n                    A state machine class representing the flashing state of a microwave's clock.\n\n                    Attributes:\n                        on (sf.State):\n                             A nested state indicating that the microwave's clock display is on. An entry\n                            action is defined to display the current time.\n                        off (sf.State):\n                             A nested state indicating that the microwave's clock display is off. An entry\n                            action is defined to clear the display.\n                        Transitions:\n                        flashing_transitions (sf.collection):\n                             A set of transitions that toggle between the 'on' and 'off' states at a specified\n                            interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.\n\n                    \"\"\"\n                    class on(sf.State):\n                        \"\"\"\n                        Class representing the 'on' state within a state machine.\n                        This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n                        that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n                        indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n                        Attributes:\n                            entry:\n                                 A method to be executed upon entry to the 'on' state, which is defined by the\n                                display_time function.\n\n                        \"\"\"\n                        entry = sf.redefine(display_time)\n\n                    class off(sf.State):\n                        \"\"\"\n                        A state class representing the 'off' state in a state machine context.\n\n                        Attributes:\n                            entry (method):\n                                 A method that is bound to the 'entry' action of this state. It overrides the\n                                'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n                        \"\"\"\n                        entry = sf.redefine(display_clear)\n\n                    # initial = sf.initial(on)\n                    flashing_transitions = sf.collection(\n                        sf.transition(sf.after(seconds=2), source=on, target=off),\n                        sf.transition(sf.after(seconds=2), source=off, target=on),\n                    )\n\n                initial = sf.initial(flashing.off)\n                transitions = sf.collection(\n                    sf.transition(\n                        ClockSetEvent,\n                        source=flashing,\n                        target=ticking,\n                        effect=lambda self, event: setattr(\n                            self.model, \"time\", event.time\n                        ),\n                    ),\n                    sf.transition(sf.after(seconds=1), source=ticking, target=ticking),\n                )\n\n            class light(sf.Region):\n                \"\"\"\n                A region defining the behavior of the microwave's interior light.\n                The light region has two states indicating whether the light is turned off or on. Transitions between these states are based on the door events of the microwave. If the door is open, the light turns on, and it turns off when the door is closed.\n\n                Attributes:\n                    off (sf.State):\n                         The state representing the light being turned off.\n                    on (sf.State):\n                         The state representing the light being turned on.\n                    Transitions:\n                        A transition from 'off' to 'on' state guarded by the 'door_is_open' condition.\n                        A transition from 'on' to 'off' state triggered by `DoorCloseEvent`.\n\n                \"\"\"\n                class off(sf.State):\n                    \"\"\"\n                    A class representing an inactive or 'off' state within a finite state machine.\n                    This class is a simple subclass of the `sf.State` class, which is presumably a part of a state machine\n                    framework. The `off` class does not define any additional attributes or methods and serves as a\n                    placeholder for representing an 'off' state within the state machine. It can be used to signify\n                    that a particular component or system is in an inactive state.\n\n                    Attributes:\n                        Inherits all attributes from the parent `sf.State` class.\n\n                    Methods:\n                        Inherits all methods from the parent `sf.State` class, and does not override or define new ones.\n\n                    \"\"\"\n                    pass\n\n                class on(sf.State):\n                    \"\"\"\n                    A simple state class that inherits from `sf.State`.\n                    This class serves as a placeholder for a state that can be used in state machines\n                    which are based on `sf.State`. It does not provide any additional functionality\n                    to the base class and is meant to be subclassed to implement specific behavior\n                    for a state that is 'on'.\n\n\n                    \"\"\"\n                    pass\n\n                initial = sf.initial(off)\n                transitions = sf.collection(\n                    sf.transition(\n                        source=off, target=on, guard=door_is_open\n                    ),  # completion transition\n                    sf.transition(DoorCloseEvent, source=on, target=off),\n                )\n\n            class oven_light(sf.Region):\n                \"\"\"\n                A class representing the oven light region within the state machine, with two possible states: 'on' and 'off'.\n                The class models the oven light's behavior through two states indicating whether the oven light is\n                turned on or turned off. It starts in the 'off' state as indicated by the 'initial' configuration.\n                The transitions between the states are triggered by events. The light turns 'on' when the\n                OvenLightOnEvent occurs and returns to 'off' when the OvenLightOffEvent occurs.\n\n                Attributes:\n                    None explicitly declared in this class.\n\n                Methods:\n                    None explicitly declared in this class. The state behavior and transitions are managed by the\n                    state machine framework.\n\n                \"\"\"\n                class on(sf.State):\n                    \"\"\"\n                    A class that represents an 'on' state within a state machine framework.\n                    This class is a subclass of the 'sf.State' class and is designed to represent\n                    a specific state, presumably the 'on' state. As such, it encapsulates\n                    all functionality and characteristics pertinent to this state within the\n                    state machine's context. The class by itself does not provide any additional\n                    behavior or properties over its superclass but serves as a placeholder or\n                    an identifier for the 'on' state within the system it is used.\n\n                    Attributes:\n                        Inherited from sf.State:\n                             Refer to the superclass 'sf.State' documentation for inherited attributes.\n\n                    Methods:\n                        Inherited from sf.State:\n                             Refer to the superclass 'sf.State' documentation for inherited methods.\n\n                    \"\"\"\n                    pass\n\n                class off(sf.State):\n                    \"\"\"\n                    A class representing an 'off' state within a state machine framework.\n                    This class is a simple subclass of the `sf.State` class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from `sf.State`, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.\n\n                    Attributes:\n                        Inherits all attributes from the parent `sf.State` class.\n\n                    \"\"\"\n                    pass\n\n                initial = sf.initial(off)\n                transitions = sf.collection(\n                    sf.transition(OvenLightOnEvent, source=off, target=on),\n                    sf.transition(\n                        OvenLightOffEvent,\n                        source=on,\n                        target=off,\n                    ),\n                )\n\n            # class cooking(sf.Region):\n            class magnetron(sf.Region):\n                \"\"\"\n                A class representing the magnetron region within a larger state machine, presumably for modeling the behavior of a microwave's magnetron.\n                The magnetron class is derived from a region of a state machine and contains two basic states: 'on' and 'off'. The 'initial' static method designates the 'off' state as the initial state of this region.\n\n                Attributes:\n                    off (State):\n                         Represents the magnetron being turned off.\n                    on (State):\n                         Represents the magnetron being turned on.\n\n                Methods:\n                    initial():\n                         Static method that sets the initial state of the magnetron region to the 'off' state.\n\n                \"\"\"\n                off = sf.simple_state(\"off\")\n                on = sf.simple_state(\"on\")\n\n                initial = sf.initial(off)\n\n            class turntable(sf.Region):\n                \"\"\"\n                A class representing the turntable region within the Microwave's state machine.\n                This region models the behavior of the microwave's turntable, which can either be in a rotating or an off state.\n\n                Attributes:\n                    None\n\n                Methods:\n                    None\n                    States:\n                    rotating:\n                         State\n                        Represents the state where the turntable is rotating. It has\n                    two substates:\n                    - clockwise:\n                         State\n                        Represents the turntable rotating in a clockwise direction.\n                    - counterclockwise:\n                         State\n                        Represents the turntable rotating in a counterclockwise direction.\n                        The initial state when the turntable is rotating is set to 'clockwise'.\n                    off:\n                         State\n                        Represents the state where the turntable is not rotating (i.e., off).\n                        This is also the initial state of the turntable region when the microwave is not in use.\n                    Transitions:\n                        - A transition from the 'off' state to the 'rotating' state occurs when a CookStartEvent is triggered.\n                        - A transition from the 'rotating' state to the 'off' state occurs when a guard condition 'door_is_open' is met.\n\n                \"\"\"\n                class rotating(sf.State):\n                    \"\"\"\n                    A state object representing the rotating state of a component, such as a turntable in a microwave.\n\n                    Attributes:\n                        clockwise (sf.State):\n                             A nested state indicating that the component is rotating in the clockwise direction.\n                        counterclockwise (sf.State):\n                             A nested state indicating that the component is rotating in the counterclockwise direction.\n                            This class also defines the initial starting state for the rotating state which is set to 'clockwise'.\n\n                    \"\"\"\n                    class clockwise(sf.State):\n                        \"\"\"\n                        A class that represents a 'clockwise' state in a state machine.\n                        This class is derived from the 'sf.State' class and is intended to represent a\n                        state within a state machine that signifies a 'clockwise' movement or transition.\n                        The class does not provide any additional methods or attributes and serves as a\n                        placeholder for a specific state category in the context of the state machine.\n\n                        Attributes:\n                            Inherits all attributes from the 'sf.State' class.\n\n                        \"\"\"\n                        pass\n\n                    class counterclockwise(sf.State):\n                        \"\"\"\n                        A class representing a state in which an object or a system operates in a counterclockwise direction.\n                        This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n                        Attributes:\n                            Inherits all attributes from the superclass 'sf.State'.\n\n                        Methods:\n                            Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n                        \"\"\"\n                        pass\n\n                    initial = sf.initial(clockwise)\n\n                class off(sf.State):\n                    \"\"\"\n                    A placeholder state class that inherits from `sf.State` with no additional functionality.\n                    This class represents a state that can be used in state machines derived from the `sf.State` base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.\n\n                    Attributes:\n                        Inherits all attributes from the parent class `sf.State`.\n\n                    Methods:\n                        Inherits all methods from the parent class `sf.State`.\n\n                    \"\"\"\n                    pass\n\n                initial = sf.initial(off)\n                transitions = sf.collection(\n                    sf.transition(CookStartEvent, source=off, target=rotating),\n                    sf.transition(source=rotating, target=off, guard=door_is_open),\n                )\n\n            class exhaust_fan(sf.Region):\n                \"\"\"\n                A class that defines the behavior of the exhaust fan within a state machine context.\n                The `exhaust_fan` class inherits from `sf.Region` and specifies the different states that an exhaust fan can be in, as well as the transitions between these states. It includes mechanisms to handle events that change the exhaust fan's speed.\n\n                Attributes:\n                    speed_choice (sf.Choice):\n                         A state choice mechanism to determine the next state of the fan based on the event guard conditions.\n                    off (sf.SimpleState):\n                         A simple state representing the fan being off.\n                    initial (sf.Initial):\n                         Identifies the initial state of the fan as being on with low speed.\n                    transition_to_off (sf.Transition):\n                         Defines the transition from any `on` state to the `off` state on receiving an `ExhaustFanOffEvent`.\n                    transition_to_fan_on (sf.Transition):\n                         Defines transitions to the `speed_choice` based on an `ExhaustFanOnEvent`.\n                        The `on` inner class represents the fan being on with nested states for low, medium, and high speeds. Each nested state is also a `sf.SimpleState`. The `speed_choice` mechanism selects the appropriate speed state based on guard conditions defined in the `speed_is_high` and `speed_is_medium` methods.\n\n                Methods:\n                    speed_is_high(self, event:\n                         ExhaustFanOnEvent) -&gt; bool:\n                        A guard function that determines if the fan speed should be high.\n                    speed_is_medium(self, event:\n                         ExhaustFanOnEvent) -&gt; bool:\n                        A guard function that determines if the fan speed should be medium.\n\n                \"\"\"\n                def speed_is_high(self, event: ExhaustFanOnEvent) -&gt; bool:\n                    \"\"\"\n                    Determines if the exhaust fan's speed is at a high level.\n                    Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.\n\n                    Args:\n                        event (ExhaustFanOnEvent):\n                             The event object that includes the current speed of the exhaust fan.\n\n                    Returns:\n                        (bool):\n                             True if the fan's speed is high (speed equals 3), False otherwise.\n\n                    \"\"\"\n                    return event.speed == 3\n\n                def speed_is_medium(self, event: ExhaustFanOnEvent) -&gt; bool:\n                    \"\"\"\n                    Determines if the exhaust fan is operating at medium speed.\n                    Checks the speed attribute of the given ExhaustFanOnEvent object to determine\n                    if the exhaust fan is running at medium speed, which is defined by the speed\n                    attribute being equal to 2.\n\n                    Args:\n                        event (ExhaustFanOnEvent):\n                             An event object containing the exhaust fan's\n                            current status and properties.\n\n                    Returns:\n                        (bool):\n                             True if the fan's speed is medium, i.e., when speed attribute equals\n                            2; otherwise, False.\n\n\n                    \"\"\"\n                    return event.speed == 2\n\n                class on(sf.State):\n                    \"\"\"\n                    A class representing the 'on' state within a state machine context.\n                    This class is a subclass of `sf.State` and defines three nested states to represent\n                    the speed of an exhaust fan when the microwave is operating. The nested states are defined\n                    as simple states using the StateFlow (`sf`) library.\n\n                    Attributes:\n                        low (sf.State):\n                             Represents the low-speed state of the exhaust fan.\n                        medium (sf.State):\n                             Represents the medium-speed state of the exhaust fan.\n                        high (sf.State):\n                             Represents the high-speed state of the exhaust fan.\n                            The class does not provide methods but serves as a container for the nested\n                            states that represent different operational speeds of an exhaust fan component within\n                            the broader context of a microwave's functioning state machine.\n\n                    \"\"\"\n                    low = sf.simple_state(\"low\")\n                    medium = sf.simple_state(\"medium\")\n                    high = sf.simple_state(\"high\")\n\n                speed_choice = sf.choice(\n                    sf.transition(target=on.high, guard=speed_is_high),\n                    sf.transition(target=on.medium, guard=speed_is_medium),\n                    sf.transition(target=on.low),\n                )\n\n                off = sf.simple_state(\"off\")\n\n                initial = sf.initial(on.low)\n                transition_to_off = sf.transition(\n                    ExhaustFanOffEvent, source=on, target=off\n                )\n\n                # Transitioning to fan speed choice\n                transition_to_fan_on = sf.transition(\n                    ExhaustFanOnEvent,\n                    source=(off, on),\n                    target=speed_choice,\n                )\n\n        initial = sf.initial(on)\n\n    transitions = sf.collection(\n        sf.transition(power_on, source=power.off, target=power.on),\n        sf.transition(power_off, source=power.on, target=power.off),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.door","title":"<code>door</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class representing the door state within the microwave state machine.</p> <p>Attributes:</p> Name Type Description <code>initial</code> <p>The initial state which is set to 'closed' when the microwave's door state machine is initiated.</p> <code>States</code> <code>open</code> <p>A state representing the door being open.</p> <code>closed</code> <p>A state representing the door being closed.</p> <code>Transitions</code> <code>A</code> <code>collection of transitions that define the change of states</code> <ul> <li>When a <code>DoorCloseEvent</code> occurs, the door transitions from the 'open' state to the 'closed' state.</li> <li>When a <code>DoorOpenEvent</code> occurs, the door transitions from the 'closed' state to the 'open' state.</li> </ul> Source code in <code>examples/microwave.py</code> <pre><code>class door(sf.Region):\n    \"\"\"\n    A class representing the door state within the microwave state machine.\n\n    Attributes:\n        initial:\n             The initial state which is set to 'closed' when the microwave's door state machine is initiated.\n        States:\n        open:\n             A state representing the door being open.\n        closed:\n             A state representing the door being closed.\n        Transitions:\n        A collection of transitions that define the change of states:\n            - When a `DoorCloseEvent` occurs, the door transitions from the 'open' state to the 'closed' state.\n            - When a `DoorOpenEvent` occurs, the door transitions from the 'closed' state to the 'open' state.\n\n    \"\"\"\n    class open(sf.State):\n        \"\"\"\n        A class representing an open state within a state machine.\n        This class inherits from State (`sf.State`) and is used to represent a state that is considered 'open'. Typically, this would imply that the state\n        allows for certain operations to occur that may not be permissible in other states. As a subclass of `sf.State`, instances of `open` will have all the methods and attributes provided by the parent class. It serves as a template for creating more specific open states that would inherit from this class, providing a clear indication of their functionality within the system.\n\n        Attributes:\n            Inherits all attributes from the parent class `sf.State`.\n\n        Methods:\n            Inherits all methods from the parent class `sf.State`.\n\n        \"\"\"\n        pass\n\n    class closed(sf.State):\n        \"\"\"\n        Represents a state indicating that something is in a closed condition.\n        This class is derived from `sf.State` and typically represents a state in a\n        state machine or similar systems to indicate a closed status.\n\n        Attributes:\n            Inherits all attributes from the parent class `sf.State`.\n\n        \"\"\"\n        pass\n\n    initial = sf.initial(closed)\n    transitions = sf.collection(\n        sf.transition(DoorCloseEvent, source=open, target=closed),\n        sf.transition(DoorOpenEvent, source=closed, target=open),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.door.closed","title":"<code>closed</code>","text":"<p>             Bases: <code>State</code></p> <p>Represents a state indicating that something is in a closed condition. This class is derived from <code>sf.State</code> and typically represents a state in a state machine or similar systems to indicate a closed status.</p> Source code in <code>examples/microwave.py</code> <pre><code>class closed(sf.State):\n    \"\"\"\n    Represents a state indicating that something is in a closed condition.\n    This class is derived from `sf.State` and typically represents a state in a\n    state machine or similar systems to indicate a closed status.\n\n    Attributes:\n        Inherits all attributes from the parent class `sf.State`.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.door.open","title":"<code>open</code>","text":"<p>             Bases: <code>State</code></p> <p>A class representing an open state within a state machine. This class inherits from State (<code>sf.State</code>) and is used to represent a state that is considered 'open'. Typically, this would imply that the state allows for certain operations to occur that may not be permissible in other states. As a subclass of <code>sf.State</code>, instances of <code>open</code> will have all the methods and attributes provided by the parent class. It serves as a template for creating more specific open states that would inherit from this class, providing a clear indication of their functionality within the system.</p> Source code in <code>examples/microwave.py</code> <pre><code>class open(sf.State):\n    \"\"\"\n    A class representing an open state within a state machine.\n    This class inherits from State (`sf.State`) and is used to represent a state that is considered 'open'. Typically, this would imply that the state\n    allows for certain operations to occur that may not be permissible in other states. As a subclass of `sf.State`, instances of `open` will have all the methods and attributes provided by the parent class. It serves as a template for creating more specific open states that would inherit from this class, providing a clear indication of their functionality within the system.\n\n    Attributes:\n        Inherits all attributes from the parent class `sf.State`.\n\n    Methods:\n        Inherits all methods from the parent class `sf.State`.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power","title":"<code>power</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class representing the power region of a state machine in the context of a microwave appliance. This class encapsulates the states and transitions related to the power functionality of a microwave oven, and it is divided into several nested regions each representing a different aspect of the microwave's operation when powered on.</p> <p>Attributes:</p> Name Type Description <code>off</code> <code>State</code> <p>A simple state representing the microwave being powered off.</p> <code>on</code> <code>State</code> <p>A state representing the microwave being powered on with several nested regions:</p> <code>clock</code> <code>Region</code> <p>A region to manage the state of the microwave's clock which can be ticking or flashing.</p> <code>light</code> <code>Region</code> <p>A region to manage the state of the microwave's internal light, which can be on or off.</p> <code>oven_light</code> <code>Region</code> <p>A region to manage the state of the oven light.</p> <code>magnetron</code> <code>Region</code> <p>A region to manage the state of the microwave's magnetron, responsible for heating the food.</p> <code>turntable</code> <code>Region</code> <p>A region that manages the state of the rotating turntable within the microwave.</p> <code>exhaust_fan</code> <code>Region</code> <p>A region to manage the exhaust fan's state which can vary in speed.</p> Source code in <code>examples/microwave.py</code> <pre><code>class power(sf.Region):\n    \"\"\"\n    A class representing the power region of a state machine in the context of a microwave appliance.\n    This class encapsulates the states and transitions related to the power functionality of a microwave oven, and it is divided into several nested regions each representing a different aspect of the microwave's operation when powered on.\n\n    Attributes:\n        off (sf.State):\n             A simple state representing the microwave being powered off.\n        on (sf.State):\n             A state representing the microwave being powered on with several nested regions:\n        clock (sf.Region):\n             A region to manage the state of the microwave's clock which can be ticking or flashing.\n        light (sf.Region):\n             A region to manage the state of the microwave's internal light, which can be on or off.\n        oven_light (sf.Region):\n             A region to manage the state of the oven light.\n        magnetron (sf.Region):\n             A region to manage the state of the microwave's magnetron, responsible for heating the food.\n        turntable (sf.Region):\n             A region that manages the state of the rotating turntable within the microwave.\n        exhaust_fan (sf.Region):\n             A region to manage the exhaust fan's state which can vary in speed.\n\n    Methods:\n        - There are no public methods defined in the 'power' class as the functionality is encapsulated within.\n\n    \"\"\"\n    class off(sf.State):\n        \"\"\"\n        A state class representing the 'off' state, inheriting from `sf.State`.\n        This class is typically used to represent a state in a state machine where 'off' signifies\n        that a particular component, feature, or system is in an inactive or non-operational state.\n        Since it is an empty class, it serves as a placeholder or a default state with no\n        additional functionality beyond what is provided by the `sf.State` base class.\n\n        \"\"\"\n        pass\n\n    class on(sf.State):\n        \"\"\"\n        A state modeling class within a microwave oven control state machine that encapsulates several regions\n        representing different aspects of the oven's behavior when it is in the 'on' state.\n        The class defines regions for the clock, light, oven light, magnetron, turntable, and\n        exhaust fan. Each region further contains states and transitions that model the specific\n        behavior of that component.\n        The clock region transitions between ticking and flashing states, with the flashing state\n        providing on and off substates toggled every two seconds to flash the display.\n        The light region models the simple on/off behavior of the oven light based on\n        the door being open.\n        The oven light region also controls the on/off state of an additional light source within\n        the oven, possibly for internal lighting, based on external events.\n        The magnetron region models the on/off behavior of the component that generates microwaves.\n        The turntable region manages the behavior of the oven's rotating plate, allowing it to turn\n        clockwise, counter-clockwise, or to be off, with transitions based on cooking events and door status.\n        The exhaust fan region models more detailed behavior of the oven's fan, accounting for\n        multiple speed settings (low, medium, high), and transitions between these speeds or off\n        states based on events reflecting changes in fan speed or an event signaling the fan to turn off.\n        This class is expected to be used within a larger state machine framework for a microwave oven,\n        responding to various events such as clock setting, door opening or closing, cooking start, and\n        exhaust fan operation changes.\n\n        \"\"\"\n        class clock(sf.Region):\n            \"\"\"\n            A region that represents the clock functionality within a state machine context.\n            The clock has two main states, 'ticking' and 'flashing', which represent its behavior. The 'flashing' state itself\n            contains two substates, 'on' and 'off', which toggle to simulate the flashing effect of the clock display.\n            The flashing transition occurs every 2 seconds between the 'on' and 'off' states.\n\n            Attributes:\n                ticking (sf.State):\n                     Represents the clock in a steady state, where time progresses normally.\n                flashing (sf.State):\n                     Represents the clock display in a flashing mode, useful for indicating when the time is unset or should be set.\n                Transitions:\n                    A transition from the 'flashing' to 'ticking' state is triggered by a ClockSetEvent. This transition sets the clock's time based on the event's time attribute.\n                    A self-transition on the 'ticking' state is set to occur every second, simulating the progression of time in this state.\n                Entry Actions:\n                display_time:\n                     A function called upon entering the 'on' substate of 'flashing' to display the current time.\n                display_clear:\n                     A function called upon entering the 'off' substate of 'flashing' to clear the display or make it blank.\n\n            \"\"\"\n            class ticking(sf.State):\n                \"\"\"\n                A class that represents the 'ticking' state in a state machine.\n                This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.\n\n                Attributes:\n                    Inherited from sf.State, the attributes will depend on what is defined in the sf.State class. The 'ticking' class does not define any additional attributes.\n\n                \"\"\"\n                pass\n\n            class flashing(sf.State):\n                \"\"\"\n                A state machine class representing the flashing state of a microwave's clock.\n\n                Attributes:\n                    on (sf.State):\n                         A nested state indicating that the microwave's clock display is on. An entry\n                        action is defined to display the current time.\n                    off (sf.State):\n                         A nested state indicating that the microwave's clock display is off. An entry\n                        action is defined to clear the display.\n                    Transitions:\n                    flashing_transitions (sf.collection):\n                         A set of transitions that toggle between the 'on' and 'off' states at a specified\n                        interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.\n\n                \"\"\"\n                class on(sf.State):\n                    \"\"\"\n                    Class representing the 'on' state within a state machine.\n                    This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n                    that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n                    indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n                    Attributes:\n                        entry:\n                             A method to be executed upon entry to the 'on' state, which is defined by the\n                            display_time function.\n\n                    \"\"\"\n                    entry = sf.redefine(display_time)\n\n                class off(sf.State):\n                    \"\"\"\n                    A state class representing the 'off' state in a state machine context.\n\n                    Attributes:\n                        entry (method):\n                             A method that is bound to the 'entry' action of this state. It overrides the\n                            'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n                    \"\"\"\n                    entry = sf.redefine(display_clear)\n\n                # initial = sf.initial(on)\n                flashing_transitions = sf.collection(\n                    sf.transition(sf.after(seconds=2), source=on, target=off),\n                    sf.transition(sf.after(seconds=2), source=off, target=on),\n                )\n\n            initial = sf.initial(flashing.off)\n            transitions = sf.collection(\n                sf.transition(\n                    ClockSetEvent,\n                    source=flashing,\n                    target=ticking,\n                    effect=lambda self, event: setattr(\n                        self.model, \"time\", event.time\n                    ),\n                ),\n                sf.transition(sf.after(seconds=1), source=ticking, target=ticking),\n            )\n\n        class light(sf.Region):\n            \"\"\"\n            A region defining the behavior of the microwave's interior light.\n            The light region has two states indicating whether the light is turned off or on. Transitions between these states are based on the door events of the microwave. If the door is open, the light turns on, and it turns off when the door is closed.\n\n            Attributes:\n                off (sf.State):\n                     The state representing the light being turned off.\n                on (sf.State):\n                     The state representing the light being turned on.\n                Transitions:\n                    A transition from 'off' to 'on' state guarded by the 'door_is_open' condition.\n                    A transition from 'on' to 'off' state triggered by `DoorCloseEvent`.\n\n            \"\"\"\n            class off(sf.State):\n                \"\"\"\n                A class representing an inactive or 'off' state within a finite state machine.\n                This class is a simple subclass of the `sf.State` class, which is presumably a part of a state machine\n                framework. The `off` class does not define any additional attributes or methods and serves as a\n                placeholder for representing an 'off' state within the state machine. It can be used to signify\n                that a particular component or system is in an inactive state.\n\n                Attributes:\n                    Inherits all attributes from the parent `sf.State` class.\n\n                Methods:\n                    Inherits all methods from the parent `sf.State` class, and does not override or define new ones.\n\n                \"\"\"\n                pass\n\n            class on(sf.State):\n                \"\"\"\n                A simple state class that inherits from `sf.State`.\n                This class serves as a placeholder for a state that can be used in state machines\n                which are based on `sf.State`. It does not provide any additional functionality\n                to the base class and is meant to be subclassed to implement specific behavior\n                for a state that is 'on'.\n\n\n                \"\"\"\n                pass\n\n            initial = sf.initial(off)\n            transitions = sf.collection(\n                sf.transition(\n                    source=off, target=on, guard=door_is_open\n                ),  # completion transition\n                sf.transition(DoorCloseEvent, source=on, target=off),\n            )\n\n        class oven_light(sf.Region):\n            \"\"\"\n            A class representing the oven light region within the state machine, with two possible states: 'on' and 'off'.\n            The class models the oven light's behavior through two states indicating whether the oven light is\n            turned on or turned off. It starts in the 'off' state as indicated by the 'initial' configuration.\n            The transitions between the states are triggered by events. The light turns 'on' when the\n            OvenLightOnEvent occurs and returns to 'off' when the OvenLightOffEvent occurs.\n\n            Attributes:\n                None explicitly declared in this class.\n\n            Methods:\n                None explicitly declared in this class. The state behavior and transitions are managed by the\n                state machine framework.\n\n            \"\"\"\n            class on(sf.State):\n                \"\"\"\n                A class that represents an 'on' state within a state machine framework.\n                This class is a subclass of the 'sf.State' class and is designed to represent\n                a specific state, presumably the 'on' state. As such, it encapsulates\n                all functionality and characteristics pertinent to this state within the\n                state machine's context. The class by itself does not provide any additional\n                behavior or properties over its superclass but serves as a placeholder or\n                an identifier for the 'on' state within the system it is used.\n\n                Attributes:\n                    Inherited from sf.State:\n                         Refer to the superclass 'sf.State' documentation for inherited attributes.\n\n                Methods:\n                    Inherited from sf.State:\n                         Refer to the superclass 'sf.State' documentation for inherited methods.\n\n                \"\"\"\n                pass\n\n            class off(sf.State):\n                \"\"\"\n                A class representing an 'off' state within a state machine framework.\n                This class is a simple subclass of the `sf.State` class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from `sf.State`, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.\n\n                Attributes:\n                    Inherits all attributes from the parent `sf.State` class.\n\n                \"\"\"\n                pass\n\n            initial = sf.initial(off)\n            transitions = sf.collection(\n                sf.transition(OvenLightOnEvent, source=off, target=on),\n                sf.transition(\n                    OvenLightOffEvent,\n                    source=on,\n                    target=off,\n                ),\n            )\n\n        # class cooking(sf.Region):\n        class magnetron(sf.Region):\n            \"\"\"\n            A class representing the magnetron region within a larger state machine, presumably for modeling the behavior of a microwave's magnetron.\n            The magnetron class is derived from a region of a state machine and contains two basic states: 'on' and 'off'. The 'initial' static method designates the 'off' state as the initial state of this region.\n\n            Attributes:\n                off (State):\n                     Represents the magnetron being turned off.\n                on (State):\n                     Represents the magnetron being turned on.\n\n            Methods:\n                initial():\n                     Static method that sets the initial state of the magnetron region to the 'off' state.\n\n            \"\"\"\n            off = sf.simple_state(\"off\")\n            on = sf.simple_state(\"on\")\n\n            initial = sf.initial(off)\n\n        class turntable(sf.Region):\n            \"\"\"\n            A class representing the turntable region within the Microwave's state machine.\n            This region models the behavior of the microwave's turntable, which can either be in a rotating or an off state.\n\n            Attributes:\n                None\n\n            Methods:\n                None\n                States:\n                rotating:\n                     State\n                    Represents the state where the turntable is rotating. It has\n                two substates:\n                - clockwise:\n                     State\n                    Represents the turntable rotating in a clockwise direction.\n                - counterclockwise:\n                     State\n                    Represents the turntable rotating in a counterclockwise direction.\n                    The initial state when the turntable is rotating is set to 'clockwise'.\n                off:\n                     State\n                    Represents the state where the turntable is not rotating (i.e., off).\n                    This is also the initial state of the turntable region when the microwave is not in use.\n                Transitions:\n                    - A transition from the 'off' state to the 'rotating' state occurs when a CookStartEvent is triggered.\n                    - A transition from the 'rotating' state to the 'off' state occurs when a guard condition 'door_is_open' is met.\n\n            \"\"\"\n            class rotating(sf.State):\n                \"\"\"\n                A state object representing the rotating state of a component, such as a turntable in a microwave.\n\n                Attributes:\n                    clockwise (sf.State):\n                         A nested state indicating that the component is rotating in the clockwise direction.\n                    counterclockwise (sf.State):\n                         A nested state indicating that the component is rotating in the counterclockwise direction.\n                        This class also defines the initial starting state for the rotating state which is set to 'clockwise'.\n\n                \"\"\"\n                class clockwise(sf.State):\n                    \"\"\"\n                    A class that represents a 'clockwise' state in a state machine.\n                    This class is derived from the 'sf.State' class and is intended to represent a\n                    state within a state machine that signifies a 'clockwise' movement or transition.\n                    The class does not provide any additional methods or attributes and serves as a\n                    placeholder for a specific state category in the context of the state machine.\n\n                    Attributes:\n                        Inherits all attributes from the 'sf.State' class.\n\n                    \"\"\"\n                    pass\n\n                class counterclockwise(sf.State):\n                    \"\"\"\n                    A class representing a state in which an object or a system operates in a counterclockwise direction.\n                    This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n                    Attributes:\n                        Inherits all attributes from the superclass 'sf.State'.\n\n                    Methods:\n                        Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n                    \"\"\"\n                    pass\n\n                initial = sf.initial(clockwise)\n\n            class off(sf.State):\n                \"\"\"\n                A placeholder state class that inherits from `sf.State` with no additional functionality.\n                This class represents a state that can be used in state machines derived from the `sf.State` base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.\n\n                Attributes:\n                    Inherits all attributes from the parent class `sf.State`.\n\n                Methods:\n                    Inherits all methods from the parent class `sf.State`.\n\n                \"\"\"\n                pass\n\n            initial = sf.initial(off)\n            transitions = sf.collection(\n                sf.transition(CookStartEvent, source=off, target=rotating),\n                sf.transition(source=rotating, target=off, guard=door_is_open),\n            )\n\n        class exhaust_fan(sf.Region):\n            \"\"\"\n            A class that defines the behavior of the exhaust fan within a state machine context.\n            The `exhaust_fan` class inherits from `sf.Region` and specifies the different states that an exhaust fan can be in, as well as the transitions between these states. It includes mechanisms to handle events that change the exhaust fan's speed.\n\n            Attributes:\n                speed_choice (sf.Choice):\n                     A state choice mechanism to determine the next state of the fan based on the event guard conditions.\n                off (sf.SimpleState):\n                     A simple state representing the fan being off.\n                initial (sf.Initial):\n                     Identifies the initial state of the fan as being on with low speed.\n                transition_to_off (sf.Transition):\n                     Defines the transition from any `on` state to the `off` state on receiving an `ExhaustFanOffEvent`.\n                transition_to_fan_on (sf.Transition):\n                     Defines transitions to the `speed_choice` based on an `ExhaustFanOnEvent`.\n                    The `on` inner class represents the fan being on with nested states for low, medium, and high speeds. Each nested state is also a `sf.SimpleState`. The `speed_choice` mechanism selects the appropriate speed state based on guard conditions defined in the `speed_is_high` and `speed_is_medium` methods.\n\n            Methods:\n                speed_is_high(self, event:\n                     ExhaustFanOnEvent) -&gt; bool:\n                    A guard function that determines if the fan speed should be high.\n                speed_is_medium(self, event:\n                     ExhaustFanOnEvent) -&gt; bool:\n                    A guard function that determines if the fan speed should be medium.\n\n            \"\"\"\n            def speed_is_high(self, event: ExhaustFanOnEvent) -&gt; bool:\n                \"\"\"\n                Determines if the exhaust fan's speed is at a high level.\n                Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.\n\n                Args:\n                    event (ExhaustFanOnEvent):\n                         The event object that includes the current speed of the exhaust fan.\n\n                Returns:\n                    (bool):\n                         True if the fan's speed is high (speed equals 3), False otherwise.\n\n                \"\"\"\n                return event.speed == 3\n\n            def speed_is_medium(self, event: ExhaustFanOnEvent) -&gt; bool:\n                \"\"\"\n                Determines if the exhaust fan is operating at medium speed.\n                Checks the speed attribute of the given ExhaustFanOnEvent object to determine\n                if the exhaust fan is running at medium speed, which is defined by the speed\n                attribute being equal to 2.\n\n                Args:\n                    event (ExhaustFanOnEvent):\n                         An event object containing the exhaust fan's\n                        current status and properties.\n\n                Returns:\n                    (bool):\n                         True if the fan's speed is medium, i.e., when speed attribute equals\n                        2; otherwise, False.\n\n\n                \"\"\"\n                return event.speed == 2\n\n            class on(sf.State):\n                \"\"\"\n                A class representing the 'on' state within a state machine context.\n                This class is a subclass of `sf.State` and defines three nested states to represent\n                the speed of an exhaust fan when the microwave is operating. The nested states are defined\n                as simple states using the StateFlow (`sf`) library.\n\n                Attributes:\n                    low (sf.State):\n                         Represents the low-speed state of the exhaust fan.\n                    medium (sf.State):\n                         Represents the medium-speed state of the exhaust fan.\n                    high (sf.State):\n                         Represents the high-speed state of the exhaust fan.\n                        The class does not provide methods but serves as a container for the nested\n                        states that represent different operational speeds of an exhaust fan component within\n                        the broader context of a microwave's functioning state machine.\n\n                \"\"\"\n                low = sf.simple_state(\"low\")\n                medium = sf.simple_state(\"medium\")\n                high = sf.simple_state(\"high\")\n\n            speed_choice = sf.choice(\n                sf.transition(target=on.high, guard=speed_is_high),\n                sf.transition(target=on.medium, guard=speed_is_medium),\n                sf.transition(target=on.low),\n            )\n\n            off = sf.simple_state(\"off\")\n\n            initial = sf.initial(on.low)\n            transition_to_off = sf.transition(\n                ExhaustFanOffEvent, source=on, target=off\n            )\n\n            # Transitioning to fan speed choice\n            transition_to_fan_on = sf.transition(\n                ExhaustFanOnEvent,\n                source=(off, on),\n                target=speed_choice,\n            )\n\n    initial = sf.initial(on)\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.off","title":"<code>off</code>","text":"<p>             Bases: <code>State</code></p> <p>A state class representing the 'off' state, inheriting from <code>sf.State</code>. This class is typically used to represent a state in a state machine where 'off' signifies that a particular component, feature, or system is in an inactive or non-operational state. Since it is an empty class, it serves as a placeholder or a default state with no additional functionality beyond what is provided by the <code>sf.State</code> base class.</p> Source code in <code>examples/microwave.py</code> <pre><code>class off(sf.State):\n    \"\"\"\n    A state class representing the 'off' state, inheriting from `sf.State`.\n    This class is typically used to represent a state in a state machine where 'off' signifies\n    that a particular component, feature, or system is in an inactive or non-operational state.\n    Since it is an empty class, it serves as a placeholder or a default state with no\n    additional functionality beyond what is provided by the `sf.State` base class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on","title":"<code>on</code>","text":"<p>             Bases: <code>State</code></p> <p>A state modeling class within a microwave oven control state machine that encapsulates several regions representing different aspects of the oven's behavior when it is in the 'on' state. The class defines regions for the clock, light, oven light, magnetron, turntable, and exhaust fan. Each region further contains states and transitions that model the specific behavior of that component. The clock region transitions between ticking and flashing states, with the flashing state providing on and off substates toggled every two seconds to flash the display. The light region models the simple on/off behavior of the oven light based on the door being open. The oven light region also controls the on/off state of an additional light source within the oven, possibly for internal lighting, based on external events. The magnetron region models the on/off behavior of the component that generates microwaves. The turntable region manages the behavior of the oven's rotating plate, allowing it to turn clockwise, counter-clockwise, or to be off, with transitions based on cooking events and door status. The exhaust fan region models more detailed behavior of the oven's fan, accounting for multiple speed settings (low, medium, high), and transitions between these speeds or off states based on events reflecting changes in fan speed or an event signaling the fan to turn off. This class is expected to be used within a larger state machine framework for a microwave oven, responding to various events such as clock setting, door opening or closing, cooking start, and exhaust fan operation changes.</p> Source code in <code>examples/microwave.py</code> <pre><code>class on(sf.State):\n    \"\"\"\n    A state modeling class within a microwave oven control state machine that encapsulates several regions\n    representing different aspects of the oven's behavior when it is in the 'on' state.\n    The class defines regions for the clock, light, oven light, magnetron, turntable, and\n    exhaust fan. Each region further contains states and transitions that model the specific\n    behavior of that component.\n    The clock region transitions between ticking and flashing states, with the flashing state\n    providing on and off substates toggled every two seconds to flash the display.\n    The light region models the simple on/off behavior of the oven light based on\n    the door being open.\n    The oven light region also controls the on/off state of an additional light source within\n    the oven, possibly for internal lighting, based on external events.\n    The magnetron region models the on/off behavior of the component that generates microwaves.\n    The turntable region manages the behavior of the oven's rotating plate, allowing it to turn\n    clockwise, counter-clockwise, or to be off, with transitions based on cooking events and door status.\n    The exhaust fan region models more detailed behavior of the oven's fan, accounting for\n    multiple speed settings (low, medium, high), and transitions between these speeds or off\n    states based on events reflecting changes in fan speed or an event signaling the fan to turn off.\n    This class is expected to be used within a larger state machine framework for a microwave oven,\n    responding to various events such as clock setting, door opening or closing, cooking start, and\n    exhaust fan operation changes.\n\n    \"\"\"\n    class clock(sf.Region):\n        \"\"\"\n        A region that represents the clock functionality within a state machine context.\n        The clock has two main states, 'ticking' and 'flashing', which represent its behavior. The 'flashing' state itself\n        contains two substates, 'on' and 'off', which toggle to simulate the flashing effect of the clock display.\n        The flashing transition occurs every 2 seconds between the 'on' and 'off' states.\n\n        Attributes:\n            ticking (sf.State):\n                 Represents the clock in a steady state, where time progresses normally.\n            flashing (sf.State):\n                 Represents the clock display in a flashing mode, useful for indicating when the time is unset or should be set.\n            Transitions:\n                A transition from the 'flashing' to 'ticking' state is triggered by a ClockSetEvent. This transition sets the clock's time based on the event's time attribute.\n                A self-transition on the 'ticking' state is set to occur every second, simulating the progression of time in this state.\n            Entry Actions:\n            display_time:\n                 A function called upon entering the 'on' substate of 'flashing' to display the current time.\n            display_clear:\n                 A function called upon entering the 'off' substate of 'flashing' to clear the display or make it blank.\n\n        \"\"\"\n        class ticking(sf.State):\n            \"\"\"\n            A class that represents the 'ticking' state in a state machine.\n            This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.\n\n            Attributes:\n                Inherited from sf.State, the attributes will depend on what is defined in the sf.State class. The 'ticking' class does not define any additional attributes.\n\n            \"\"\"\n            pass\n\n        class flashing(sf.State):\n            \"\"\"\n            A state machine class representing the flashing state of a microwave's clock.\n\n            Attributes:\n                on (sf.State):\n                     A nested state indicating that the microwave's clock display is on. An entry\n                    action is defined to display the current time.\n                off (sf.State):\n                     A nested state indicating that the microwave's clock display is off. An entry\n                    action is defined to clear the display.\n                Transitions:\n                flashing_transitions (sf.collection):\n                     A set of transitions that toggle between the 'on' and 'off' states at a specified\n                    interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.\n\n            \"\"\"\n            class on(sf.State):\n                \"\"\"\n                Class representing the 'on' state within a state machine.\n                This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n                that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n                indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n                Attributes:\n                    entry:\n                         A method to be executed upon entry to the 'on' state, which is defined by the\n                        display_time function.\n\n                \"\"\"\n                entry = sf.redefine(display_time)\n\n            class off(sf.State):\n                \"\"\"\n                A state class representing the 'off' state in a state machine context.\n\n                Attributes:\n                    entry (method):\n                         A method that is bound to the 'entry' action of this state. It overrides the\n                        'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n                \"\"\"\n                entry = sf.redefine(display_clear)\n\n            # initial = sf.initial(on)\n            flashing_transitions = sf.collection(\n                sf.transition(sf.after(seconds=2), source=on, target=off),\n                sf.transition(sf.after(seconds=2), source=off, target=on),\n            )\n\n        initial = sf.initial(flashing.off)\n        transitions = sf.collection(\n            sf.transition(\n                ClockSetEvent,\n                source=flashing,\n                target=ticking,\n                effect=lambda self, event: setattr(\n                    self.model, \"time\", event.time\n                ),\n            ),\n            sf.transition(sf.after(seconds=1), source=ticking, target=ticking),\n        )\n\n    class light(sf.Region):\n        \"\"\"\n        A region defining the behavior of the microwave's interior light.\n        The light region has two states indicating whether the light is turned off or on. Transitions between these states are based on the door events of the microwave. If the door is open, the light turns on, and it turns off when the door is closed.\n\n        Attributes:\n            off (sf.State):\n                 The state representing the light being turned off.\n            on (sf.State):\n                 The state representing the light being turned on.\n            Transitions:\n                A transition from 'off' to 'on' state guarded by the 'door_is_open' condition.\n                A transition from 'on' to 'off' state triggered by `DoorCloseEvent`.\n\n        \"\"\"\n        class off(sf.State):\n            \"\"\"\n            A class representing an inactive or 'off' state within a finite state machine.\n            This class is a simple subclass of the `sf.State` class, which is presumably a part of a state machine\n            framework. The `off` class does not define any additional attributes or methods and serves as a\n            placeholder for representing an 'off' state within the state machine. It can be used to signify\n            that a particular component or system is in an inactive state.\n\n            Attributes:\n                Inherits all attributes from the parent `sf.State` class.\n\n            Methods:\n                Inherits all methods from the parent `sf.State` class, and does not override or define new ones.\n\n            \"\"\"\n            pass\n\n        class on(sf.State):\n            \"\"\"\n            A simple state class that inherits from `sf.State`.\n            This class serves as a placeholder for a state that can be used in state machines\n            which are based on `sf.State`. It does not provide any additional functionality\n            to the base class and is meant to be subclassed to implement specific behavior\n            for a state that is 'on'.\n\n\n            \"\"\"\n            pass\n\n        initial = sf.initial(off)\n        transitions = sf.collection(\n            sf.transition(\n                source=off, target=on, guard=door_is_open\n            ),  # completion transition\n            sf.transition(DoorCloseEvent, source=on, target=off),\n        )\n\n    class oven_light(sf.Region):\n        \"\"\"\n        A class representing the oven light region within the state machine, with two possible states: 'on' and 'off'.\n        The class models the oven light's behavior through two states indicating whether the oven light is\n        turned on or turned off. It starts in the 'off' state as indicated by the 'initial' configuration.\n        The transitions between the states are triggered by events. The light turns 'on' when the\n        OvenLightOnEvent occurs and returns to 'off' when the OvenLightOffEvent occurs.\n\n        Attributes:\n            None explicitly declared in this class.\n\n        Methods:\n            None explicitly declared in this class. The state behavior and transitions are managed by the\n            state machine framework.\n\n        \"\"\"\n        class on(sf.State):\n            \"\"\"\n            A class that represents an 'on' state within a state machine framework.\n            This class is a subclass of the 'sf.State' class and is designed to represent\n            a specific state, presumably the 'on' state. As such, it encapsulates\n            all functionality and characteristics pertinent to this state within the\n            state machine's context. The class by itself does not provide any additional\n            behavior or properties over its superclass but serves as a placeholder or\n            an identifier for the 'on' state within the system it is used.\n\n            Attributes:\n                Inherited from sf.State:\n                     Refer to the superclass 'sf.State' documentation for inherited attributes.\n\n            Methods:\n                Inherited from sf.State:\n                     Refer to the superclass 'sf.State' documentation for inherited methods.\n\n            \"\"\"\n            pass\n\n        class off(sf.State):\n            \"\"\"\n            A class representing an 'off' state within a state machine framework.\n            This class is a simple subclass of the `sf.State` class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from `sf.State`, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.\n\n            Attributes:\n                Inherits all attributes from the parent `sf.State` class.\n\n            \"\"\"\n            pass\n\n        initial = sf.initial(off)\n        transitions = sf.collection(\n            sf.transition(OvenLightOnEvent, source=off, target=on),\n            sf.transition(\n                OvenLightOffEvent,\n                source=on,\n                target=off,\n            ),\n        )\n\n    # class cooking(sf.Region):\n    class magnetron(sf.Region):\n        \"\"\"\n        A class representing the magnetron region within a larger state machine, presumably for modeling the behavior of a microwave's magnetron.\n        The magnetron class is derived from a region of a state machine and contains two basic states: 'on' and 'off'. The 'initial' static method designates the 'off' state as the initial state of this region.\n\n        Attributes:\n            off (State):\n                 Represents the magnetron being turned off.\n            on (State):\n                 Represents the magnetron being turned on.\n\n        Methods:\n            initial():\n                 Static method that sets the initial state of the magnetron region to the 'off' state.\n\n        \"\"\"\n        off = sf.simple_state(\"off\")\n        on = sf.simple_state(\"on\")\n\n        initial = sf.initial(off)\n\n    class turntable(sf.Region):\n        \"\"\"\n        A class representing the turntable region within the Microwave's state machine.\n        This region models the behavior of the microwave's turntable, which can either be in a rotating or an off state.\n\n        Attributes:\n            None\n\n        Methods:\n            None\n            States:\n            rotating:\n                 State\n                Represents the state where the turntable is rotating. It has\n            two substates:\n            - clockwise:\n                 State\n                Represents the turntable rotating in a clockwise direction.\n            - counterclockwise:\n                 State\n                Represents the turntable rotating in a counterclockwise direction.\n                The initial state when the turntable is rotating is set to 'clockwise'.\n            off:\n                 State\n                Represents the state where the turntable is not rotating (i.e., off).\n                This is also the initial state of the turntable region when the microwave is not in use.\n            Transitions:\n                - A transition from the 'off' state to the 'rotating' state occurs when a CookStartEvent is triggered.\n                - A transition from the 'rotating' state to the 'off' state occurs when a guard condition 'door_is_open' is met.\n\n        \"\"\"\n        class rotating(sf.State):\n            \"\"\"\n            A state object representing the rotating state of a component, such as a turntable in a microwave.\n\n            Attributes:\n                clockwise (sf.State):\n                     A nested state indicating that the component is rotating in the clockwise direction.\n                counterclockwise (sf.State):\n                     A nested state indicating that the component is rotating in the counterclockwise direction.\n                    This class also defines the initial starting state for the rotating state which is set to 'clockwise'.\n\n            \"\"\"\n            class clockwise(sf.State):\n                \"\"\"\n                A class that represents a 'clockwise' state in a state machine.\n                This class is derived from the 'sf.State' class and is intended to represent a\n                state within a state machine that signifies a 'clockwise' movement or transition.\n                The class does not provide any additional methods or attributes and serves as a\n                placeholder for a specific state category in the context of the state machine.\n\n                Attributes:\n                    Inherits all attributes from the 'sf.State' class.\n\n                \"\"\"\n                pass\n\n            class counterclockwise(sf.State):\n                \"\"\"\n                A class representing a state in which an object or a system operates in a counterclockwise direction.\n                This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n                Attributes:\n                    Inherits all attributes from the superclass 'sf.State'.\n\n                Methods:\n                    Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n                \"\"\"\n                pass\n\n            initial = sf.initial(clockwise)\n\n        class off(sf.State):\n            \"\"\"\n            A placeholder state class that inherits from `sf.State` with no additional functionality.\n            This class represents a state that can be used in state machines derived from the `sf.State` base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.\n\n            Attributes:\n                Inherits all attributes from the parent class `sf.State`.\n\n            Methods:\n                Inherits all methods from the parent class `sf.State`.\n\n            \"\"\"\n            pass\n\n        initial = sf.initial(off)\n        transitions = sf.collection(\n            sf.transition(CookStartEvent, source=off, target=rotating),\n            sf.transition(source=rotating, target=off, guard=door_is_open),\n        )\n\n    class exhaust_fan(sf.Region):\n        \"\"\"\n        A class that defines the behavior of the exhaust fan within a state machine context.\n        The `exhaust_fan` class inherits from `sf.Region` and specifies the different states that an exhaust fan can be in, as well as the transitions between these states. It includes mechanisms to handle events that change the exhaust fan's speed.\n\n        Attributes:\n            speed_choice (sf.Choice):\n                 A state choice mechanism to determine the next state of the fan based on the event guard conditions.\n            off (sf.SimpleState):\n                 A simple state representing the fan being off.\n            initial (sf.Initial):\n                 Identifies the initial state of the fan as being on with low speed.\n            transition_to_off (sf.Transition):\n                 Defines the transition from any `on` state to the `off` state on receiving an `ExhaustFanOffEvent`.\n            transition_to_fan_on (sf.Transition):\n                 Defines transitions to the `speed_choice` based on an `ExhaustFanOnEvent`.\n                The `on` inner class represents the fan being on with nested states for low, medium, and high speeds. Each nested state is also a `sf.SimpleState`. The `speed_choice` mechanism selects the appropriate speed state based on guard conditions defined in the `speed_is_high` and `speed_is_medium` methods.\n\n        Methods:\n            speed_is_high(self, event:\n                 ExhaustFanOnEvent) -&gt; bool:\n                A guard function that determines if the fan speed should be high.\n            speed_is_medium(self, event:\n                 ExhaustFanOnEvent) -&gt; bool:\n                A guard function that determines if the fan speed should be medium.\n\n        \"\"\"\n        def speed_is_high(self, event: ExhaustFanOnEvent) -&gt; bool:\n            \"\"\"\n            Determines if the exhaust fan's speed is at a high level.\n            Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.\n\n            Args:\n                event (ExhaustFanOnEvent):\n                     The event object that includes the current speed of the exhaust fan.\n\n            Returns:\n                (bool):\n                     True if the fan's speed is high (speed equals 3), False otherwise.\n\n            \"\"\"\n            return event.speed == 3\n\n        def speed_is_medium(self, event: ExhaustFanOnEvent) -&gt; bool:\n            \"\"\"\n            Determines if the exhaust fan is operating at medium speed.\n            Checks the speed attribute of the given ExhaustFanOnEvent object to determine\n            if the exhaust fan is running at medium speed, which is defined by the speed\n            attribute being equal to 2.\n\n            Args:\n                event (ExhaustFanOnEvent):\n                     An event object containing the exhaust fan's\n                    current status and properties.\n\n            Returns:\n                (bool):\n                     True if the fan's speed is medium, i.e., when speed attribute equals\n                    2; otherwise, False.\n\n\n            \"\"\"\n            return event.speed == 2\n\n        class on(sf.State):\n            \"\"\"\n            A class representing the 'on' state within a state machine context.\n            This class is a subclass of `sf.State` and defines three nested states to represent\n            the speed of an exhaust fan when the microwave is operating. The nested states are defined\n            as simple states using the StateFlow (`sf`) library.\n\n            Attributes:\n                low (sf.State):\n                     Represents the low-speed state of the exhaust fan.\n                medium (sf.State):\n                     Represents the medium-speed state of the exhaust fan.\n                high (sf.State):\n                     Represents the high-speed state of the exhaust fan.\n                    The class does not provide methods but serves as a container for the nested\n                    states that represent different operational speeds of an exhaust fan component within\n                    the broader context of a microwave's functioning state machine.\n\n            \"\"\"\n            low = sf.simple_state(\"low\")\n            medium = sf.simple_state(\"medium\")\n            high = sf.simple_state(\"high\")\n\n        speed_choice = sf.choice(\n            sf.transition(target=on.high, guard=speed_is_high),\n            sf.transition(target=on.medium, guard=speed_is_medium),\n            sf.transition(target=on.low),\n        )\n\n        off = sf.simple_state(\"off\")\n\n        initial = sf.initial(on.low)\n        transition_to_off = sf.transition(\n            ExhaustFanOffEvent, source=on, target=off\n        )\n\n        # Transitioning to fan speed choice\n        transition_to_fan_on = sf.transition(\n            ExhaustFanOnEvent,\n            source=(off, on),\n            target=speed_choice,\n        )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.clock","title":"<code>clock</code>","text":"<p>             Bases: <code>Region</code></p> <p>A region that represents the clock functionality within a state machine context. The clock has two main states, 'ticking' and 'flashing', which represent its behavior. The 'flashing' state itself contains two substates, 'on' and 'off', which toggle to simulate the flashing effect of the clock display. The flashing transition occurs every 2 seconds between the 'on' and 'off' states.</p> <p>Attributes:</p> Name Type Description <code>ticking</code> <code>State</code> <p>Represents the clock in a steady state, where time progresses normally.</p> <code>flashing</code> <code>State</code> <p>Represents the clock display in a flashing mode, useful for indicating when the time is unset or should be set.</p> <code>Transitions</code> <code>State</code> <p>A transition from the 'flashing' to 'ticking' state is triggered by a ClockSetEvent. This transition sets the clock's time based on the event's time attribute. A self-transition on the 'ticking' state is set to occur every second, simulating the progression of time in this state.</p> <code>Entry</code> <code>Actions</code> <code>display_time</code> <code>Actions</code> <p>A function called upon entering the 'on' substate of 'flashing' to display the current time.</p> <code>display_clear</code> <code>Actions</code> <p>A function called upon entering the 'off' substate of 'flashing' to clear the display or make it blank.</p> Source code in <code>examples/microwave.py</code> <pre><code>class clock(sf.Region):\n    \"\"\"\n    A region that represents the clock functionality within a state machine context.\n    The clock has two main states, 'ticking' and 'flashing', which represent its behavior. The 'flashing' state itself\n    contains two substates, 'on' and 'off', which toggle to simulate the flashing effect of the clock display.\n    The flashing transition occurs every 2 seconds between the 'on' and 'off' states.\n\n    Attributes:\n        ticking (sf.State):\n             Represents the clock in a steady state, where time progresses normally.\n        flashing (sf.State):\n             Represents the clock display in a flashing mode, useful for indicating when the time is unset or should be set.\n        Transitions:\n            A transition from the 'flashing' to 'ticking' state is triggered by a ClockSetEvent. This transition sets the clock's time based on the event's time attribute.\n            A self-transition on the 'ticking' state is set to occur every second, simulating the progression of time in this state.\n        Entry Actions:\n        display_time:\n             A function called upon entering the 'on' substate of 'flashing' to display the current time.\n        display_clear:\n             A function called upon entering the 'off' substate of 'flashing' to clear the display or make it blank.\n\n    \"\"\"\n    class ticking(sf.State):\n        \"\"\"\n        A class that represents the 'ticking' state in a state machine.\n        This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.\n\n        Attributes:\n            Inherited from sf.State, the attributes will depend on what is defined in the sf.State class. The 'ticking' class does not define any additional attributes.\n\n        \"\"\"\n        pass\n\n    class flashing(sf.State):\n        \"\"\"\n        A state machine class representing the flashing state of a microwave's clock.\n\n        Attributes:\n            on (sf.State):\n                 A nested state indicating that the microwave's clock display is on. An entry\n                action is defined to display the current time.\n            off (sf.State):\n                 A nested state indicating that the microwave's clock display is off. An entry\n                action is defined to clear the display.\n            Transitions:\n            flashing_transitions (sf.collection):\n                 A set of transitions that toggle between the 'on' and 'off' states at a specified\n                interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.\n\n        \"\"\"\n        class on(sf.State):\n            \"\"\"\n            Class representing the 'on' state within a state machine.\n            This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n            that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n            indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n            Attributes:\n                entry:\n                     A method to be executed upon entry to the 'on' state, which is defined by the\n                    display_time function.\n\n            \"\"\"\n            entry = sf.redefine(display_time)\n\n        class off(sf.State):\n            \"\"\"\n            A state class representing the 'off' state in a state machine context.\n\n            Attributes:\n                entry (method):\n                     A method that is bound to the 'entry' action of this state. It overrides the\n                    'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n            \"\"\"\n            entry = sf.redefine(display_clear)\n\n        # initial = sf.initial(on)\n        flashing_transitions = sf.collection(\n            sf.transition(sf.after(seconds=2), source=on, target=off),\n            sf.transition(sf.after(seconds=2), source=off, target=on),\n        )\n\n    initial = sf.initial(flashing.off)\n    transitions = sf.collection(\n        sf.transition(\n            ClockSetEvent,\n            source=flashing,\n            target=ticking,\n            effect=lambda self, event: setattr(\n                self.model, \"time\", event.time\n            ),\n        ),\n        sf.transition(sf.after(seconds=1), source=ticking, target=ticking),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.clock.flashing","title":"<code>flashing</code>","text":"<p>             Bases: <code>State</code></p> <p>A state machine class representing the flashing state of a microwave's clock.</p> <p>Attributes:</p> Name Type Description <code>on</code> <code>State</code> <p>A nested state indicating that the microwave's clock display is on. An entry action is defined to display the current time.</p> <code>off</code> <code>State</code> <p>A nested state indicating that the microwave's clock display is off. An entry action is defined to clear the display.</p> <code>Transitions</code> <code>State</code> <code>flashing_transitions</code> <code>collection</code> <p>A set of transitions that toggle between the 'on' and 'off' states at a specified interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.</p> Source code in <code>examples/microwave.py</code> <pre><code>class flashing(sf.State):\n    \"\"\"\n    A state machine class representing the flashing state of a microwave's clock.\n\n    Attributes:\n        on (sf.State):\n             A nested state indicating that the microwave's clock display is on. An entry\n            action is defined to display the current time.\n        off (sf.State):\n             A nested state indicating that the microwave's clock display is off. An entry\n            action is defined to clear the display.\n        Transitions:\n        flashing_transitions (sf.collection):\n             A set of transitions that toggle between the 'on' and 'off' states at a specified\n            interval. Transitions occur after a 2-second delay, creating a blinking effect for the clock display.\n\n    \"\"\"\n    class on(sf.State):\n        \"\"\"\n        Class representing the 'on' state within a state machine.\n        This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n        that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n        indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n        Attributes:\n            entry:\n                 A method to be executed upon entry to the 'on' state, which is defined by the\n                display_time function.\n\n        \"\"\"\n        entry = sf.redefine(display_time)\n\n    class off(sf.State):\n        \"\"\"\n        A state class representing the 'off' state in a state machine context.\n\n        Attributes:\n            entry (method):\n                 A method that is bound to the 'entry' action of this state. It overrides the\n                'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n        \"\"\"\n        entry = sf.redefine(display_clear)\n\n    # initial = sf.initial(on)\n    flashing_transitions = sf.collection(\n        sf.transition(sf.after(seconds=2), source=on, target=off),\n        sf.transition(sf.after(seconds=2), source=off, target=on),\n    )\n</code></pre> <code>off</code> <p>             Bases: <code>State</code></p> <p>A state class representing the 'off' state in a state machine context.</p> <p>Attributes:</p> Name Type Description <code>entry</code> <code>method</code> <p>A method that is bound to the 'entry' action of this state. It overrides the 'display_clear' function to clear the display when the microwave enters the 'off' state.</p> Source code in <code>examples/microwave.py</code> <pre><code>class off(sf.State):\n    \"\"\"\n    A state class representing the 'off' state in a state machine context.\n\n    Attributes:\n        entry (method):\n             A method that is bound to the 'entry' action of this state. It overrides the\n            'display_clear' function to clear the display when the microwave enters the 'off' state.\n\n    \"\"\"\n    entry = sf.redefine(display_clear)\n</code></pre> <code>on</code> <p>             Bases: <code>State</code></p> <p>Class representing the 'on' state within a state machine. This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function, indicating that the current time should be displayed when the microwave is in the 'on' state.</p> <p>Attributes:</p> Name Type Description <code>entry</code> <p>A method to be executed upon entry to the 'on' state, which is defined by the display_time function.</p> Source code in <code>examples/microwave.py</code> <pre><code>class on(sf.State):\n    \"\"\"\n    Class representing the 'on' state within a state machine.\n    This class extends sf.State and has a single behavior defined by the 'entry' attribute, which is a method\n    that should be executed when entering this state. The 'entry' attribute is linked to the 'display_time' function,\n    indicating that the current time should be displayed when the microwave is in the 'on' state.\n\n    Attributes:\n        entry:\n             A method to be executed upon entry to the 'on' state, which is defined by the\n            display_time function.\n\n    \"\"\"\n    entry = sf.redefine(display_time)\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.clock.ticking","title":"<code>ticking</code>","text":"<p>             Bases: <code>State</code></p> <p>A class that represents the 'ticking' state in a state machine. This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.</p> Source code in <code>examples/microwave.py</code> <pre><code>class ticking(sf.State):\n    \"\"\"\n    A class that represents the 'ticking' state in a state machine.\n    This class inherits from the 'sf.State' which is likely a part of a state framework or library. The 'ticking' state could represent a periodic or continuous action within the state machine context. As it currently stands without additional methods or properties, it serves as a placeholder or default implementation for the 'ticking' behavior in the state machine.\n\n    Attributes:\n        Inherited from sf.State, the attributes will depend on what is defined in the sf.State class. The 'ticking' class does not define any additional attributes.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.exhaust_fan","title":"<code>exhaust_fan</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class that defines the behavior of the exhaust fan within a state machine context. The <code>exhaust_fan</code> class inherits from <code>sf.Region</code> and specifies the different states that an exhaust fan can be in, as well as the transitions between these states. It includes mechanisms to handle events that change the exhaust fan's speed.</p> <p>Attributes:</p> Name Type Description <code>speed_choice</code> <code>Choice</code> <p>A state choice mechanism to determine the next state of the fan based on the event guard conditions.</p> <code>off</code> <code>SimpleState</code> <p>A simple state representing the fan being off.</p> <code>initial</code> <code>Initial</code> <p>Identifies the initial state of the fan as being on with low speed.</p> <code>transition_to_off</code> <code>Transition</code> <p>Defines the transition from any <code>on</code> state to the <code>off</code> state on receiving an <code>ExhaustFanOffEvent</code>.</p> <code>transition_to_fan_on</code> <code>Transition</code> <p>Defines transitions to the <code>speed_choice</code> based on an <code>ExhaustFanOnEvent</code>. The <code>on</code> inner class represents the fan being on with nested states for low, medium, and high speeds. Each nested state is also a <code>sf.SimpleState</code>. The <code>speed_choice</code> mechanism selects the appropriate speed state based on guard conditions defined in the <code>speed_is_high</code> and <code>speed_is_medium</code> methods.</p> <p>Methods:</p> Name Description <code>speed_is_high</code> <p>ExhaustFanOnEvent) -&gt; bool: A guard function that determines if the fan speed should be high.</p> <code>speed_is_medium</code> <p>ExhaustFanOnEvent) -&gt; bool: A guard function that determines if the fan speed should be medium.</p> Source code in <code>examples/microwave.py</code> <pre><code>class exhaust_fan(sf.Region):\n    \"\"\"\n    A class that defines the behavior of the exhaust fan within a state machine context.\n    The `exhaust_fan` class inherits from `sf.Region` and specifies the different states that an exhaust fan can be in, as well as the transitions between these states. It includes mechanisms to handle events that change the exhaust fan's speed.\n\n    Attributes:\n        speed_choice (sf.Choice):\n             A state choice mechanism to determine the next state of the fan based on the event guard conditions.\n        off (sf.SimpleState):\n             A simple state representing the fan being off.\n        initial (sf.Initial):\n             Identifies the initial state of the fan as being on with low speed.\n        transition_to_off (sf.Transition):\n             Defines the transition from any `on` state to the `off` state on receiving an `ExhaustFanOffEvent`.\n        transition_to_fan_on (sf.Transition):\n             Defines transitions to the `speed_choice` based on an `ExhaustFanOnEvent`.\n            The `on` inner class represents the fan being on with nested states for low, medium, and high speeds. Each nested state is also a `sf.SimpleState`. The `speed_choice` mechanism selects the appropriate speed state based on guard conditions defined in the `speed_is_high` and `speed_is_medium` methods.\n\n    Methods:\n        speed_is_high(self, event:\n             ExhaustFanOnEvent) -&gt; bool:\n            A guard function that determines if the fan speed should be high.\n        speed_is_medium(self, event:\n             ExhaustFanOnEvent) -&gt; bool:\n            A guard function that determines if the fan speed should be medium.\n\n    \"\"\"\n    def speed_is_high(self, event: ExhaustFanOnEvent) -&gt; bool:\n        \"\"\"\n        Determines if the exhaust fan's speed is at a high level.\n        Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.\n\n        Args:\n            event (ExhaustFanOnEvent):\n                 The event object that includes the current speed of the exhaust fan.\n\n        Returns:\n            (bool):\n                 True if the fan's speed is high (speed equals 3), False otherwise.\n\n        \"\"\"\n        return event.speed == 3\n\n    def speed_is_medium(self, event: ExhaustFanOnEvent) -&gt; bool:\n        \"\"\"\n        Determines if the exhaust fan is operating at medium speed.\n        Checks the speed attribute of the given ExhaustFanOnEvent object to determine\n        if the exhaust fan is running at medium speed, which is defined by the speed\n        attribute being equal to 2.\n\n        Args:\n            event (ExhaustFanOnEvent):\n                 An event object containing the exhaust fan's\n                current status and properties.\n\n        Returns:\n            (bool):\n                 True if the fan's speed is medium, i.e., when speed attribute equals\n                2; otherwise, False.\n\n\n        \"\"\"\n        return event.speed == 2\n\n    class on(sf.State):\n        \"\"\"\n        A class representing the 'on' state within a state machine context.\n        This class is a subclass of `sf.State` and defines three nested states to represent\n        the speed of an exhaust fan when the microwave is operating. The nested states are defined\n        as simple states using the StateFlow (`sf`) library.\n\n        Attributes:\n            low (sf.State):\n                 Represents the low-speed state of the exhaust fan.\n            medium (sf.State):\n                 Represents the medium-speed state of the exhaust fan.\n            high (sf.State):\n                 Represents the high-speed state of the exhaust fan.\n                The class does not provide methods but serves as a container for the nested\n                states that represent different operational speeds of an exhaust fan component within\n                the broader context of a microwave's functioning state machine.\n\n        \"\"\"\n        low = sf.simple_state(\"low\")\n        medium = sf.simple_state(\"medium\")\n        high = sf.simple_state(\"high\")\n\n    speed_choice = sf.choice(\n        sf.transition(target=on.high, guard=speed_is_high),\n        sf.transition(target=on.medium, guard=speed_is_medium),\n        sf.transition(target=on.low),\n    )\n\n    off = sf.simple_state(\"off\")\n\n    initial = sf.initial(on.low)\n    transition_to_off = sf.transition(\n        ExhaustFanOffEvent, source=on, target=off\n    )\n\n    # Transitioning to fan speed choice\n    transition_to_fan_on = sf.transition(\n        ExhaustFanOnEvent,\n        source=(off, on),\n        target=speed_choice,\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.exhaust_fan.on","title":"<code>on</code>","text":"<p>             Bases: <code>State</code></p> <p>A class representing the 'on' state within a state machine context. This class is a subclass of <code>sf.State</code> and defines three nested states to represent the speed of an exhaust fan when the microwave is operating. The nested states are defined as simple states using the StateFlow (<code>sf</code>) library.</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>State</code> <p>Represents the low-speed state of the exhaust fan.</p> <code>medium</code> <code>State</code> <p>Represents the medium-speed state of the exhaust fan.</p> <code>high</code> <code>State</code> <p>Represents the high-speed state of the exhaust fan. The class does not provide methods but serves as a container for the nested states that represent different operational speeds of an exhaust fan component within the broader context of a microwave's functioning state machine.</p> Source code in <code>examples/microwave.py</code> <pre><code>class on(sf.State):\n    \"\"\"\n    A class representing the 'on' state within a state machine context.\n    This class is a subclass of `sf.State` and defines three nested states to represent\n    the speed of an exhaust fan when the microwave is operating. The nested states are defined\n    as simple states using the StateFlow (`sf`) library.\n\n    Attributes:\n        low (sf.State):\n             Represents the low-speed state of the exhaust fan.\n        medium (sf.State):\n             Represents the medium-speed state of the exhaust fan.\n        high (sf.State):\n             Represents the high-speed state of the exhaust fan.\n            The class does not provide methods but serves as a container for the nested\n            states that represent different operational speeds of an exhaust fan component within\n            the broader context of a microwave's functioning state machine.\n\n    \"\"\"\n    low = sf.simple_state(\"low\")\n    medium = sf.simple_state(\"medium\")\n    high = sf.simple_state(\"high\")\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.exhaust_fan.speed_is_high","title":"<code>speed_is_high(event)</code>","text":"<p>Determines if the exhaust fan's speed is at a high level. Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ExhaustFanOnEvent</code> <p>The event object that includes the current speed of the exhaust fan.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the fan's speed is high (speed equals 3), False otherwise.</p> Source code in <code>examples/microwave.py</code> <pre><code>def speed_is_high(self, event: ExhaustFanOnEvent) -&gt; bool:\n    \"\"\"\n    Determines if the exhaust fan's speed is at a high level.\n    Checks the speed attribute of a given ExhaustFanOnEvent instance and evaluates if it is equal to 3, indicating a high speed.\n\n    Args:\n        event (ExhaustFanOnEvent):\n             The event object that includes the current speed of the exhaust fan.\n\n    Returns:\n        (bool):\n             True if the fan's speed is high (speed equals 3), False otherwise.\n\n    \"\"\"\n    return event.speed == 3\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.exhaust_fan.speed_is_medium","title":"<code>speed_is_medium(event)</code>","text":"<p>Determines if the exhaust fan is operating at medium speed. Checks the speed attribute of the given ExhaustFanOnEvent object to determine if the exhaust fan is running at medium speed, which is defined by the speed attribute being equal to 2.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ExhaustFanOnEvent</code> <p>An event object containing the exhaust fan's current status and properties.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the fan's speed is medium, i.e., when speed attribute equals 2; otherwise, False.</p> Source code in <code>examples/microwave.py</code> <pre><code>def speed_is_medium(self, event: ExhaustFanOnEvent) -&gt; bool:\n    \"\"\"\n    Determines if the exhaust fan is operating at medium speed.\n    Checks the speed attribute of the given ExhaustFanOnEvent object to determine\n    if the exhaust fan is running at medium speed, which is defined by the speed\n    attribute being equal to 2.\n\n    Args:\n        event (ExhaustFanOnEvent):\n             An event object containing the exhaust fan's\n            current status and properties.\n\n    Returns:\n        (bool):\n             True if the fan's speed is medium, i.e., when speed attribute equals\n            2; otherwise, False.\n\n\n    \"\"\"\n    return event.speed == 2\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.light","title":"<code>light</code>","text":"<p>             Bases: <code>Region</code></p> <p>A region defining the behavior of the microwave's interior light. The light region has two states indicating whether the light is turned off or on. Transitions between these states are based on the door events of the microwave. If the door is open, the light turns on, and it turns off when the door is closed.</p> <p>Attributes:</p> Name Type Description <code>off</code> <code>State</code> <p>The state representing the light being turned off.</p> <code>on</code> <code>State</code> <p>The state representing the light being turned on.</p> <code>Transitions</code> <code>State</code> <p>A transition from 'off' to 'on' state guarded by the 'door_is_open' condition. A transition from 'on' to 'off' state triggered by <code>DoorCloseEvent</code>.</p> Source code in <code>examples/microwave.py</code> <pre><code>class light(sf.Region):\n    \"\"\"\n    A region defining the behavior of the microwave's interior light.\n    The light region has two states indicating whether the light is turned off or on. Transitions between these states are based on the door events of the microwave. If the door is open, the light turns on, and it turns off when the door is closed.\n\n    Attributes:\n        off (sf.State):\n             The state representing the light being turned off.\n        on (sf.State):\n             The state representing the light being turned on.\n        Transitions:\n            A transition from 'off' to 'on' state guarded by the 'door_is_open' condition.\n            A transition from 'on' to 'off' state triggered by `DoorCloseEvent`.\n\n    \"\"\"\n    class off(sf.State):\n        \"\"\"\n        A class representing an inactive or 'off' state within a finite state machine.\n        This class is a simple subclass of the `sf.State` class, which is presumably a part of a state machine\n        framework. The `off` class does not define any additional attributes or methods and serves as a\n        placeholder for representing an 'off' state within the state machine. It can be used to signify\n        that a particular component or system is in an inactive state.\n\n        Attributes:\n            Inherits all attributes from the parent `sf.State` class.\n\n        Methods:\n            Inherits all methods from the parent `sf.State` class, and does not override or define new ones.\n\n        \"\"\"\n        pass\n\n    class on(sf.State):\n        \"\"\"\n        A simple state class that inherits from `sf.State`.\n        This class serves as a placeholder for a state that can be used in state machines\n        which are based on `sf.State`. It does not provide any additional functionality\n        to the base class and is meant to be subclassed to implement specific behavior\n        for a state that is 'on'.\n\n\n        \"\"\"\n        pass\n\n    initial = sf.initial(off)\n    transitions = sf.collection(\n        sf.transition(\n            source=off, target=on, guard=door_is_open\n        ),  # completion transition\n        sf.transition(DoorCloseEvent, source=on, target=off),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.light.off","title":"<code>off</code>","text":"<p>             Bases: <code>State</code></p> <p>A class representing an inactive or 'off' state within a finite state machine. This class is a simple subclass of the <code>sf.State</code> class, which is presumably a part of a state machine framework. The <code>off</code> class does not define any additional attributes or methods and serves as a placeholder for representing an 'off' state within the state machine. It can be used to signify that a particular component or system is in an inactive state.</p> Source code in <code>examples/microwave.py</code> <pre><code>class off(sf.State):\n    \"\"\"\n    A class representing an inactive or 'off' state within a finite state machine.\n    This class is a simple subclass of the `sf.State` class, which is presumably a part of a state machine\n    framework. The `off` class does not define any additional attributes or methods and serves as a\n    placeholder for representing an 'off' state within the state machine. It can be used to signify\n    that a particular component or system is in an inactive state.\n\n    Attributes:\n        Inherits all attributes from the parent `sf.State` class.\n\n    Methods:\n        Inherits all methods from the parent `sf.State` class, and does not override or define new ones.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.light.on","title":"<code>on</code>","text":"<p>             Bases: <code>State</code></p> <p>A simple state class that inherits from <code>sf.State</code>. This class serves as a placeholder for a state that can be used in state machines which are based on <code>sf.State</code>. It does not provide any additional functionality to the base class and is meant to be subclassed to implement specific behavior for a state that is 'on'.</p> Source code in <code>examples/microwave.py</code> <pre><code>class on(sf.State):\n    \"\"\"\n    A simple state class that inherits from `sf.State`.\n    This class serves as a placeholder for a state that can be used in state machines\n    which are based on `sf.State`. It does not provide any additional functionality\n    to the base class and is meant to be subclassed to implement specific behavior\n    for a state that is 'on'.\n\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.magnetron","title":"<code>magnetron</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class representing the magnetron region within a larger state machine, presumably for modeling the behavior of a microwave's magnetron. The magnetron class is derived from a region of a state machine and contains two basic states: 'on' and 'off'. The 'initial' static method designates the 'off' state as the initial state of this region.</p> <p>Attributes:</p> Name Type Description <code>off</code> <code>State</code> <p>Represents the magnetron being turned off.</p> <code>on</code> <code>State</code> <p>Represents the magnetron being turned on.</p> <p>Methods:</p> Name Description <code>initial</code> <p>Static method that sets the initial state of the magnetron region to the 'off' state.</p> Source code in <code>examples/microwave.py</code> <pre><code>class magnetron(sf.Region):\n    \"\"\"\n    A class representing the magnetron region within a larger state machine, presumably for modeling the behavior of a microwave's magnetron.\n    The magnetron class is derived from a region of a state machine and contains two basic states: 'on' and 'off'. The 'initial' static method designates the 'off' state as the initial state of this region.\n\n    Attributes:\n        off (State):\n             Represents the magnetron being turned off.\n        on (State):\n             Represents the magnetron being turned on.\n\n    Methods:\n        initial():\n             Static method that sets the initial state of the magnetron region to the 'off' state.\n\n    \"\"\"\n    off = sf.simple_state(\"off\")\n    on = sf.simple_state(\"on\")\n\n    initial = sf.initial(off)\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.oven_light","title":"<code>oven_light</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class representing the oven light region within the state machine, with two possible states: 'on' and 'off'. The class models the oven light's behavior through two states indicating whether the oven light is turned on or turned off. It starts in the 'off' state as indicated by the 'initial' configuration. The transitions between the states are triggered by events. The light turns 'on' when the OvenLightOnEvent occurs and returns to 'off' when the OvenLightOffEvent occurs.</p> Source code in <code>examples/microwave.py</code> <pre><code>class oven_light(sf.Region):\n    \"\"\"\n    A class representing the oven light region within the state machine, with two possible states: 'on' and 'off'.\n    The class models the oven light's behavior through two states indicating whether the oven light is\n    turned on or turned off. It starts in the 'off' state as indicated by the 'initial' configuration.\n    The transitions between the states are triggered by events. The light turns 'on' when the\n    OvenLightOnEvent occurs and returns to 'off' when the OvenLightOffEvent occurs.\n\n    Attributes:\n        None explicitly declared in this class.\n\n    Methods:\n        None explicitly declared in this class. The state behavior and transitions are managed by the\n        state machine framework.\n\n    \"\"\"\n    class on(sf.State):\n        \"\"\"\n        A class that represents an 'on' state within a state machine framework.\n        This class is a subclass of the 'sf.State' class and is designed to represent\n        a specific state, presumably the 'on' state. As such, it encapsulates\n        all functionality and characteristics pertinent to this state within the\n        state machine's context. The class by itself does not provide any additional\n        behavior or properties over its superclass but serves as a placeholder or\n        an identifier for the 'on' state within the system it is used.\n\n        Attributes:\n            Inherited from sf.State:\n                 Refer to the superclass 'sf.State' documentation for inherited attributes.\n\n        Methods:\n            Inherited from sf.State:\n                 Refer to the superclass 'sf.State' documentation for inherited methods.\n\n        \"\"\"\n        pass\n\n    class off(sf.State):\n        \"\"\"\n        A class representing an 'off' state within a state machine framework.\n        This class is a simple subclass of the `sf.State` class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from `sf.State`, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.\n\n        Attributes:\n            Inherits all attributes from the parent `sf.State` class.\n\n        \"\"\"\n        pass\n\n    initial = sf.initial(off)\n    transitions = sf.collection(\n        sf.transition(OvenLightOnEvent, source=off, target=on),\n        sf.transition(\n            OvenLightOffEvent,\n            source=on,\n            target=off,\n        ),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.oven_light.off","title":"<code>off</code>","text":"<p>             Bases: <code>State</code></p> <p>A class representing an 'off' state within a state machine framework. This class is a simple subclass of the <code>sf.State</code> class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from <code>sf.State</code>, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.</p> Source code in <code>examples/microwave.py</code> <pre><code>class off(sf.State):\n    \"\"\"\n    A class representing an 'off' state within a state machine framework.\n    This class is a simple subclass of the `sf.State` class and does not define any additional methods or properties. It serves as a specific state, presumably indicating that something is turned off or inactive within the state machine's context. By inheriting from `sf.State`, it leverages all the functionality of a state within a state machine, such as entering, exiting, transitions, and possibly holding behavior that should occur when the state machine is in the 'off' state.\n\n    Attributes:\n        Inherits all attributes from the parent `sf.State` class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.oven_light.on","title":"<code>on</code>","text":"<p>             Bases: <code>State</code></p> <p>A class that represents an 'on' state within a state machine framework. This class is a subclass of the 'sf.State' class and is designed to represent a specific state, presumably the 'on' state. As such, it encapsulates all functionality and characteristics pertinent to this state within the state machine's context. The class by itself does not provide any additional behavior or properties over its superclass but serves as a placeholder or an identifier for the 'on' state within the system it is used.</p> <p>Attributes:</p> Name Type Description <code>Inherited</code> <code>from sf.State</code> <p>Refer to the superclass 'sf.State' documentation for inherited attributes.</p> <p>Methods:</p> Name Description <code>Inherited from sf.State</code> <p>Refer to the superclass 'sf.State' documentation for inherited methods.</p> Source code in <code>examples/microwave.py</code> <pre><code>class on(sf.State):\n    \"\"\"\n    A class that represents an 'on' state within a state machine framework.\n    This class is a subclass of the 'sf.State' class and is designed to represent\n    a specific state, presumably the 'on' state. As such, it encapsulates\n    all functionality and characteristics pertinent to this state within the\n    state machine's context. The class by itself does not provide any additional\n    behavior or properties over its superclass but serves as a placeholder or\n    an identifier for the 'on' state within the system it is used.\n\n    Attributes:\n        Inherited from sf.State:\n             Refer to the superclass 'sf.State' documentation for inherited attributes.\n\n    Methods:\n        Inherited from sf.State:\n             Refer to the superclass 'sf.State' documentation for inherited methods.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.turntable","title":"<code>turntable</code>","text":"<p>             Bases: <code>Region</code></p> <p>A class representing the turntable region within the Microwave's state machine. This region models the behavior of the microwave's turntable, which can either be in a rotating or an off state.</p> <p>Methods:</p> Name Description <code>States</code> <code>rotating</code> <p>State Represents the state where the turntable is rotating. It has</p> <code>two substates</code> <code>- clockwise</code> <p>State Represents the turntable rotating in a clockwise direction.</p> <code>- counterclockwise</code> <p>State Represents the turntable rotating in a counterclockwise direction. The initial state when the turntable is rotating is set to 'clockwise'.</p> <code>off</code> <p>State Represents the state where the turntable is not rotating (i.e., off). This is also the initial state of the turntable region when the microwave is not in use.</p> <code>Transitions</code> <ul> <li>A transition from the 'off' state to the 'rotating' state occurs when a CookStartEvent is triggered.</li> <li>A transition from the 'rotating' state to the 'off' state occurs when a guard condition 'door_is_open' is met.</li> </ul> Source code in <code>examples/microwave.py</code> <pre><code>class turntable(sf.Region):\n    \"\"\"\n    A class representing the turntable region within the Microwave's state machine.\n    This region models the behavior of the microwave's turntable, which can either be in a rotating or an off state.\n\n    Attributes:\n        None\n\n    Methods:\n        None\n        States:\n        rotating:\n             State\n            Represents the state where the turntable is rotating. It has\n        two substates:\n        - clockwise:\n             State\n            Represents the turntable rotating in a clockwise direction.\n        - counterclockwise:\n             State\n            Represents the turntable rotating in a counterclockwise direction.\n            The initial state when the turntable is rotating is set to 'clockwise'.\n        off:\n             State\n            Represents the state where the turntable is not rotating (i.e., off).\n            This is also the initial state of the turntable region when the microwave is not in use.\n        Transitions:\n            - A transition from the 'off' state to the 'rotating' state occurs when a CookStartEvent is triggered.\n            - A transition from the 'rotating' state to the 'off' state occurs when a guard condition 'door_is_open' is met.\n\n    \"\"\"\n    class rotating(sf.State):\n        \"\"\"\n        A state object representing the rotating state of a component, such as a turntable in a microwave.\n\n        Attributes:\n            clockwise (sf.State):\n                 A nested state indicating that the component is rotating in the clockwise direction.\n            counterclockwise (sf.State):\n                 A nested state indicating that the component is rotating in the counterclockwise direction.\n                This class also defines the initial starting state for the rotating state which is set to 'clockwise'.\n\n        \"\"\"\n        class clockwise(sf.State):\n            \"\"\"\n            A class that represents a 'clockwise' state in a state machine.\n            This class is derived from the 'sf.State' class and is intended to represent a\n            state within a state machine that signifies a 'clockwise' movement or transition.\n            The class does not provide any additional methods or attributes and serves as a\n            placeholder for a specific state category in the context of the state machine.\n\n            Attributes:\n                Inherits all attributes from the 'sf.State' class.\n\n            \"\"\"\n            pass\n\n        class counterclockwise(sf.State):\n            \"\"\"\n            A class representing a state in which an object or a system operates in a counterclockwise direction.\n            This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n            Attributes:\n                Inherits all attributes from the superclass 'sf.State'.\n\n            Methods:\n                Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n            \"\"\"\n            pass\n\n        initial = sf.initial(clockwise)\n\n    class off(sf.State):\n        \"\"\"\n        A placeholder state class that inherits from `sf.State` with no additional functionality.\n        This class represents a state that can be used in state machines derived from the `sf.State` base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.\n\n        Attributes:\n            Inherits all attributes from the parent class `sf.State`.\n\n        Methods:\n            Inherits all methods from the parent class `sf.State`.\n\n        \"\"\"\n        pass\n\n    initial = sf.initial(off)\n    transitions = sf.collection(\n        sf.transition(CookStartEvent, source=off, target=rotating),\n        sf.transition(source=rotating, target=off, guard=door_is_open),\n    )\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.turntable.off","title":"<code>off</code>","text":"<p>             Bases: <code>State</code></p> <p>A placeholder state class that inherits from <code>sf.State</code> with no additional functionality. This class represents a state that can be used in state machines derived from the <code>sf.State</code> base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.</p> Source code in <code>examples/microwave.py</code> <pre><code>class off(sf.State):\n    \"\"\"\n    A placeholder state class that inherits from `sf.State` with no additional functionality.\n    This class represents a state that can be used in state machines derived from the `sf.State` base class. It serves as a simple, unmodified state that does not introduce any new behavior or properties to the states that a state machine can be in.\n\n    Attributes:\n        Inherits all attributes from the parent class `sf.State`.\n\n    Methods:\n        Inherits all methods from the parent class `sf.State`.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power.on.turntable.rotating","title":"<code>rotating</code>","text":"<p>             Bases: <code>State</code></p> <p>A state object representing the rotating state of a component, such as a turntable in a microwave.</p> <p>Attributes:</p> Name Type Description <code>clockwise</code> <code>State</code> <p>A nested state indicating that the component is rotating in the clockwise direction.</p> <code>counterclockwise</code> <code>State</code> <p>A nested state indicating that the component is rotating in the counterclockwise direction. This class also defines the initial starting state for the rotating state which is set to 'clockwise'.</p> Source code in <code>examples/microwave.py</code> <pre><code>class rotating(sf.State):\n    \"\"\"\n    A state object representing the rotating state of a component, such as a turntable in a microwave.\n\n    Attributes:\n        clockwise (sf.State):\n             A nested state indicating that the component is rotating in the clockwise direction.\n        counterclockwise (sf.State):\n             A nested state indicating that the component is rotating in the counterclockwise direction.\n            This class also defines the initial starting state for the rotating state which is set to 'clockwise'.\n\n    \"\"\"\n    class clockwise(sf.State):\n        \"\"\"\n        A class that represents a 'clockwise' state in a state machine.\n        This class is derived from the 'sf.State' class and is intended to represent a\n        state within a state machine that signifies a 'clockwise' movement or transition.\n        The class does not provide any additional methods or attributes and serves as a\n        placeholder for a specific state category in the context of the state machine.\n\n        Attributes:\n            Inherits all attributes from the 'sf.State' class.\n\n        \"\"\"\n        pass\n\n    class counterclockwise(sf.State):\n        \"\"\"\n        A class representing a state in which an object or a system operates in a counterclockwise direction.\n        This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n        Attributes:\n            Inherits all attributes from the superclass 'sf.State'.\n\n        Methods:\n            Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n        \"\"\"\n        pass\n\n    initial = sf.initial(clockwise)\n</code></pre> <code>clockwise</code> <p>             Bases: <code>State</code></p> <p>A class that represents a 'clockwise' state in a state machine. This class is derived from the 'sf.State' class and is intended to represent a state within a state machine that signifies a 'clockwise' movement or transition. The class does not provide any additional methods or attributes and serves as a placeholder for a specific state category in the context of the state machine.</p> Source code in <code>examples/microwave.py</code> <pre><code>class clockwise(sf.State):\n    \"\"\"\n    A class that represents a 'clockwise' state in a state machine.\n    This class is derived from the 'sf.State' class and is intended to represent a\n    state within a state machine that signifies a 'clockwise' movement or transition.\n    The class does not provide any additional methods or attributes and serves as a\n    placeholder for a specific state category in the context of the state machine.\n\n    Attributes:\n        Inherits all attributes from the 'sf.State' class.\n\n    \"\"\"\n    pass\n</code></pre> <code>counterclockwise</code> <p>             Bases: <code>State</code></p> <p>A class representing a state in which an object or a system operates in a counterclockwise direction. This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.</p> Source code in <code>examples/microwave.py</code> <pre><code>class counterclockwise(sf.State):\n    \"\"\"\n    A class representing a state in which an object or a system operates in a counterclockwise direction.\n    This class is a subclass of 'sf.State' and represents a specific state within a state machine or a state-based system where the primary characteristic is counterclockwise motion or behavior. The class does not implement any additional methods or attributes and serves as a placeholder to signify counterclockwise operation. External systems or functions utilizing this class will define the specific behaviors associated with a 'counterclockwise' state.\n\n    Attributes:\n        Inherits all attributes from the superclass 'sf.State'.\n\n    Methods:\n        Inherits all methods from the superclass 'sf.State' and may override them if counterclockwise-specific behavior is required.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power_off","title":"<code>power_off()</code>  <code>async</code>","text":"<p>Asynchronously powers off a device or system. This method serves as an event trigger for initiating a shutdown sequence. It is adorned with a decorator indicating that it is meant to be treated as a callable event within the system. The exact side-effects are determined by the underlying implementation which should be designed to perform the shutdown process asynchronously. The function is a coroutine, it must be awaited when invoked, and it may need to be called as part of an event loop in asynchronous workflows. No arguments are required or processed, and the method does not return any value. Since this function does not take any parameters and does not provide a return value, the primary use-case is to signal other parts of the application that a power off event is requested, upon which those parts can take the necessary shutdown or cleanup actions.</p> Source code in <code>examples/microwave.py</code> <pre><code>@sf.decorators.call_event\nasync def power_off(self):\n    \"\"\"\n    Asynchronously powers off a device or system.\n    This method serves as an event trigger for initiating a shutdown sequence.\n    It is adorned with a decorator indicating that it is meant to be treated\n    as a callable event within the system. The exact side-effects are determined by\n    the underlying implementation which should be designed to perform the\n    shutdown process asynchronously.\n    The function is a coroutine, it must be awaited when invoked, and it\n    may need to be called as part of an event loop in asynchronous workflows.\n    No arguments are required or processed, and the method does not return any value.\n    Since this function does not take any parameters and does not provide a return\n    value, the primary use-case is to signal other parts of the application that a\n    power off event is requested, upon which those parts can take the necessary\n    shutdown or cleanup actions.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave.power_on","title":"<code>power_on()</code>  <code>async</code>","text":"<p>Asynchronously powers on the system or device linked to the class instance. This method is designed to be triggered as an event, indicated by the <code>call_event</code> decorator. It performs the necessary actions to initiate the power-on process but contains no implementation within the definition provided.</p> <p>Returns:</p> Type Description <p>The return value is not specified in this context, as the implementation of the method is yet to be defined. It is expected to return a value, typically a coroutine or a future, that the async event loop can await, or it might simply execute an action without returning anything if the power on operation is instantaneous.</p> Source code in <code>examples/microwave.py</code> <pre><code>@sf.decorators.call_event\nasync def power_on(self):\n    \"\"\"\n    Asynchronously powers on the system or device linked to the class instance.\n    This method is designed to be triggered as an event, indicated by the `call_event` decorator. It performs the necessary actions to initiate the power-on process but contains no implementation within the definition provided.\n\n    Raises:\n        This method is not documented to raise any exceptions, but since it is a placeholder, exceptions could be raised in concrete implementations depending on the actions performed while powering on the system.\n\n    Returns:\n        The return value is not specified in this context, as the implementation of the method is yet to be defined. It is expected to return a value, typically a coroutine or a future, that the async event loop can await, or it might simply execute an action without returning anything if the power on operation is instantaneous.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.Microwave2","title":"<code>Microwave2</code>","text":"<p>             Bases: <code>Microwave</code></p> <p>A subclass of the Microwave class, which inherits all the properties and methods from the Microwave parent class. This class currently does not introduce any additional attributes or methods and serves as a placeholder for potential future enhancements or specific implementations that differentiate it from its superclass.</p> Source code in <code>examples/microwave.py</code> <pre><code>class Microwave2(Microwave):\n    \"\"\"\n    A subclass of the Microwave class, which inherits all the properties and methods from the Microwave parent class. This class currently does not introduce any additional attributes or methods and serves as a placeholder for potential future enhancements or specific implementations that differentiate it from its superclass.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.OvenLightOffEvent","title":"<code>OvenLightOffEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A class representing an event where the oven light is turned off. This class serves as a specific event type within an event-driven system or framework dealing with an oven's state changes. It inherits from <code>sf.Event</code>, presumable a base event class provided by the system's framework. The <code>OvenLightOffEvent</code> class does not add any additional attributes or methods; it functions as a simple, semantic indicator for when the oven light is deactivated.</p> Source code in <code>examples/microwave.py</code> <pre><code>class OvenLightOffEvent(sf.Event):\n    \"\"\"\n    A class representing an event where the oven light is turned off.\n    This class serves as a specific event type within an event-driven system or framework\n    dealing with an oven's state changes. It inherits from `sf.Event`, presumable a base\n    event class provided by the system's framework. The `OvenLightOffEvent` class does\n    not add any additional attributes or methods; it functions as a simple, semantic\n    indicator for when the oven light is deactivated.\n\n    Attributes:\n        Inherits all attributes from the base class `sf.Event`.\n\n    Methods:\n        Inherits all methods from the base class `sf.Event`.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.OvenLightOnEvent","title":"<code>OvenLightOnEvent</code>","text":"<p>             Bases: <code>Event</code></p> <p>A simple event class that signifies that the oven light has been turned on. This class inherits from <code>sf.Event</code> and represents a specific event that can be used in applications that monitor or handle states of an oven, particularly the state of the oven light. It does not hold any additional data or methods; it serves as a signaling mechanism for event-driven systems to indicate the occurrence of the oven light being turned on.</p> Source code in <code>examples/microwave.py</code> <pre><code>class OvenLightOnEvent(sf.Event):\n    \"\"\"\n    A simple event class that signifies that the oven light has been turned on.\n    This class inherits from `sf.Event` and represents a specific event that can be used\n    in applications that monitor or handle states of an oven, particularly the state\n    of the oven light. It does not hold any additional data or methods; it serves as\n    a signaling mechanism for event-driven systems to indicate the occurrence of the\n    oven light being turned on.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.display_clear","title":"<code>display_clear(self, event)</code>","text":"<p>Clears the microwave display by printing an empty line. This function is designed to be a behavior callback associated with state transitions where the microwave display needs to be cleared. It takes an event, but does not use it within the function body, printing an empty line to the standard output regardless of the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that triggers this behavior. It is unused inside the function.</p> required Source code in <code>examples/microwave.py</code> <pre><code>@sf.decorators.behavior\ndef display_clear(self, event: sf.Event):\n    \"\"\"\n    Clears the microwave display by printing an empty line.\n    This function is designed to be a behavior callback associated with state transitions\n    where the microwave display needs to be cleared. It takes an event, but does not\n    use it within the function body, printing an empty line to the standard output regardless\n    of the event.\n\n    Args:\n        event (sf.Event):\n             The event that triggers this behavior. It is unused inside the function.\n\n    \"\"\"\n    print(\"\")\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.display_time","title":"<code>display_time(self, event=None)</code>","text":"<p>Displays the current time in ISO 8601 format. This is a state machine behavior method that prints the time attribute of the state machine's model. If an event triggers this behavior, the event is ignored as it is not utilized within the method.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Optional[Event]</code> <p>The event that triggered this behavior, which is not utilized within the function. It defaults to None if not provided.</p> <code>None</code> Source code in <code>examples/microwave.py</code> <pre><code>@sf.decorators.behavior\ndef display_time(self, event: sf.Event = None):\n    \"\"\"\n    Displays the current time in ISO 8601 format.\n    This is a state machine behavior method that prints the time attribute of the state\n    machine's model. If an event triggers this behavior, the event is ignored as it\n    is not utilized within the method.\n\n    Args:\n        event (Optional[sf.Event]):\n             The event that triggered this behavior, which is\n            not utilized within the function. It defaults to None if not provided.\n\n    \"\"\"\n    print(self.model.time.isoformat())\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.door_is_open","title":"<code>door_is_open(self, event=None)</code>","text":"<p>Determines if the door is currently open by checking the state against the interpreter stack.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event object which can optionally be used to determine the door's state. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the door's 'open' state is present in the interpreter stack, False otherwise.</p> Source code in <code>examples/microwave.py</code> <pre><code>def door_is_open(self, event: sf.Event = None):\n    \"\"\"\n    Determines if the door is currently open by checking the state against the interpreter stack.\n\n    Args:\n        event (sf.Event, optional):\n             The event object which can optionally be used to determine the door's state. Defaults to None.\n\n    Returns:\n        (bool):\n             True if the door's 'open' state is present in the interpreter stack, False otherwise.\n\n    \"\"\"\n    return self.model.door.open in self.model.interpreter.stack\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.main","title":"<code>main()</code>  <code>async</code>","text":"<p>Async function that initializes and starts a Microwave state machine. This function dumps the structure of the Microwave state machine for debugging, creates an instance of Microwave, starts the state machine's interpreter, and prints its state. It then asserts that the power is turned on and prints the state again.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the power state of the microwave is not 'on' after starting the interpreter.</p> Source code in <code>examples/microwave.py</code> <pre><code>async def main():\n    \"\"\"\n    Async function that initializes and starts a Microwave state machine.\n    This function dumps the structure of the Microwave state machine for debugging, creates an instance of Microwave, starts the state machine's interpreter, and prints its state. It then asserts that the power is turned on and prints the state again.\n\n    Raises:\n        AssertionError:\n             If the power state of the microwave is not 'on' after starting the interpreter.\n\n    \"\"\"\n    sf.dump(Microwave)\n    microwave = Microwave()\n\n    await microwave.interpreter.start()\n    print(microwave.state)\n    assert microwave.power.on in microwave.state\n    print(microwave.state)\n</code></pre>"},{"location":"Python/Examples/Microwave/#examples.microwave.throw","title":"<code>throw(exception)</code>","text":"<p>Raises a specified exception.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception object to be raised.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>The exception passed to the function.</p> Source code in <code>examples/microwave.py</code> <pre><code>def throw(exception: Exception):\n    \"\"\"\n\n    Raises a specified exception.\n\n    Args:\n        exception (Exception):\n             The exception object to be raised.\n\n    Raises:\n        Exception:\n             The exception passed to the function.\n\n    \"\"\"\n    raise exception\n</code></pre>"},{"location":"Python/Examples/TrafficLight/","title":"TrafficLight","text":""},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--overview-of-stateforwardexampletraffic_lightpy-module","title":"Overview of <code>stateforward.example.traffic_light.py</code> Module","text":"<p>The <code>stateforward.example.traffic_light.py</code> module is part of the <code>stateforward</code> package, which provides a framework for building state machines using the asyncio capabilities of Python. This specific module includes an example implementation of a traffic light state machine.</p>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--features","title":"Features:","text":"<ul> <li>Asynchronous state machine implementation for traffic lights.</li> <li>Custom events such as <code>PedestrianWalkButton</code> and <code>CarSensor</code>.</li> <li>Use of timers to automatically transition between states (<code>after</code> function).</li> <li>Guard functions that allow conditional transitions.</li> </ul>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--traffic-light-example-usage","title":"Traffic Light Example Usage","text":"<p>Below is a possible sequence of operations for the <code>TrafficLight</code> state machine:</p> <ol> <li>The traffic light starts in the <code>On</code> state with the <code>green</code> submachine state active.</li> <li>When a <code>PedestrianWalkButton</code> event occurs, the light transitions to the <code>yellow</code> submachine state.</li> <li>After 3 seconds (simulated by the <code>after</code> guard condition), the light transitions to the <code>red</code> submachine state.</li> </ol>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--state-machine-diagram","title":"State Machine Diagram","text":"<p>Here is a mermaid.js diagram that visualizes the state machine for the traffic light example:</p> <p>Traffic Light</p> Signal DiagramTraffic Light DiagramCode <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / display(self)\n    Off: exit / display(self)\n    On: On\n    On: entry / display(self)\n    On: exit / display(self)\n    [*] --&gt; On\n    On --&gt; [*]\n    On --&gt; Off : after(1s) / guard self.flashing\n    Off --&gt; On : after(1s)\n</code></pre> <pre><code>stateDiagram-v2\n    direction LR\n    state On {\n\n    [*] --&gt; green\n    }\n</code></pre> <pre><code>stateDiagram-v2\n    direction LR\n\n    state On {\n      initial --&gt; green\n      green --&gt; yellow: PedestrianWalkButton\n      yellow --&gt; red: after(3s)\n    }\n\n    [*] --&gt; On\n    On --&gt; Off: power_off</code></pre>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--development-notes","title":"Development Notes","text":""},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--event-classes","title":"Event Classes","text":"<ul> <li><code>PedestrianWalkButton</code> - Represents the event of a pedestrian pressing the walk button.</li> <li><code>CarSensor</code> - Represents the detection of a car waiting at the traffic light.</li> <li><code>OffEvent</code> - Indicates that the traffic light has been turned off.</li> <li><code>FlashingEvent</code> - Indicates the traffic light has entered a flashing state.</li> </ul>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--behavior-implementation","title":"Behavior Implementation","text":"<ul> <li><code>Signal</code> - A state machine used to represent a traffic signal mechanism that can switch between <code>On</code> and <code>Off</code> states.</li> <li><code>TrafficLight</code> - A more complex state machine representing a traffic light system that can handle pedestrian interaction and power-off events.</li> </ul>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--guard-functions","title":"Guard Functions","text":"<ul> <li><code>walk_guard</code> - A guard function to allow the <code>Pedestrian</code> region to transition from <code>DontWalk</code> to <code>Walk</code>.</li> </ul>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--helper-functions","title":"Helper Functions","text":"<ul> <li><code>display</code> - A debugging function to visually display the traffic light's current state.</li> </ul>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--usage","title":"Usage","text":"<p>To run the traffic light simulation, execute <code>traffic_light_main()</code> within an <code>asyncio</code> event loop, asynchronously starting the traffic light state machine and allowing for interaction through event dispatching.</p>"},{"location":"Python/Examples/TrafficLight/#examples.traffic_light--concurrency","title":"Concurrency","text":"<p>This example takes advantage of the <code>ConcurrencyKind.asynchronous</code> to ensure that the traffic light state machine runs in an asynchronous environment suitable for IO-bound and high-level structured network code.</p>"}]}