{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Overview/","title":"Overview","text":"<p>StateForward Python is in alpha</p> <p>This is a work in progress and is not ready for production use yet. The API and implementation are subject to changes on minor versions. See the Roadmap for planned features and the Contributing section for ways to contribute.</p>"},{"location":"Overview/#stateforward--about-stateforward-python","title":"About StateForward Python","text":"<p>StateForward Python is where code complexity meets simplicity. This library is your ally in evolving spaghetti code into elegant, robust state machines. Say goodbye to the dense forest of if-else statements and welcome a world where adding features doesn\u2019t mean unraveling a complex knot.</p> <p>With StateForward Python, you\u2019re building on solid ground. Your code becomes a clear map of states and transitions, making it easily extendable and a joy to maintain. It's about writing software that grows with grace, ensuring that your project's future is as structured and reliable as its present.</p>"},{"location":"Overview/#stateforward--installation","title":"Installation","text":"<pre><code>pip install stateforward\n</code></pre>"},{"location":"Overview/#stateforward--usage","title":"Usage","text":"<p>Light Switch Example</p> DiagramCodeOutput <p>Here is a simple example of a light switch state machine using StateForward Python. <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / print(\"Light off entry\")\n    Off: exit / print(\"Light off exit\")\n    [*] --&gt; Off\n    On: On\n    On: entry / print(\"Light on entry\")\n    On: exit / print(\"Light on exit\")\n    Off --&gt; On : OnEvent\n    On --&gt; Off : OffEvent\n\n</code></pre></p> <pre><code>import stateforward as sf\nimport asyncio\n\n\nclass OnEvent(sf.Event):\n    pass\n\n\nclass OffEvent(sf.Event):\n    pass\n\n\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light on entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light on exit\")\n\n    class Off(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light off entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light off exit\")\n\n    initial = sf.initial(Off)\n    transitions = sf.collection(\n        sf.transition(OnEvent, source=Off, target=On),\n        sf.transition(OffEvent, source=On, target=Off),\n    )\n\n\nasync def main():\n    # instantiate a light switch\n    light_switch = LightSwitch()\n    # start the interpreter and wait for it to be settled\n    await light_switch.interpreter.start()\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OnEvent to the state machine\n    await sf.dispatch(OnEvent(), light_switch)\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OffEvent to the state machine\n    await sf.dispatch(OffEvent(), light_switch)\n    print(light_switch.state)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>Light off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\nLight on entry\n(&lt;__main__.LightSwitch.region.region_0.On object at 0x10683dd90&gt;,)\nLight on exit\nLight off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\n</code></pre>"},{"location":"Roadmap/","title":"Roadmap","text":""},{"location":"Roadmap/#roadmap","title":"Roadmap","text":""},{"location":"Roadmap/#submachine","title":"Submachine","text":"<ul> <li> Implement Submachine: Creation of a substate machine within the larger state machine architecture is complete.</li> <li> Define Entry Point: Establish the initialization state where the submachine commences its process.</li> <li> Institute Exit Point: Designate the final state that concludes the submachine's execution and handle any necessary state cleanup.</li> </ul>"},{"location":"Roadmap/#history-pseudostate","title":"History Pseudostate","text":"<ul> <li> Integrate Shallow History: Develop a state memory system that recalls the most recent active substate without retaining nested state histories, enabling reentry at the last active state.</li> <li> Incorporate Deep History: Implement a comprehensive state memory system that retains complete nested state histories for accurate restoration upon reentry.</li> </ul>"},{"location":"Roadmap/#statemachine-interpreters","title":"StateMachine Interpreters","text":"<ul> <li> Implement Async StateMachine Interpreter: Completed the asynchronous state machine interpreter, facilitating non-blocking state execution.</li> <li> Develop Multi-Processing StateMachine Interpreter: Construct an interpreter that utilizes multiple processes for parallel state processing, enhancing performance for computations.</li> <li> Construct Thread-Based Interpreter: Build an interpreter that manages state operations via threading, optimizing for concurrent I/O-bound tasks.</li> <li> Design SequentialStateMachine Interpreter: Initiate the creation of an interpreter that deals with state transitions in a sequential, ordered manner, designed for straightforward execution flows.</li> </ul>"},{"location":"Roadmap/#unit-tests","title":"Unit Tests","text":"<ul> <li> Develop Unit Tests: Write tests for individual state components to evaluate their independent functionalities, ensuring reliability and bug-free operation.</li> </ul>"},{"location":"Roadmap/#documentation","title":"Documentation","text":"<ul> <li> Compile Documentation: Produce detailed documentation outlining the state machine's configuration, including its states, transitions, and state machine protocols, to support maintenance and usage comprehension.</li> </ul>"},{"location":"Roadmap/#interpreter-refactoring","title":"Interpreter Refactoring","text":"<ul> <li> Refactor Interpreter Logic: Rework the interpreter component to execute a sequence of abstract instructions, rather than direct manipulation of the state tree, for better modularity and maintainability.</li> </ul> <p>See the open issues for a full list of proposed features (and known issues).</p>"},{"location":"Examples/LightSwitch/","title":"LightSwitch","text":""},{"location":"Examples/LightSwitch/#examples.light_switch--introduction","title":"Introduction","text":"<p>The <code>light_switch</code> module is part of the <code>stateforward</code> examples and showcases the implementation of an asynchronous state machine to model the behavior of a light switch. The example defines states for the light switch, such as <code>On</code>, <code>Off</code>, and <code>Flashing</code>, as well as events that trigger state transitions, such as turning the light <code>OnEvent</code> or <code>OffEvent</code>.</p> <p>Light Switch Example</p> DiagramCodeOutput <p>Here is a simple example of a light switch state machine using StateForward Python. <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / print(\"Light off entry\")\n    Off: exit / print(\"Light off exit\")\n    [*] --&gt; Off\n    On: On\n    On: entry / print(\"Light on entry\")\n    On: exit / print(\"Light on exit\")\n    Off --&gt; On : OnEvent\n    On --&gt; Off : OffEvent\n\n</code></pre></p> <pre><code>import stateforward as sf\nimport asyncio\n\n\nclass OnEvent(sf.Event):\n    pass\n\n\nclass OffEvent(sf.Event):\n    pass\n\n\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light on entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light on exit\")\n\n    class Off(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light off entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light off exit\")\n\n    initial = sf.initial(Off)\n    transitions = sf.collection(\n        sf.transition(OnEvent, source=Off, target=On),\n        sf.transition(OffEvent, source=On, target=Off),\n    )\n\n\nasync def main():\n    # instantiate a light switch\n    light_switch = LightSwitch()\n    # start the interpreter and wait for it to be settled\n    await light_switch.interpreter.start()\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OnEvent to the state machine\n    await sf.dispatch(OnEvent(), light_switch)\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OffEvent to the state machine\n    await sf.dispatch(OffEvent(), light_switch)\n    print(light_switch.state)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>Light off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\nLight on entry\n(&lt;__main__.LightSwitch.region.region_0.On object at 0x10683dd90&gt;,)\nLight on exit\nLight off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\n</code></pre>"},{"location":"Examples/LightSwitch/#examples.light_switch--components-of-the-light-switch-state-machine","title":"Components of the Light Switch State Machine","text":""},{"location":"Examples/LightSwitch/#examples.light_switch--events","title":"Events","text":"<ul> <li><code>OnEvent</code>: An event representing the action of turning the light on.</li> <li><code>OffEvent</code>: An event representing the action of turning the light off.</li> <li><code>FlashEvent</code>: An event that triggers the flashing mode, derived from the custom <code>ChangeEvent</code>.</li> </ul>"},{"location":"Examples/LightSwitch/#examples.light_switch--states","title":"States","text":"<ul> <li><code>On</code>: The state representing the light being turned on.</li> <li><code>Off</code>: The state representing the light being turned off.</li> <li><code>Flashing</code>: The state representing the light in a flashing mode. Transition to this state is determined by the condition <code>lambda self, event=None: self.model.flashing</code>.</li> </ul>"},{"location":"Examples/LightSwitch/#examples.light_switch--behaviors","title":"Behaviors","text":"<p>The module defines <code>PrintBehavior</code> as a simple behavior that prints a message to the console upon entering and exiting states.</p>"},{"location":"Examples/LightSwitch/#examples.light_switch--defining-the-light-switch-state-machine","title":"Defining the Light Switch State Machine","text":"<p>The <code>LightSwitch</code> state machine is derived from <code>AsyncStateMachine</code> and specifies the states and transitions. It includes an attribute <code>flashing</code>, which is a boolean flag used to conditionally trigger the flashing state.</p>"},{"location":"Examples/LightSwitch/#examples.light_switch--transitions","title":"Transitions","text":"<p>Transitions between states are defined using the <code>transition</code> function from the <code>stateforward</code> framework; it specifies what event causes the transition, the source state, and the target state, along with optional guards and effects.</p>"},{"location":"Examples/LightSwitch/#examples.light_switch--asynchronous-operation","title":"Asynchronous Operation","text":"<p>The state machine is designed to operate asynchronously, making use of Python's <code>asyncio</code> library. This allows for concurrent operation within an event-driven system.</p>"},{"location":"Examples/LightSwitch/#examples.light_switch--running-the-example","title":"Running the Example","text":"<p>The module includes an asynchronous <code>light_switch_main</code> function that initializes the state machine, starts it, and dispatches events to trigger state transitions. One can observe the behavior of the light switch by calling this function within an event loop.</p>"},{"location":"Examples/LightSwitch/#examples.light_switch--conclusion","title":"Conclusion","text":"<p>The <code>stateforward.example.light_switch</code> module serves as an educational tool for understanding the <code>stateforward</code> framework and is an example of how to model and simulate a simple system with state machines in Python.</p> <p>To learn more about other parts of the <code>stateforward</code> framework or to adapt the light switch example for your own use case, please refer to the rest of the documentation.</p>"},{"location":"Examples/TrafficLight/","title":"TrafficLight","text":""},{"location":"Examples/TrafficLight/#examples.traffic_light--overview-of-stateforwardexampletraffic_lightpy-module","title":"Overview of <code>stateforward.example.traffic_light.py</code> Module","text":"<p>The <code>stateforward.example.traffic_light.py</code> module is part of the <code>stateforward</code> package, which provides a framework for building state machines using the asyncio capabilities of Python. This specific module includes an example implementation of a traffic light state machine.</p>"},{"location":"Examples/TrafficLight/#examples.traffic_light--features","title":"Features:","text":"<ul> <li>Asynchronous state machine implementation for traffic lights.</li> <li>Custom events such as <code>PedestrianWalkButton</code> and <code>CarSensor</code>.</li> <li>Use of timers to automatically transition between states (<code>after</code> function).</li> <li>Guard functions that allow conditional transitions.</li> </ul>"},{"location":"Examples/TrafficLight/#examples.traffic_light--traffic-light-example-usage","title":"Traffic Light Example Usage","text":"<p>Below is a possible sequence of operations for the <code>TrafficLight</code> state machine:</p> <ol> <li>The traffic light starts in the <code>On</code> state with the <code>green</code> submachine state active.</li> <li>When a <code>PedestrianWalkButton</code> event occurs, the light transitions to the <code>yellow</code> submachine state.</li> <li>After 3 seconds (simulated by the <code>after</code> guard condition), the light transitions to the <code>red</code> submachine state.</li> </ol>"},{"location":"Examples/TrafficLight/#examples.traffic_light--state-machine-diagram","title":"State Machine Diagram","text":"<p>Here is a mermaid.js diagram that visualizes the state machine for the traffic light example:</p> <p>Traffic Light</p> Signal DiagramTraffic Light DiagramCode <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / display(self)\n    Off: exit / display(self)\n    On: On\n    On: entry / display(self)\n    On: exit / display(self)\n    [*] --&gt; On\n    On --&gt; [*]\n    On --&gt; Off : after(1s) / guard self.flashing\n    Off --&gt; On : after(1s)\n</code></pre> <pre><code>stateDiagram-v2\n    direction LR\n    state On {\n\n    [*] --&gt; green\n    }\n</code></pre> <pre><code>stateDiagram-v2\n    direction LR\n\n    state On {\n      initial --&gt; green\n      green --&gt; yellow: PedestrianWalkButton\n      yellow --&gt; red: after(3s)\n    }\n\n    [*] --&gt; On\n    On --&gt; Off: power_off</code></pre>"},{"location":"Examples/TrafficLight/#examples.traffic_light--development-notes","title":"Development Notes","text":""},{"location":"Examples/TrafficLight/#examples.traffic_light--event-classes","title":"Event Classes","text":"<ul> <li><code>PedestrianWalkButton</code> - Represents the event of a pedestrian pressing the walk button.</li> <li><code>CarSensor</code> - Represents the detection of a car waiting at the traffic light.</li> <li><code>OffEvent</code> - Indicates that the traffic light has been turned off.</li> <li><code>FlashingEvent</code> - Indicates the traffic light has entered a flashing state.</li> </ul>"},{"location":"Examples/TrafficLight/#examples.traffic_light--behavior-implementation","title":"Behavior Implementation","text":"<ul> <li><code>Signal</code> - A state machine used to represent a traffic signal mechanism that can switch between <code>On</code> and <code>Off</code> states.</li> <li><code>TrafficLight</code> - A more complex state machine representing a traffic light system that can handle pedestrian interaction and power-off events.</li> </ul>"},{"location":"Examples/TrafficLight/#examples.traffic_light--guard-functions","title":"Guard Functions","text":"<ul> <li><code>walk_guard</code> - A guard function to allow the <code>Pedestrian</code> region to transition from <code>DontWalk</code> to <code>Walk</code>.</li> </ul>"},{"location":"Examples/TrafficLight/#examples.traffic_light--helper-functions","title":"Helper Functions","text":"<ul> <li><code>display</code> - A debugging function to visually display the traffic light's current state.</li> </ul>"},{"location":"Examples/TrafficLight/#examples.traffic_light--usage","title":"Usage","text":"<p>To run the traffic light simulation, execute <code>traffic_light_main()</code> within an <code>asyncio</code> event loop, asynchronously starting the traffic light state machine and allowing for interaction through event dispatching.</p>"},{"location":"Examples/TrafficLight/#examples.traffic_light--concurrency","title":"Concurrency","text":"<p>This example takes advantage of the <code>ConcurrencyKind.asynchronous</code> to ensure that the traffic light state machine runs in an asynchronous environment suitable for IO-bound and high-level structured network code.</p>"},{"location":"Modeling/Overview/","title":"Overview","text":""},{"location":"Modeling/Overview/#stateforward.model--element-overview","title":"Element Overview","text":"<p>The Element is the foundational class for all StateForward elements. It provides essential functionality for creating a tree structure and managing relationships.</p> <p>In contrast to the <code>ast</code> module, the Element and its associated elements are classes rather than objects. This design choice is based on several reasons:</p> <ol> <li>The tree is constructed only once at the initiation of the Python process and remains static thereafter. This results in a one-time overhead, which becomes significant when we examine the <code>Model</code> element.</li> <li>Elements can be customized through standard inheritance and polymorphism. This feature enables the development of unique elements that can enhance the capabilities of the <code>Element</code> class.</li> <li>Elements are instantiated in the same manner as any other Python object.</li> </ol>"},{"location":"Modeling/Overview/#stateforward.model--definition","title":"Definition","text":"<p>Element Definition</p> CodeOutput <pre><code>import stateforward as sf\nfrom typing import Union\n\n\nclass FamilyTreeElement(sf.Element):\n    def __new__(cls, *args, **kwargs):\n        print(f\"{cls.qualified_name}.__new__\")\n        return super().__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        print(f\"{self.qualified_name}.__init__\")\n        super().__init__(*args, **kwargs)\n\n\nclass Person(FamilyTreeElement):\n    first_name: str\n    age: int\n    kids: Union[FamilyTreeElement, sf.Collection[FamilyTreeElement]] = None\n\n\nclass FamilyTree(FamilyTreeElement):\n    pass\n\n\nclass Family(FamilyTree):\n    class Dad(Person, first_name=\"John\", age=40):\n        pass\n\n    class Mom(Person, first_name=\"Jane\", age=38):\n        class Son(Person, first_name=\"Jack\", age=15):\n            pass\n\n        class Daughter(Person, first_name=\"Jill\", age=26):\n            class Grandson(Person, first_name=\"Jimmy\", age=1):\n                pass\n\n        class SonInLaw(Person, first_name=\"John\", age=26):\n            pass\n\n\nsf.dump(Family)\n</code></pre> <pre><code>0 -&gt; Family type[FamilyTree] @ 0x105882730\n 1 -&gt; Family.Dad type[Person] @ 0x10587feb0\n 1 -&gt; Family.Mom type[Person] @ 0x105882070\n  2 -&gt; Family.Mom.Son type[Person] @ 0x105880570\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x1058812f0\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x105880c30\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x1058819b0\n</code></pre> <p>The leading numbers in the output denote the hierarchical level of each element within the tree structure, which aids in deciphering the connections among elements. Even upon instantiation, this hierarchical format is preserved.</p>"},{"location":"Modeling/Overview/#stateforward.model--instantiating","title":"Instantiating","text":"<p>Element Instantiation</p> CodeOutput <pre><code>my_family = Family()\nsf.dump(my_family)\nprint(my_family.Dad)\n</code></pre> <pre><code>Family.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x1011ea59\n 1 -&gt; Family.Dad object[Person] @ 0x101a7cb9\n 1 -&gt; Family.Mom object[Person] @ 0x101a7cc9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x101a7cdd\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x101a7ced\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x101a7d05\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x101a7d11\n&lt;__main__.Family.Dad object at 0x101a7cb9&gt;\n</code></pre> <p>Print statements were added to <code>__new__</code> and <code>__init__</code> to demonstrate the order of instantiation and initialization of a tree of Elements. This is done intentionally to ensure that all elements are instantiated before any of them are initialized making them safe to access or references inside the <code>__init__</code> method. Additionally the owned elements that are declared in <code>Family</code> become object attributes of the <code>Family</code> instance. As you can see in the printed <code>my_family.Dad</code> statement output.</p>"},{"location":"Modeling/Overview/#stateforward.model--association-overview","title":"Association Overview","text":"<p>An <code>Association</code> represents a relationship to an element that is already under ownership elsewhere in the object hierarchy. It acts as a reference that enables access to these elements without directly owning them, maintaining a clear structure of ownership and dependencies.</p> <p>In Python, an <code>Association</code> is a specialized wrapper around <code>weakref.proxy</code>, which allows the referred objects to be accessible as long as they exist, without affecting their lifetime by creating strong reference counts that would prevent garbage collection.</p> <p>For example, in the <code>Family</code> tree structure mentioned earlier, if the <code>Grandson</code> needs to be associated with both <code>Daughter</code> and <code>SonInLaw</code>, rather than duplicating the <code>Grandson</code> object or directly sharing ownership, an <code>Association</code> can be created from <code>SonInLaw</code> to the pre-existing <code>Grandson</code> element. This setup symbolizes the relationship without taking full ownership, thus keeping the <code>Grandson</code> within the sole ownership tree of <code>Daughter</code> but still accessible from <code>SonInLaw</code> through this lightweight relationship.</p> <p>By utilizing an <code>Association</code>, you ensure the system's relational integrity without being entangled in complex webs of ownership that might lead to memory leaks or logical inconsistencies.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_1","title":"Definition","text":"<p>Association Usage</p> CodeOutput <pre><code># ... same as above\n        class SonInLaw(Person, first_name=\"John\", age=26, kids=Daughter.Grandson):\n            pass\n\n\nsf.dump(Family)\n</code></pre> <pre><code>0 -&gt; Family type[FamilyTree] @ 0x106f0ab10\n 1 -&gt; Family.Dad type[Person] @ 0x106f08290\n 1 -&gt; Family.Mom type[Person] @ 0x106f0a450\n  2 -&gt; Family.Mom.Son type[Person] @ 0x106f08950\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x106f096d0\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x106f09010\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x106f09d90\n   3 -&gt; Family.Mom.SonInLaw.kids type[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x106f09010\n</code></pre> <p>Inspecting the output reveals that <code>SonInLaw.kids</code> has been established as an <code>Association</code> pointing to <code>Daughter.Grandson</code>. It is noteworthy that this association references the grandson using the very same memory location, underscoring that it does not constitute a separate instance but a different access path to the same object.</p>"},{"location":"Modeling/Overview/#stateforward.model--instantiating_1","title":"Instantiating","text":"<p>Now, let's proceed to create another instance of the family tree to observe the effects of these relationships in practice.</p> <p>Element With Associations</p> CodeOutput <pre><code>my_family = Family()\nsf.dump(my_family)\n</code></pre> <pre><code>Family.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x1010d245\n 1 -&gt; Family.Dad object[Person] @ 0x1010d899\n 1 -&gt; Family.Mom object[Person] @ 0x1010d8b9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x1010d8d1\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x1010d8e1\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x1010d8f9\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x1010d905\n   3 -&gt; Family.Mom.SonInLaw.kids object[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x1010d8f9\n</code></pre> <p>Upon observation, we can discern that the <code>Association</code> has maintained its link to the same <code>Grandson</code> instance, as indicated by the identical memory address.</p> <p>Additionally, the output highlights that the <code>Grandson</code> element is initialized only once, even though it's included in the family tree twice\u2014once directly within <code>Daughter</code> and once as an associated reference in <code>SonInLaw</code>. It demonstrates the efficiency of <code>Associations</code> in managing relationships without redundant initializations, thus providing a single source of truth for shared objects within complex structures.</p>"},{"location":"Modeling/Overview/#stateforward.model--collection-overview","title":"Collection Overview","text":"<p>A <code>Collection</code> is a fixed container designed to hold elements, which can be either directly owned entities or associations to other elements. Elements within a <code>Collection</code> are automatically mapped or instantiated at the time the <code>Collection</code> itself is instantiated, making the container's content predictable and consistent.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_2","title":"Definition","text":"<p>The following modification to the family tree example introduces a <code>GrandDaughter</code> under the <code>Mom.Daughter</code> class. Additionally, the <code>SonInLaw</code> class now includes a <code>Collection</code> named <code>kids</code> to hold both the <code>Grandson</code> and the <code>Granddaughter</code>.</p> <p>Collection Example</p> CodeOutput <pre><code># ... same as the original\n        class Daughter(Person, first_name=\"Jill\", age=26):\n            class Grandson(Person, first_name=\"Jimmy\", age=1):\n                pass\n\n            class Granddaughter(Person, first_name=\"Jenny\", age=3):\n                pass\n\n        class SonInLaw(\n            Person,\n            first_name=\"John\",\n            age=26,\n            kids=sf.collection(Daughter.Grandson, Daughter.Granddaughter),\n        ):\n            pass\n\n\nsf.dump(Family)\n</code></pre> <p>In this scenario, the <code>SonInLaw</code> class reflects that <code>John</code> has two children: <code>Grandson</code> and <code>Granddaughter</code>. These children are grouped together using the <code>sf.collection()</code> method, signifying that <code>John</code>'s <code>kids</code> attribute is an immutable set of his children. When the <code>Family</code> instance is created, this <code>Collection</code> ensures that the <code>Grandson</code> and <code>Granddaughter</code> are both tied into the family structure within the context of the <code>SonInLaw</code> class. <pre><code>0 -&gt; Family type[FamilyTree] @ 0x120eb8a40\n 1 -&gt; Family.Dad type[Person] @ 0x120eb5440\n 1 -&gt; Family.Mom type[Person] @ 0x120eb8380\n  2 -&gt; Family.Mom.Son type[Person] @ 0x120eb5b00\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x120eb6f40\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x120eb61c0\n   3 -&gt; Family.Mom.Daughter.Granddaughter type[Person] @ 0x120eb6880\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x120eb7cc0\n   3 -&gt; Family.Mom.SonInLaw.kids type[Collection] @ 0x120eb7600\n    4 -&gt; Family.Mom.SonInLaw.kids.0 type[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x120eb61c0\n    4 -&gt; Family.Mom.SonInLaw.kids.1 type[Association&lt;Family.Mom.Daughter.Granddaughter&gt;] @ 0x120eb6880\n</code></pre></p> <p>You can discern from this output that the <code>kids</code> attribute of the <code>SonInLaw</code> instance is now a <code>Collection</code>. Within this <code>Collection</code>, there are <code>Associations</code> to the <code>Grandson</code> and <code>Granddaughter</code>. Crucially, these associations preserve the original memory addresses of the grandchildren, as they should, confirming the <code>Collection</code> utilizes direct associations to existing instances rather than creating duplicate objects.</p> <p>The output enumerates and maintains the hierarchical integrity and precise order of elements, as exhibited by the four-level deep printout where <code>SonInLaw.kids</code> consists of indexes (<code>.0</code> and <code>.1</code>) signifying individual positions within the <code>Collection</code>. This ensures each child's relational context within the family is clear and traceable.</p>"},{"location":"Modeling/Overview/#stateforward.model--instantiating_2","title":"Instantiating","text":"<p>instantiating the family again.</p> <p>Collection Instantiation</p> CodeOutput <pre><code>my_family = Family()\nsf.dump(my_family)\nprint(my_family.Mom.SonInLaw.kids[0])\n</code></pre> <pre><code>Family.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.Daughter.Granddaughter.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Granddaughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x102eaf7d\n 1 -&gt; Family.Dad object[Person] @ 0x103f14e9\n 1 -&gt; Family.Mom object[Person] @ 0x103f14f9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x103f1511\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x103f1521\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x103f153d\n   3 -&gt; Family.Mom.Daughter.Granddaughter object[Person] @ 0x103f154d\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x103f1559\n   3 -&gt; Family.Mom.SonInLaw.kids object[Collection] @ 0x103f155d\n    4 -&gt; Family.Mom.SonInLaw.kids.0 object[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x103f153d\n    4 -&gt; Family.Mom.SonInLaw.kids.1 object[Association&lt;Family.Mom.Daughter.Granddaughter&gt;] @ 0x103f154d\n&lt;__main__.Family.Mom.Daughter.Grandson object at 0x103f153d&gt;\n</code></pre> <p>Just as anticipated from our previous discussion, the <code>Collection</code> within <code>SonInLaw.kids</code> endures as a reference to the <code>Grandson</code> and <code>Granddaughter</code>. It's worth observing that these associations are now presented as <code>objects</code> instead of <code>types</code>, reflecting the instantiated state of the elements. In this context, \"instantiated state\" suggests that instead of merely referring to the class blueprints (types), we're now handling actual, constructed instances of these elements, as represented by their memory addresses.</p> <p>Moreover, the <code>Grandson</code> and <code>Granddaughter</code> are both initialized just once, despite being referenced mutiple times within the family tree, affirming the intelligent management of object creation and relationships through <code>Associations</code> and <code>Collections</code> in this family tree representation.</p>"},{"location":"Modeling/Overview/#stateforward.model--model-overview","title":"Model Overview","text":"<p>The <code>Model</code> class is an enhancement of the <code>Element</code> that includes additional features for preprocessing, validation, and interpretation, providing a structured way to represent complex entities within a system. Each <code>Element</code> nested within a <code>Model</code> is provided with a <code>model</code> attribute, granting a reference to the root <code>Model</code> instance, which allows elements to be aware of their context within the larger entity.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_3","title":"Definition","text":"<p>Model Definition</p> CodeOutput <pre><code>import stateforward as sf\n\nclass Automobile(sf.Model):\n    manufacturer: str = None\n    wheels: sf.Collection[\"Wheel\"]\n    engine: \"Engine\"\n\nclass Wheel(sf.Element):\n    size: int\n\nclass Engine(sf.Element):\n    power: int\n\nclass Car(\n    Automobile,\n    manufacturer=\"Saturn\",\n):\n    class V8(Engine, power=300):\n        pass\n\n    class FrontLeft(Wheel, size=16):\n        pass\n\n    class FrontRight(Wheel, size=16):\n        pass\n\n    class RearLeft(Wheel, size=16):\n        pass\n\n    class RearRight(Wheel, size=16):\n        pass\n\nsf.dump(Car)\nprint(Car.V8.model)\n</code></pre> <pre><code>0 -&gt; Car type[Automobile] @ 0x11861f820\n 1 -&gt; Car.V8 type[Engine] @ 0x11861d660\n 1 -&gt; Car.FrontLeft type[Wheel] @ 0x11861dd20\n 1 -&gt; Car.FrontRight type[Wheel] @ 0x11861e3e0\n 1 -&gt; Car.RearLeft type[Wheel] @ 0x11861eaa0\n 1 -&gt; Car.RearRight type[Wheel] @ 0x11861f160\n&lt;class '__main__.Car'&gt;\n</code></pre> <p>The output shows the structure of the <code>Car</code> as a <code>Model</code>, which is a concrete representation of an <code>Automobile</code>. The nested classes like <code>V8</code> and the individual wheels are displayed as <code>Element</code> types that are part of the <code>Car</code> model. It also exhibits that the <code>V8</code> class within <code>Car</code> understands it is part of the <code>Car</code> model via the <code>model</code> attribute.</p> <p>The <code>Automobile</code> model specifies that <code>manufacturer</code>, <code>wheels</code>, and an <code>engine</code> are essential components. In the context of the example, it means that a valid <code>Car</code> must have these attributes defined. However, it's important to note that the presence and correctness of these parts are not automatically checked by the <code>Model</code> or <code>Element</code> classes \u2014 a dedicated <code>Validator</code> would be required to ensure that the <code>Car</code> model adheres to the defined rules and structure of an <code>Automobile</code>.</p>"},{"location":"Modeling/Overview/#stateforward.model--validation","title":"Validation","text":"<p>The <code>Model</code> class facilitates the use of a validator which is executed once the <code>Model</code> is fully constructed. The validation occurs only once at runtime, after the entire model is built, ensuring that the instance complies with the predefined rules and requirements.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_4","title":"Definition","text":"<p>Below is an excerpt showing the incorporation of an <code>AutomobileValidator</code> for an <code>Automobile</code> <code>Model</code>. The validator checks for the presence of essential components like <code>engine</code> and <code>wheels</code>.</p> <p>Model Validation</p> CodeOutput <pre><code># ... the rest of the example above\n\nclass AutomobileValidator(sf.Validator):\n    def validate_automobile(self, automobile: type[\"Automobile\"]):\n        if automobile.engine is None:\n            raise ValueError(f\"Automobile {automobile.name} must have an engine\")\n        elif automobile.wheels is None:\n            raise ValueError(f\"Automobile {automobile.name} must have wheels\")\n\nclass Automobile(sf.Model, validator=AutomobileValidator()):\n# ... the rest of the example\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"car_model_example.py\", line 26, in &lt;module&gt;\n    class Car(\n  File \"model.py\", line 33, in __init_subclass__\n    cls.validator.validate(cls)\n  File \"validator.py\", line 35, in validate\n    self.validate_element(element)\n  File \"validator.py\", line 26, in validate_element\n    method(element.type)\n  File \"car_model_example.py\", line 7, in validate_automobile\n    raise ValueError(f\"Automobile {automobile.name} must have an engine\")\nValueError: Automobile Car must have an engine\n</code></pre> <p>In this case, the validator indicates that the <code>Car</code> class or its derivatives must include both an <code>engine</code> and <code>wheels</code> to be considered valid. However, explicitly specifying these components for every car class can be cumbersome.</p> <p>To address this, we can introduce preprocessors to the <code>Model</code>. Preprocessors can simplify the code by automatically inferring or setting default values for properties like <code>engine</code> and <code>wheels</code>, reducing verbosity and making the model definitions more efficient and less error-prone.</p>"},{"location":"Modeling/Overview/#stateforward.model--preprocessing","title":"Preprocessing","text":"<p>Preprocessors are executed as part of the <code>Model</code> construction process, taking place after the entire <code>Model</code> has been built but ahead of the validation phase. They are useful for setting up or modifying <code>Model</code> attributes based on a specific logic before the model is validated for correctness.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_5","title":"Definition","text":"<p>This extension of the earlier example incorporates a <code>Preprocessor</code> for the <code>Automobile</code> <code>Model</code>, which dynamically assigns the <code>wheels</code> and <code>engine</code> attributes by inspecting the elements present in the model.</p> <p>Model Preprocessing</p> CodeOutput <pre><code># ... continuation from the Automobile validation example\n\n# Define a Preprocessor class specific to the Automobile model\nclass AutomobilePreprocessor(sf.Preprocessor):\n    def preprocess_automobile(self, element: type[\"Automobile\"]):\n        sf.set_attribute(\n            element,\n            \"wheels\",\n            sf.collection(\n                *sf.find_owned_elements(\n                    element, lambda _element: sf.is_subtype(_element, Wheel)\n                )\n            ),\n        )\n        sf.set_attribute(\n            element,\n            \"engine\",\n            sf.find_owned_element(\n                element, lambda _element: sf.is_subtype(_element, Engine)\n            ),\n        )\n\n# Update the Automobile Model to leverage the Preprocessor and Validator\nclass Automobile(\n    sf.Model, validator=AutomobileValidator(), preprocessor=AutomobilePreprocessor()\n):\n# ... the remaining code for the Automobile model etc.\n</code></pre> <pre><code>0 -&gt; Car type[Automobile] @ 0x11d616af0\n 1 -&gt; Car.V8 type[Engine] @ 0x11d614930\n 1 -&gt; Car.FrontLeft type[Wheel] @ 0x11d614ff0\n 1 -&gt; Car.FrontRight type[Wheel] @ 0x11d6156b0\n 1 -&gt; Car.RearLeft type[Wheel] @ 0x11d615d70\n 1 -&gt; Car.RearRight type[Wheel] @ 0x11d616430\n 1 -&gt; Car.wheels type[Collection] @ 0x11d6171b0\n  2 -&gt; Car.wheels.0 type[Association&lt;Car.FrontLeft&gt;] @ 0x11d614ff0\n  2 -&gt; Car.wheels.1 type[Association&lt;Car.FrontRight&gt;] @ 0x11d6156b0\n  2 -&gt; Car.wheels.2 type[Association&lt;Car.RearLeft&gt;] @ 0x11d615d70\n  2 -&gt; Car.wheels.3 type[Association&lt;Car.RearRight&gt;] @ 0x11d616430\n 1 -&gt; Car.engine type[Association&lt;Car.V8&gt;] @ 0x11d614930\n</code></pre> <p>With the preprocessor's functionality, we've streamlined the <code>Model</code> definition process, making it less verbose and more maintainable without the need to explicitly declare <code>wheels</code> and <code>engine</code> for every <code>Automobile</code> subclass. This approach allows for easier extension and customization of the model by simply including the relevant subclass elements.</p>"},{"location":"Modeling/Overview/#stateforward.model--validator-overview","title":"Validator Overview","text":"<p>The <code>Validator</code> in the context of the <code>Model</code> functions analogously to the <code>NodeVisitor</code> found in Python\u2019s abstract syntax tree (<code>ast</code>) module. It follows a set path to discover the appropriate validation method for a given element within the structure.</p> <p>Here\u2019s an outline of the search logic:</p> <ol> <li>Element names are normalized to lowercase and converted to snake_case.</li> <li>The search attempts to find a method called <code>validate_{element.name}</code>.</li> <li>If not found, it looks for <code>validate_{element.type.name}</code>, continuing the search up the inheritance chain until <code>validate_element</code> is found or a matching method is identified.</li> <li>This search stops as soon as a validation method is discovered, and that method is executed.</li> </ol> <p>Further, if the <code>Element</code> derives from another <code>Element</code>, the base class validation methods must be explicitly called within the identified validation method; they are not called automatically.</p>"},{"location":"Modeling/Overview/#stateforward.model--definition_6","title":"Definition","text":"<p>In the example provided, different color elements are created along with a corresponding <code>Validator</code> class that contains specific validation methods.</p> <p>Validator Definition</p> CodeOutput <pre><code>import stateforward as sf\n\n# Define a Validator to handle ColorWheel and its elements\nclass ColorWheelValidator(sf.Validator):\n    # Validates a ColorWheel instance\n    def validate_color_wheel(self, element: type[\"ColorWheel\"]):\n        print(f\"validate_color_wheel({element.name})\")\n        # Invokes validation for each owned element within ColorWheel\n        self.validate_owned_elements(element)\n\n    # Validates an instance of Red, inheriting from Theme.Red\n    def validate_red(self, element: type[\"Theme.Red\"]):\n        print(\"validate_red(Red)\")\n        # Calls validation for the Color base class with an indent\n        self.validate_color(element, 2)\n\n    # Validates an instance of Green\n    def validate_green(self, element: type[\"Theme.Green\"]):\n        print(\"validate_green(Green)\")\n\n    # Validates any Color instance with an optional indent\n    def validate_color(self, element: type[\"Color\"], indent=0):\n        print(f\"{' ' * indent}validate_color({element.name})\")\n\n# Define a generic Color Element\nclass Color(sf.Element):\n    pass\n\n# Define a ColorWheel Model, which incorporates the Validator\nclass ColorWheel(sf.Model, validator=ColorWheelValidator()):\n    pass\n\n# Define a Theme Model that inherits from ColorWheel and includes color elements\nclass Theme(ColorWheel):\n    class Red(Color):\n        pass\n\n    class Green(Color):\n        pass\n\n    class Blue(Color):\n        pass\n\n# The output will demonstrate the Validator searching for and executing\n# validation rules for the Theme Model's color elements\n</code></pre> <p>The console output should indicate that the Validator successfully navigates through the elements, invoking the corresponding validation methods: <pre><code>validate_color_wheel(Theme)\nvalidate_red(Red)\n  validate_color(Red)\nvalidate_green(Green)\nvalidate_color(Blue)\n</code></pre></p> <p>In the bullet points, it is explained how each color's validation method is resolved, showcasing the Validator's logic:</p> <ol> <li>The <code>Blue</code> color is validated using <code>validate_color</code> directly, as there is no explicit <code>validate_blue</code> method available.</li> <li><code>validate_color</code> is not called for the <code>Green</code> color because <code>validate_green</code> is already present and does not call <code>validate_color</code>.</li> <li><code>validate_color</code> is invoked for the <code>Red</code> color due to an explicit call within <code>validate_red</code>.</li> <li><code>validate_owned_elements</code> is used in the <code>ColorWheel</code> validator, ensuring that all owned elements (<code>Red</code>, <code>Green</code>, and <code>Blue</code>) get validated. This step is vital because element validation would not occur without it.</li> </ol> <p>By defining and structuring the Validator and validation methods correctly, developers can enforce specific validation rules tailored to their <code>Model</code> structure and ensure that all elements comply with the defined criteria.</p>"},{"location":"Modeling/Overview/#stateforward.model--preprocessor-overview","title":"Preprocessor Overview","text":"<p>The preprocessor in the <code>stateforward</code> library operates identically to the <code>Validator</code>, with the key difference being the timing of its invocation. It is called before the validation phase, which allows it to modify or augment the <code>Model</code> structure prior to any checks for correctness. The primary role of the <code>Preprocessor</code> is to streamline the model construction process, adding convenience and reducing code verbosity, thus enhancing the clarity and maintainability of the model definitions.</p> <p>The <code>Preprocessor</code> follows a search pattern similar to the <code>Validator</code> to determine the appropriate processing method for a given element:</p> <ol> <li>Element names are converted to lowercase and snake_case for standardization.</li> <li>It seeks a method with the signature <code>preprocess_{element.name}</code>.</li> <li>Failing that, it looks for <code>preprocess_{element.type.name}</code>, proceeding recursively up the inheritance hierarchy until either <code>preprocess_element</code> is found or a suitable method is located.</li> <li>Once a preprocessing method is identified, the search concludes and that method is executed.</li> </ol> <p>Should an <code>Element</code> inherit from another <code>Element</code>, base preprocessing functions are not automatically invoked. They must be explicitly called within the identified preprocessing method.</p> <p>While the preprocessor can perform a wide range of tasks, common uses include auto-filling attributes with default values, organizing collections of elements, and setting up links or associations between parts of the model. This enables developers to define elegant and concise models that automatically adjust to include necessary attributes or sub-elements, thus freeing them from repetitive boilerplate code.</p> <p>The <code>Preprocessor</code> is a powerful tool within the <code>stateforward</code> library that aids in simplifying complex model preparation while ensuring a solid foundation for subsequent validation steps.</p>"},{"location":"Modeling/Overview/#stateforward.model--interpreter-overview","title":"Interpreter Overview","text":"<p>The <code>Interpreter</code> is an abstract class responsible for executing a <code>Model</code>.</p>"},{"location":"Modeling/API/Collection/","title":"Collection","text":""},{"location":"Modeling/API/Collection/#stateforward.model.collection.Collection","title":"Collection","text":"<p>             Bases: <code>Element[T]</code></p> <p>A representation of a collection of Elements.</p> <p>This class inherits from <code>Element</code>, allowing collections to be first-class citizens in the model, just like any other element. It adds sequential collection functionality.</p> <p>Attributes:</p> Name Type Description <code>length</code> <code>int</code> <p>The number of elements in the collection.</p> <p>Methods:</p> Name Description <code>elements</code> <p>Returns a generator yielding each Element in the collection.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>class Collection(Element[T]):\n    \"\"\"\n    A representation of a collection of Elements.\n\n    This class inherits from `Element`, allowing collections to be first-class citizens in the\n    model, just like any other element. It adds sequential collection functionality.\n\n    Attributes:\n        length (int): The number of elements in the collection.\n\n    Methods:\n        elements: Returns a generator yielding each Element in the collection.\n    \"\"\"\n\n    length: int = 0\n\n    @instance_or_classmethod\n    def elements(self: \"CollectionType\") -&gt; Generator[\"ElementType\", None, None]:\n        for index in range(self.length):\n            yield self.attributes[index]\n\n    def __len__(self):\n        return self.length\n\n    def __iter__(self):\n        return self.elements()\n\n    def __getitem__(self, index):\n        return self.attributes[index if index &gt;= 0 else self.length + index]\n</code></pre>"},{"location":"Modeling/API/Collection/#stateforward.model.collection.collection","title":"collection","text":"<pre><code>collection(*elements: Sequence[ElementType], name: str = None) -&gt; ElementType\n</code></pre> <p>Create a new collection element that contains a sequence of elements.</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Sequence[ElementType]</code> <p>One or more ElementType instances to be added to the collection.</p> <code>()</code> <code>name</code> <code>str</code> <p>The name assigned to this collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ElementType</code> <code>ElementType</code> <p>A new Collection instance containing the provided elements.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def collection(\n    *elements: Sequence[ElementType],\n    name: str = None,\n) -&gt; ElementType:\n    \"\"\"\n    Create a new collection element that contains a sequence of elements.\n\n    Args:\n        *elements (Sequence[ElementType]): One or more ElementType instances to be added to the collection.\n        name (str, optional): The name assigned to this collection. Defaults to None.\n\n    Returns:\n        ElementType: A new Collection instance containing the provided elements.\n    \"\"\"\n    new_collection = new_element(\n        bases=(Collection,),\n        length=len(elements),\n        name=name,\n    )\n    for index, element in enumerate(elements):\n        if element.owner is None:\n            add_owned_element(new_collection, element)\n        set_attribute(new_collection, index, association(element))\n    return new_collection\n</code></pre>"},{"location":"Modeling/API/Collection/#stateforward.model.collection.extend_collection","title":"extend_collection","text":"<pre><code>extend_collection(collection_element: Type[Collection], *elements: Sequence[ElementType])\n</code></pre> <p>Extend a collection by adding one or more new elements.</p> <p>Parameters:</p> Name Type Description Default <code>collection_element</code> <code>Type[Collection]</code> <p>The Collection to be extended.</p> required <code>*elements</code> <code>Sequence[ElementType]</code> <p>The sequence of new elements to be added to the collection.</p> <code>()</code> Source code in <code>stateforward/model/collection.py</code> <pre><code>def extend_collection(\n    collection_element: Type[Collection], *elements: Sequence[ElementType]\n):\n    \"\"\"\n    Extend a collection by adding one or more new elements.\n\n    Args:\n        collection_element (Type[Collection]): The Collection to be extended.\n        *elements (Sequence[ElementType]): The sequence of new elements to be added to the collection.\n    \"\"\"\n    for element in elements:\n        set_attribute(collection_element, collection_element.length, element)\n        collection_element.length += 1\n</code></pre>"},{"location":"Modeling/API/Collection/#stateforward.model.collection.is_collection","title":"is_collection","text":"<pre><code>is_collection(value: Any) -&gt; bool\n</code></pre> <p>Check if a given value is a subtype of Collection.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to be checked against the Collection type.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the value is a subtype of Collection, <code>False</code> otherwise.</p> Source code in <code>stateforward/model/collection.py</code> <pre><code>def is_collection(value: Any) -&gt; bool:\n    \"\"\"\n    Check if a given value is a subtype of Collection.\n\n    Args:\n        value (Any): The value to be checked against the Collection type.\n\n    Returns:\n        bool: `True` if the value is a subtype of Collection, `False` otherwise.\n    \"\"\"\n    return is_subtype(value, (Collection,))\n</code></pre>"},{"location":"Modeling/API/Collection/#stateforward.model.collection.sort_collection","title":"sort_collection","text":"<pre><code>sort_collection(element: Type[Collection], key=None, reverse=False)\n</code></pre> <p>Sort the elements of the collection in place.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Collection]</code> <p>The Collection type to be sorted.</p> required <code>key</code> <code>callable</code> <p>A function that serves as a key for the sort comparison.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If <code>True</code>, the sorted list is reversed (or sorted in descending order). Defaults to False.</p> <code>False</code> Source code in <code>stateforward/model/collection.py</code> <pre><code>def sort_collection(element: Type[Collection], key=None, reverse=False):\n    \"\"\"\n    Sort the elements of the collection in place.\n\n    Args:\n        element (Type[Collection]): The Collection type to be sorted.\n        key (callable, optional): A function that serves as a key for the sort comparison.\n        reverse (bool, optional): If `True`, the sorted list is reversed (or sorted in descending order).\n            Defaults to False.\n    \"\"\"\n    sorted_elements = sorted(\n        (element.attributes[x] for x in range(element.length)), key=key, reverse=reverse\n    )\n    for index, _element in enumerate(sorted_elements):\n        element.attributes[index] = _element\n</code></pre>"},{"location":"Modeling/API/Element/","title":"Element","text":""},{"location":"Modeling/API/Element/#stateforward.model.Element","title":"Element","text":"<p>             Bases: <code>ElementInterface[T]</code></p> <p>Element is the base class for all elements in the model.</p> <p>The Element class extends ElementInterface and provides a default implementation of several methods. It supports customization via the 'init_subclass' and 'define' methods, which allows properties and behavior specific to a given element to be set up.</p> <p>Attributes:</p> Name Type Description <code>associations</code> <code>dict[str, Association]</code> <p>A dictionary of association proxies where keys are attribute names.</p> <code>owned_elements</code> <code>Union[list[ElementType], list[T]]</code> <p>A list of elements that are owned by this element.</p> <code>owner</code> <code>Optional[Association[ElementType]]</code> <p>A proxy to the owner element, if any.</p> <code>model</code> <code>Association[Model]</code> <p>A proxy to the model that owns this element.</p> <code>attributes</code> <code>dict[Any, Any]</code> <p>A dictionary of this element's attributes.</p> Type Parameters <p>T: The type variable associated with the element.</p> <p>Methods:</p> Name Description <code>__init_subclass__</code> <p>Allows subclasses to be initialized with custom attributes and behavior.</p> <code>__define__</code> <p>Allows for the definition of owned elements and other properties.</p> <code>__new__</code> <p>Overrides the default object instantiation behavior.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>class Element(ElementInterface[T]):\n    \"\"\"\n    Element is the base class for all elements in the model.\n\n    The Element class extends ElementInterface and provides a default implementation of several methods.\n    It supports customization via the '__init_subclass__' and '__define__' methods, which allows\n    properties and behavior specific to a given element to be set up.\n\n    Attributes:\n        associations (dict[str, Association]): A dictionary of association proxies where keys are attribute names.\n        owned_elements (Union[list[\"ElementType\"], list[T]]): A list of elements that are owned by this element.\n        owner (Optional[Association[\"ElementType\"]]): A proxy to the owner element, if any.\n        model (Association[\"Model\"]): A proxy to the model that owns this element.\n        attributes (dict[Any, Any]): A dictionary of this element's attributes.\n\n    Type Parameters:\n        T: The type variable associated with the element.\n\n    Methods:\n        __init_subclass__: Allows subclasses to be initialized with custom attributes and behavior.\n        __define__: Allows for the definition of owned elements and other properties.\n        __new__: Overrides the default object instantiation behavior.\n    \"\"\"\n\n    __init__: Callable[P, None] = object.__init__\n\n    def __init_subclass__(\n        cls: type[\"Element\"],\n        name: str = None,\n        redefined_element: \"ElementType\" = None,\n        **kwargs: dict,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a new subclass of Element.\n\n        Invoked when a new subclass of Element is defined in order to customize\n        element-specific attributes, associations, and owned elements.\n        Supports specialization of the base class by copying inherited elements\n        and setting up attributes.\n\n        Parameters:\n        - cls (type[\"Element\"]): The class object representing the subclass being initialized.\n        - name (str, optional): The name of the element. If not provided, defaults to the name of the subclass.\n        - redefined_element (ElementType, optional): The element that the subclass redefines.\n        - **kwargs (dict): Additional keyword arguments containing attribute initializations which are not directly handled.\n\n        Raises:\n        - TypeError: If an unexpected keyword is encountered in element initializations.\n\n        Note:\n        - Redefined elements allow subclassing elements to replace or extend the behavior of inherited features.\n        - The method also takes care of handling the owned elements through specialization.\n        - Attributes like \"owning association\" and \"model\" are set here.\n        \"\"\"\n        attributes = cls.attributes = (cls.attributes or {}).copy()\n        for key in kwargs:\n            if key not in attributes and key not in ElementInterface.__annotations__:\n                raise TypeError(\n                    f\"{name or cls.__name__}.__init_subclass__ got an unexpected keyword {key}\"\n                )\n        cls.owned_elements = []\n        cls.name = name or cls.__name__\n        cls.qualified_name = cls.__qualname__\n        cls.owner = None\n        cls.type = cls\n        cls.model = association(cls)\n        cls.associations = {}\n        cls.redefined_element = redefined_element or cls.redefined_element\n        if cls.__base__.owned_elements:\n            specialize(cls.__base__, cls)\n        if redefined_element is None:\n            cls.__define__(name=name, **kwargs)\n        else:\n            cls.__redefine__(redefined_element=cls.redefined_element, **kwargs)\n\n    @classmethod\n    def __redefine__(cls, **kwargs):\n        for key, value in kwargs.items():\n            set_attribute(cls, key, value)\n\n    @classmethod\n    def __define__(\n        cls: type[\"Element\"],\n        name: str = None,\n        owned_elements: Sequence[\"ElementType\"] = (),\n        **kwargs: dict,\n    ) -&gt; None:\n        \"\"\"\n        Define the class-level attributes for the Element class or subclass.\n\n        This method is used to set up the owned elements and any additional\n        attributes passed in the kwargs. It ensures that owned elements are\n        properly added and that each additional attribute is set on the class\n        if it's not already defined in the `ElementInterface`.\n\n        Args:\n            cls (type[Element]): The class on which to define the attributes.\n            name (str): The name of the element. If not provided, the __name__ attribute of the class will be used.\n            owned_elements (Sequence[ElementType]): A sequence of ElementType objects that are owned by this element.\n            **kwargs (dict): Additional keyword arguments representing the attributes to be set on the class.\n\n        Raises:\n            TypeError: If an unexpected keyword argument is provided that is not part of the class attributes or annotations.\n        \"\"\"\n        for owned_element in owned_elements:\n            add_owned_element(cls, owned_element)\n        for key, value in {\n            **dict((name, getattr(cls, name, MISSING)) for name in cls.__annotations__),\n            **cls.__dict__,\n            **kwargs,\n        }.items():\n            if (\n                f\"{key[-2:]}{key[:2]}\" != \"____\"\n                and key not in ElementInterface.__annotations__\n            ):\n                set_attribute(cls, key, value)\n\n    @staticmethod\n    def __new__(\n        cls: type[\"Element\"],\n        *args: Sequence[Any],\n        **kwargs: dict,\n    ) -&gt; Union[\"Element\", Callable[[], \"Element\"]]:\n        \"\"\"\n        Create a new instance or a callable to instantiate the Element class.\n\n        This method intercepts the creation of a new Element object to support\n        custom initialization logic, such as setting up owned elements and attributes\n        before calling __init__. If no owner is specified, this method returns the\n        created instance directly. If an owner is given, a lambda function delaying\n        the call to __init__ is returned instead.\n\n        Parameters:\n        - cls (type[Element]): The class object from which an instance is created.\n        - *args (Sequence[Any]): Variable length argument list.\n        - **kwargs (dict): Arbitrary keyword arguments.\n\n        Returns:\n        - Union[Element, Callable[[], Element]]: An instance of the Element class or\n          a callable that, when called, returns an instance of the Element class.\n        \"\"\"\n\n        self = super().__new__(cls)\n        self.owner = kwargs.pop(\"owner\", None)\n        self.owned_elements = []\n        self.attributes = {}\n        self.model = self.owner.model if self.owner is not None else self\n        element_map = kwargs.pop(\n            \"element_map\", {self.qualified_name: self}\n        )  # create a namespace for the elements in the element\n        for owned_element in cls.owned_elements:\n            instance = owned_element(\n                owner=self,\n                element_map=element_map,\n            )()  # using the extra function call to prevent __init__ from being called\n            element_map[owned_element.qualified_name] = instance\n            self.owned_elements.append(instance)\n        if self.owner is None:\n            for element in reversed(element_map.values()):\n                for name, value in element.__class__.attributes.items():\n                    if is_element(value):\n                        value = element.attributes[name] = element_map[\n                            value.qualified_name\n                        ]\n                        setattr(element, str(name), value)\n                if element is not self:\n                    element.__init__(**kwargs.pop(element.qualified_name, {}))\n            # this is the root element of the element, so we can start initializing\n            return self\n        # a hack to prevent __init__ from being called\n        return lambda _self=self: _self\n</code></pre>"},{"location":"Modeling/API/Element/#stateforward.model.Element.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(name: str = None, redefined_element: ElementType = None, **kwargs: dict) -&gt; None\n</code></pre> <p>Initialize a new subclass of Element.</p> <p>Invoked when a new subclass of Element is defined in order to customize element-specific attributes, associations, and owned elements. Supports specialization of the base class by copying inherited elements and setting up attributes.</p> <p>Parameters: - cls (type[\"Element\"]): The class object representing the subclass being initialized. - name (str, optional): The name of the element. If not provided, defaults to the name of the subclass. - redefined_element (ElementType, optional): The element that the subclass redefines. - **kwargs (dict): Additional keyword arguments containing attribute initializations which are not directly handled.</p> <p>Raises: - TypeError: If an unexpected keyword is encountered in element initializations.</p> <p>Note: - Redefined elements allow subclassing elements to replace or extend the behavior of inherited features. - The method also takes care of handling the owned elements through specialization. - Attributes like \"owning association\" and \"model\" are set here.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>def __init_subclass__(\n    cls: type[\"Element\"],\n    name: str = None,\n    redefined_element: \"ElementType\" = None,\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"\n    Initialize a new subclass of Element.\n\n    Invoked when a new subclass of Element is defined in order to customize\n    element-specific attributes, associations, and owned elements.\n    Supports specialization of the base class by copying inherited elements\n    and setting up attributes.\n\n    Parameters:\n    - cls (type[\"Element\"]): The class object representing the subclass being initialized.\n    - name (str, optional): The name of the element. If not provided, defaults to the name of the subclass.\n    - redefined_element (ElementType, optional): The element that the subclass redefines.\n    - **kwargs (dict): Additional keyword arguments containing attribute initializations which are not directly handled.\n\n    Raises:\n    - TypeError: If an unexpected keyword is encountered in element initializations.\n\n    Note:\n    - Redefined elements allow subclassing elements to replace or extend the behavior of inherited features.\n    - The method also takes care of handling the owned elements through specialization.\n    - Attributes like \"owning association\" and \"model\" are set here.\n    \"\"\"\n    attributes = cls.attributes = (cls.attributes or {}).copy()\n    for key in kwargs:\n        if key not in attributes and key not in ElementInterface.__annotations__:\n            raise TypeError(\n                f\"{name or cls.__name__}.__init_subclass__ got an unexpected keyword {key}\"\n            )\n    cls.owned_elements = []\n    cls.name = name or cls.__name__\n    cls.qualified_name = cls.__qualname__\n    cls.owner = None\n    cls.type = cls\n    cls.model = association(cls)\n    cls.associations = {}\n    cls.redefined_element = redefined_element or cls.redefined_element\n    if cls.__base__.owned_elements:\n        specialize(cls.__base__, cls)\n    if redefined_element is None:\n        cls.__define__(name=name, **kwargs)\n    else:\n        cls.__redefine__(redefined_element=cls.redefined_element, **kwargs)\n</code></pre>"},{"location":"Modeling/API/Element/#stateforward.model.Element.__define__","title":"__define__  <code>classmethod</code>","text":"<pre><code>__define__(name: str = None, owned_elements: Sequence[ElementType] = (), **kwargs: dict) -&gt; None\n</code></pre> <p>Define the class-level attributes for the Element class or subclass.</p> <p>This method is used to set up the owned elements and any additional attributes passed in the kwargs. It ensures that owned elements are properly added and that each additional attribute is set on the class if it's not already defined in the <code>ElementInterface</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Element]</code> <p>The class on which to define the attributes.</p> required <code>name</code> <code>str</code> <p>The name of the element. If not provided, the name attribute of the class will be used.</p> <code>None</code> <code>owned_elements</code> <code>Sequence[ElementType]</code> <p>A sequence of ElementType objects that are owned by this element.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments representing the attributes to be set on the class.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an unexpected keyword argument is provided that is not part of the class attributes or annotations.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __define__(\n    cls: type[\"Element\"],\n    name: str = None,\n    owned_elements: Sequence[\"ElementType\"] = (),\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"\n    Define the class-level attributes for the Element class or subclass.\n\n    This method is used to set up the owned elements and any additional\n    attributes passed in the kwargs. It ensures that owned elements are\n    properly added and that each additional attribute is set on the class\n    if it's not already defined in the `ElementInterface`.\n\n    Args:\n        cls (type[Element]): The class on which to define the attributes.\n        name (str): The name of the element. If not provided, the __name__ attribute of the class will be used.\n        owned_elements (Sequence[ElementType]): A sequence of ElementType objects that are owned by this element.\n        **kwargs (dict): Additional keyword arguments representing the attributes to be set on the class.\n\n    Raises:\n        TypeError: If an unexpected keyword argument is provided that is not part of the class attributes or annotations.\n    \"\"\"\n    for owned_element in owned_elements:\n        add_owned_element(cls, owned_element)\n    for key, value in {\n        **dict((name, getattr(cls, name, MISSING)) for name in cls.__annotations__),\n        **cls.__dict__,\n        **kwargs,\n    }.items():\n        if (\n            f\"{key[-2:]}{key[:2]}\" != \"____\"\n            and key not in ElementInterface.__annotations__\n        ):\n            set_attribute(cls, key, value)\n</code></pre>"},{"location":"Modeling/API/Element/#stateforward.model.Element.__new__","title":"__new__  <code>staticmethod</code>","text":"<pre><code>__new__(*args: Sequence[Any], **kwargs: dict) -&gt; Union[Element, Callable[[], Element]]\n</code></pre> <p>Create a new instance or a callable to instantiate the Element class.</p> <p>This method intercepts the creation of a new Element object to support custom initialization logic, such as setting up owned elements and attributes before calling init. If no owner is specified, this method returns the created instance directly. If an owner is given, a lambda function delaying the call to init is returned instead.</p> <p>Parameters: - cls (type[Element]): The class object from which an instance is created. - args (Sequence[Any]): Variable length argument list. - *kwargs (dict): Arbitrary keyword arguments.</p> <ul> <li>Union[Element, Callable[[], Element]]: An instance of the Element class or   a callable that, when called, returns an instance of the Element class.</li> </ul> Source code in <code>stateforward/model/element.py</code> <pre><code>@staticmethod\ndef __new__(\n    cls: type[\"Element\"],\n    *args: Sequence[Any],\n    **kwargs: dict,\n) -&gt; Union[\"Element\", Callable[[], \"Element\"]]:\n    \"\"\"\n    Create a new instance or a callable to instantiate the Element class.\n\n    This method intercepts the creation of a new Element object to support\n    custom initialization logic, such as setting up owned elements and attributes\n    before calling __init__. If no owner is specified, this method returns the\n    created instance directly. If an owner is given, a lambda function delaying\n    the call to __init__ is returned instead.\n\n    Parameters:\n    - cls (type[Element]): The class object from which an instance is created.\n    - *args (Sequence[Any]): Variable length argument list.\n    - **kwargs (dict): Arbitrary keyword arguments.\n\n    Returns:\n    - Union[Element, Callable[[], Element]]: An instance of the Element class or\n      a callable that, when called, returns an instance of the Element class.\n    \"\"\"\n\n    self = super().__new__(cls)\n    self.owner = kwargs.pop(\"owner\", None)\n    self.owned_elements = []\n    self.attributes = {}\n    self.model = self.owner.model if self.owner is not None else self\n    element_map = kwargs.pop(\n        \"element_map\", {self.qualified_name: self}\n    )  # create a namespace for the elements in the element\n    for owned_element in cls.owned_elements:\n        instance = owned_element(\n            owner=self,\n            element_map=element_map,\n        )()  # using the extra function call to prevent __init__ from being called\n        element_map[owned_element.qualified_name] = instance\n        self.owned_elements.append(instance)\n    if self.owner is None:\n        for element in reversed(element_map.values()):\n            for name, value in element.__class__.attributes.items():\n                if is_element(value):\n                    value = element.attributes[name] = element_map[\n                        value.qualified_name\n                    ]\n                    setattr(element, str(name), value)\n            if element is not self:\n                element.__init__(**kwargs.pop(element.qualified_name, {}))\n        # this is the root element of the element, so we can start initializing\n        return self\n    # a hack to prevent __init__ from being called\n    return lambda _self=self: _self\n</code></pre>"},{"location":"Modeling/API/ElementInterface/","title":"ElementInterface","text":""},{"location":"Modeling/API/ElementInterface/#stateforward.model.element.ElementInterface","title":"ElementInterface","text":"<p>             Bases: <code>Generic[T]</code></p> <p>ElementInterface provides a common interface for elements in the model.</p> <p>This interface defines a generic contract with attributes commonly shared among elements such as associations, owned elements, and model references.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>ClassVar[str]</code> <p>The name of the element.</p> <code>qualified_name</code> <code>ClassVar[str]</code> <p>A fully qualified name that uniquely identifies the element.</p> <code>type</code> <code>ClassVar[Type[Element]]</code> <p>The concrete type of the element.</p> <code>redefined_element</code> <code>ClassVar[Type[Element]]</code> <p>The element that is redefined by this element.</p> <code>associations</code> <code>dict[str, Association]</code> <p>A dictionary of association proxies where keys are attribute names.</p> <code>owned_elements</code> <code>Union[list[ElementType], list[T]]</code> <p>A list of elements that are owned by this element.</p> <code>owner</code> <code>Optional[Association[ElementType]]</code> <p>A proxy to the owner element, if any.</p> <code>model</code> <code>Association[Model]</code> <p>A proxy to the model that owns this element.</p> <code>attributes</code> <code>dict[Any, Any]</code> <p>A dictionary of this element's attributes.</p> Type Parameters <p>T: The type variable associated with the element.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>class ElementInterface(Generic[T]):\n    \"\"\"\n    ElementInterface provides a common interface for elements in the model.\n\n    This interface defines a generic contract with attributes commonly shared among elements\n    such as associations, owned elements, and model references.\n\n    Attributes:\n        name (ClassVar[str]): The name of the element.\n        qualified_name (ClassVar[str]): A fully qualified name that uniquely identifies the element.\n        type (ClassVar[Type[\"Element\"]]): The concrete type of the element.\n        redefined_element (ClassVar[Type[\"Element\"]]): The element that is redefined by this element.\n        associations (dict[str, Association]): A dictionary of association proxies where keys are attribute names.\n        owned_elements (Union[list[\"ElementType\"], list[T]]): A list of elements that are owned by this element.\n        owner (Optional[Association[\"ElementType\"]]): A proxy to the owner element, if any.\n        model (Association[\"Model\"]): A proxy to the model that owns this element.\n        attributes (dict[Any, Any]): A dictionary of this element's attributes.\n\n    Type Parameters:\n        T: The type variable associated with the element.\n    \"\"\"\n\n    # class variables\n    name: ClassVar[str] = None\n    qualified_name: ClassVar[str] = None\n    type: ClassVar[Type[\"Element\"]] = None\n    redefined_element: ClassVar[Type[\"Element\"]] = None\n\n    # class &amp; instance variables\n    associations: dict[str, Association] = None\n    owned_elements: Union[list[\"ElementType\"], list[T]] = None\n    owner: Optional[Association[\"ElementType\"]] = None\n    model: Association[\"Model\"] = None\n    attributes: dict[Any, Any] = None\n</code></pre>"},{"location":"Modeling/API/Model/","title":"Model","text":""},{"location":"Modeling/API/Model/#stateforward.model.Model","title":"Model","text":"<p>             Bases: <code>Element</code></p> <p>A base Model class for handling processing elements.</p> <p><code>Model</code> serves as a template for creating models which include preprocessing, validation, and interpretation logic. Subclasses of Model should define their specific processing behavior.</p> <p>Attributes:</p> Name Type Description <code>preprocessor</code> <code>ClassVar[Preprocessor]</code> <p>A class-level attribute that holds a <code>Preprocessor</code> instance or None by default. The <code>Preprocessor</code> instance is responsible for preparing input data for the model.</p> <code>validator</code> <code>ClassVar[Validator]</code> <p>A class-level attribute that holds a <code>Validator</code> instance or None by default. The <code>Validator</code> instance is responsible for ensuring that the model's input data is valid.</p> <code>interpreter</code> <code>ClassVar[type[Interpreter]]</code> <p>A class-level attribute that holds a 'Interpreter' class or None by default. The 'Interpreter' class is responsible for interpreting the model's output.</p> <p>To create a subclass of Model with specific processing components:</p> <pre><code>class MyModel(Model, preprocessor=MyPreprocessor, validator=MyValidator,\n              interpreter=MyInterpreter):\n    pass\n</code></pre> <p>When creating a subclass, if specific processors are not provided, the class-level attributes from the <code>Model</code> base class will be used.</p> Note <ul> <li>If a preprocessor is provided and a preprocessor already exists, the   existing one's <code>preprocess</code> method will be called before it is replaced.</li> <li>Similarly, if a validator is provided and a validator already exists, the   existing one's <code>validate</code> method will be called before it is replaced.</li> </ul> Source code in <code>stateforward/model/model.py</code> <pre><code>class Model(Element):\n    \"\"\"A base Model class for handling processing elements.\n\n    `Model` serves as a template for creating models which include preprocessing,\n    validation, and interpretation logic. Subclasses of Model should define their\n    specific processing behavior.\n\n    Attributes:\n        preprocessor (ClassVar[Preprocessor], optional): A class-level attribute\n            that holds a `Preprocessor` instance or None by default. The `Preprocessor`\n            instance is responsible for preparing input data for the model.\n        validator (ClassVar[Validator], optional): A class-level attribute that\n            holds a `Validator` instance or None by default. The `Validator` instance is\n            responsible for ensuring that the model's input data is valid.\n        interpreter (ClassVar[type[Interpreter]], optional): A class-level attribute\n            that holds a 'Interpreter' class or None by default. The 'Interpreter'\n            class is responsible for interpreting the model's output.\n\n    To create a subclass of Model with specific processing components:\n\n    ```python\n    class MyModel(Model, preprocessor=MyPreprocessor, validator=MyValidator,\n                  interpreter=MyInterpreter):\n        pass\n    ```\n\n    When creating a subclass, if specific processors are not provided, the\n    class-level attributes from the `Model` base class will be used.\n\n    Note:\n        - If a preprocessor is provided and a preprocessor already exists, the\n          existing one's `preprocess` method will be called before it is replaced.\n        - Similarly, if a validator is provided and a validator already exists, the\n          existing one's `validate` method will be called before it is replaced.\n    \"\"\"\n\n    preprocessor: ClassVar[Type[\"Preprocessor\"]] = None\n    validator: ClassVar[Type[\"Validator\"]] = None\n    interpreter: ClassVar[Type[\"Interpreter\"]] = None\n\n    def __init_subclass__(\n        cls: type[\"Model\"],\n        preprocessor: Optional[type[\"Preprocessor\"]] = None,\n        validator: Optional[type[\"Validator\"]] = None,\n        processor: Optional[type[\"Interpreter\"]] = None,\n        **kwargs: dict,\n    ):\n        \"\"\"Initializes the subclass with the provided processors.\n\n        This magic method is automatically called during the creation of a subclass\n        and updates the subclass's preprocessor, validator, and interpreter with the\n        provided arguments if they are not None; otherwise, it retains the existing\n        processors from the base class.\n\n        Args:\n            cls: The subclass of `Model` being initialized.\n            preprocessor: An instance or class of\n                a `Preprocessor`.\n            validator: An instance or class of a `Validator`.\n            processor: A class of `Interpreter`.\n            **kwargs: Arbitrary keyword arguments that are passed to the base\n                class's `__init_subclass__` method.\n        \"\"\"\n        super().__init_subclass__(**kwargs)\n        if cls.preprocessor is not None:\n            cls.preprocessor().preprocess(cls)\n        cls.preprocessor = preprocessor or cls.preprocessor\n        if cls.validator is not None:\n            cls.validator().validate(cls)\n        cls.validator = validator or cls.validator\n</code></pre>"},{"location":"Modeling/API/Model/#stateforward.model.Model.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(preprocessor: Optional[type[Preprocessor]] = None, validator: Optional[type[Validator]] = None, processor: Optional[type[Interpreter]] = None, **kwargs: dict)\n</code></pre> <p>Initializes the subclass with the provided processors.</p> <p>This magic method is automatically called during the creation of a subclass and updates the subclass's preprocessor, validator, and interpreter with the provided arguments if they are not None; otherwise, it retains the existing processors from the base class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Model]</code> <p>The subclass of <code>Model</code> being initialized.</p> required <code>preprocessor</code> <code>Optional[type[Preprocessor]]</code> <p>An instance or class of a <code>Preprocessor</code>.</p> <code>None</code> <code>validator</code> <code>Optional[type[Validator]]</code> <p>An instance or class of a <code>Validator</code>.</p> <code>None</code> <code>processor</code> <code>Optional[type[Interpreter]]</code> <p>A class of <code>Interpreter</code>.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Arbitrary keyword arguments that are passed to the base class's <code>__init_subclass__</code> method.</p> <code>{}</code> Source code in <code>stateforward/model/model.py</code> <pre><code>def __init_subclass__(\n    cls: type[\"Model\"],\n    preprocessor: Optional[type[\"Preprocessor\"]] = None,\n    validator: Optional[type[\"Validator\"]] = None,\n    processor: Optional[type[\"Interpreter\"]] = None,\n    **kwargs: dict,\n):\n    \"\"\"Initializes the subclass with the provided processors.\n\n    This magic method is automatically called during the creation of a subclass\n    and updates the subclass's preprocessor, validator, and interpreter with the\n    provided arguments if they are not None; otherwise, it retains the existing\n    processors from the base class.\n\n    Args:\n        cls: The subclass of `Model` being initialized.\n        preprocessor: An instance or class of\n            a `Preprocessor`.\n        validator: An instance or class of a `Validator`.\n        processor: A class of `Interpreter`.\n        **kwargs: Arbitrary keyword arguments that are passed to the base\n            class's `__init_subclass__` method.\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    if cls.preprocessor is not None:\n        cls.preprocessor().preprocess(cls)\n    cls.preprocessor = preprocessor or cls.preprocessor\n    if cls.validator is not None:\n        cls.validator().validate(cls)\n    cls.validator = validator or cls.validator\n</code></pre>"},{"location":"Modeling/API/Preprocessor/","title":"Preprocessor","text":""},{"location":"Modeling/API/Preprocessor/#stateforward.model.preprocessor.Preprocessor","title":"Preprocessor","text":"<p>Preprocessor transforms UML model elements before they are validated.</p> <p>The Preprocessor traverses each element in the model starting from the root and applies pre-processing methods based on their types. The process involves calling specific preprocess methods that handle different kinds of UML elements such as Vertex, State, Transition, etc.</p> <p>Attributes:</p> Name Type Description <code>preprocessed</code> <code>set</code> <p>A set that keeps track of already preprocessed elements by their qualified names to avoid                  redoing the preprocessing.</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>class Preprocessor:\n    \"\"\"\n    Preprocessor transforms UML model elements before they are validated.\n\n    The Preprocessor traverses each element in the model starting from the root and applies pre-processing methods\n    based on their types. The process involves calling specific preprocess methods that handle different kinds of UML\n    elements such as Vertex, State, Transition, etc.\n\n    Attributes:\n        preprocessed (set): A set that keeps track of already preprocessed elements by their qualified names to avoid\n                             redoing the preprocessing.\n\n    \"\"\"\n\n    def __init__(self):\n        self.preprocessed = set()\n\n    def preprocess_element(self, element: Type[model.Element]):\n        \"\"\"\n        Process a single element, applying preprocessing logic based on its type.\n\n        This method iterates through the MRO (Method Resolution Order) of the provided\n        element class and applies specific preprocessing logic for the first matching base\n        class found in the class hierarchy. This is achieved by calling the corresponding\n        method named 'preprocess_{element_class_name_in_snake_case}'. If no specific\n        preprocessing method is found, owned elements of the class are preprocessed.\n\n        Parameters:\n        - element (Type[Element]): The element class to be preprocessed.\n\n        Returns:\n        None\n        \"\"\"\n        if (\n            not model.is_redefined(element)\n            and element.qualified_name not in self.preprocessed\n        ):\n            self.preprocessed.add(element.qualified_name)\n            for base in element.__mro__:\n                method = getattr(\n                    self,\n                    f\"preprocess_{TITLE_CASE_PATTERN.sub(UNDERSCORE_REPLACE_PATTERN, base.__name__).lower()}\",\n                    None,\n                )\n                if method not in (None, self.preprocess_element):\n                    method(element.type)\n                    break\n            self.preprocess_owned_elements(element.type)\n\n    def preprocess_owned_elements(self, element: Type[model.Element]):\n        \"\"\"\n        Preprocesses all owned elements of the given element by recursively applying\n        the preprocessor method for each owned element.\n\n        Each owned element's specific preprocessing method is invoked based on its type\n        hierarchy. This method iterates over all of the owned elements and processes\n        them accordingly.\n\n        Args:\n            element (Type[Element]): The element whose owned elements should be preprocessed.\n\n        Raises:\n            ValueError: If an owned element's type or processing conditions are invalid,\n                        a ValueError may be raised from the specific preprocessing method.\n\n        Note:\n            This method is an integral part of the preprocessing step of the elements and\n            is usually called within the context of the preprocessor's lifecycle.\n            It should be used with caution as elements could be dynamically modified\n            during the preprocessing.\n        \"\"\"\n\n        for owned_element in element.owned_elements:\n            self.preprocess_element(owned_element)\n\n    def preprocess(self, element: Type[model.Model]):\n        \"\"\"\n        Preprocesses a StateMachine model or its subtypes, ensuring various consistency\n        checks and setting up certain derived attributes that require calculation before\n        the model is used.\n\n        Recursively traverses the entire model structure, invoking preprocess_*\n        methods tailored for different kinds of elements within the model. If a specific\n        element type has a dedicated preprocess method (e.g., preprocess_state for a\n        State element), that method is called; otherwise, general processing is applied.\n\n        This function is the entry point for preprocessing when a model needs to be prepared,\n        so it should be called before the model is ready for activities like validation,\n        simulation or code generation.\n\n        Args:\n            element (Type[Model]): A class derived from Model which is the root or a\n                subset of the StateMachine model to be preprocessed.\n        \"\"\"\n        self.preprocess_element(element)\n</code></pre>"},{"location":"Modeling/API/Preprocessor/#stateforward.model.preprocessor.Preprocessor.preprocess","title":"preprocess","text":"<pre><code>preprocess(element: Type[model.Model])\n</code></pre> <p>Preprocesses a StateMachine model or its subtypes, ensuring various consistency checks and setting up certain derived attributes that require calculation before the model is used.</p> <p>Recursively traverses the entire model structure, invoking preprocess_* methods tailored for different kinds of elements within the model. If a specific element type has a dedicated preprocess method (e.g., preprocess_state for a State element), that method is called; otherwise, general processing is applied.</p> <p>This function is the entry point for preprocessing when a model needs to be prepared, so it should be called before the model is ready for activities like validation, simulation or code generation.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Model]</code> <p>A class derived from Model which is the root or a subset of the StateMachine model to be preprocessed.</p> required Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess(self, element: Type[model.Model]):\n    \"\"\"\n    Preprocesses a StateMachine model or its subtypes, ensuring various consistency\n    checks and setting up certain derived attributes that require calculation before\n    the model is used.\n\n    Recursively traverses the entire model structure, invoking preprocess_*\n    methods tailored for different kinds of elements within the model. If a specific\n    element type has a dedicated preprocess method (e.g., preprocess_state for a\n    State element), that method is called; otherwise, general processing is applied.\n\n    This function is the entry point for preprocessing when a model needs to be prepared,\n    so it should be called before the model is ready for activities like validation,\n    simulation or code generation.\n\n    Args:\n        element (Type[Model]): A class derived from Model which is the root or a\n            subset of the StateMachine model to be preprocessed.\n    \"\"\"\n    self.preprocess_element(element)\n</code></pre>"},{"location":"Modeling/API/Preprocessor/#stateforward.model.preprocessor.Preprocessor.preprocess_element","title":"preprocess_element","text":"<pre><code>preprocess_element(element: Type[model.Element])\n</code></pre> <p>Process a single element, applying preprocessing logic based on its type.</p> <p>This method iterates through the MRO (Method Resolution Order) of the provided element class and applies specific preprocessing logic for the first matching base class found in the class hierarchy. This is achieved by calling the corresponding method named 'preprocess_{element_class_name_in_snake_case}'. If no specific preprocessing method is found, owned elements of the class are preprocessed.</p> <p>Parameters: - element (Type[Element]): The element class to be preprocessed.</p> <p>Returns: None</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess_element(self, element: Type[model.Element]):\n    \"\"\"\n    Process a single element, applying preprocessing logic based on its type.\n\n    This method iterates through the MRO (Method Resolution Order) of the provided\n    element class and applies specific preprocessing logic for the first matching base\n    class found in the class hierarchy. This is achieved by calling the corresponding\n    method named 'preprocess_{element_class_name_in_snake_case}'. If no specific\n    preprocessing method is found, owned elements of the class are preprocessed.\n\n    Parameters:\n    - element (Type[Element]): The element class to be preprocessed.\n\n    Returns:\n    None\n    \"\"\"\n    if (\n        not model.is_redefined(element)\n        and element.qualified_name not in self.preprocessed\n    ):\n        self.preprocessed.add(element.qualified_name)\n        for base in element.__mro__:\n            method = getattr(\n                self,\n                f\"preprocess_{TITLE_CASE_PATTERN.sub(UNDERSCORE_REPLACE_PATTERN, base.__name__).lower()}\",\n                None,\n            )\n            if method not in (None, self.preprocess_element):\n                method(element.type)\n                break\n        self.preprocess_owned_elements(element.type)\n</code></pre>"},{"location":"Modeling/API/Preprocessor/#stateforward.model.preprocessor.Preprocessor.preprocess_owned_elements","title":"preprocess_owned_elements","text":"<pre><code>preprocess_owned_elements(element: Type[model.Element])\n</code></pre> <p>Preprocesses all owned elements of the given element by recursively applying the preprocessor method for each owned element.</p> <p>Each owned element's specific preprocessing method is invoked based on its type hierarchy. This method iterates over all of the owned elements and processes them accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Element]</code> <p>The element whose owned elements should be preprocessed.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an owned element's type or processing conditions are invalid,         a ValueError may be raised from the specific preprocessing method.</p> Note <p>This method is an integral part of the preprocessing step of the elements and is usually called within the context of the preprocessor's lifecycle. It should be used with caution as elements could be dynamically modified during the preprocessing.</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess_owned_elements(self, element: Type[model.Element]):\n    \"\"\"\n    Preprocesses all owned elements of the given element by recursively applying\n    the preprocessor method for each owned element.\n\n    Each owned element's specific preprocessing method is invoked based on its type\n    hierarchy. This method iterates over all of the owned elements and processes\n    them accordingly.\n\n    Args:\n        element (Type[Element]): The element whose owned elements should be preprocessed.\n\n    Raises:\n        ValueError: If an owned element's type or processing conditions are invalid,\n                    a ValueError may be raised from the specific preprocessing method.\n\n    Note:\n        This method is an integral part of the preprocessing step of the elements and\n        is usually called within the context of the preprocessor's lifecycle.\n        It should be used with caution as elements could be dynamically modified\n        during the preprocessing.\n    \"\"\"\n\n    for owned_element in element.owned_elements:\n        self.preprocess_element(owned_element)\n</code></pre>"},{"location":"StateMachine/Overview/","title":"Overview","text":"<p>The state machine package allows defining states, transitions between states, and the behavior to execute upon entering or exiting states. Additionally, asynchronous behavior is supported to handle operations that need to execute in the background or are dependent on asynchronous events. States can have nested regions and sub-states, forming a hierarchy known as a statechart.</p>"},{"location":"StateMachine/Overview/#stateforward.state_machine--key-concepts-and-classes","title":"Key Concepts and Classes","text":""},{"location":"StateMachine/Overview/#stateforward.state_machine--statemachine","title":"StateMachine","text":"<ul> <li>Base class for defining a state machine.</li> <li>Uses the concepts of states, regions, and transitions to model complex behavior.</li> <li>Can be extended to represent the specific logic of an application's state machine.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--state","title":"State","text":"<ul> <li>Represents a specific condition or status of part of a system.</li> <li>Can contain behaviors to perform on entry or exit.</li> <li>Can be simple or composite, with composite states containing nested regions and states.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--transition","title":"Transition","text":"<ul> <li>Represents a change from one state to another triggered by an event and, optionally, a guard condition.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--event","title":"Event","text":"<ul> <li>Used as triggers for transitions.</li> <li>Can be any meaningful occurrence or condition change that affects the state machine.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--preprocessor","title":"Preprocessor","text":"<ul> <li>Responsible for preparing a state machine for execution by turning definitions into a runtime model with relationships between elements.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--interpreters","title":"Interpreters","text":"<p>Interpreters handle the execution of the state machine according to its definition and incoming events.</p>"},{"location":"StateMachine/Overview/#stateforward.state_machine--asyncstatemachineinterpreter","title":"AsyncStateMachineInterpreter","text":"<ul> <li>A specialized interpreter for running state machines asynchronously.</li> <li>Processes events, manages state transitions, and invokes the defined behaviors.</li> <li>Uses the <code>asyncio</code> library to handle concurrency and background operations.</li> </ul>"},{"location":"StateMachine/Overview/#stateforward.state_machine--creating-a-state-machine","title":"Creating a State Machine","text":"<p>To create a state machine, you extend the <code>StateMachine</code> class and define your states, transitions, and behaviors within it. You can use decorators and helper functions to simplify the definition of behaviors and transitions.</p>"},{"location":"StateMachine/Overview/#stateforward.state_machine--handling-events","title":"Handling Events","text":"<p>Events are the primary way to trigger transitions in the state machine. You can define custom events and dispatch them to the state machine using the interpreter's <code>dispatch</code> method. The state machine will handle these events according to the defined transitions and behaviors.</p>"},{"location":"StateMachine/Overview/#stateforward.state_machine--example-usage","title":"Example Usage","text":"<p>Examples are provided in the form of subclasses of <code>StateMachine</code>, demonstrating how to define and interact with state machines. Common scenarios such as a light switch state machine and a traffic signal state machine are provided for illustrative purposes.</p> <p>If you have any questions or need further assistance, please refer to the code documentation strings or contact the development team.</p>"},{"location":"StateMachine/Preprocessor/","title":"Preprocessor","text":""},{"location":"StateMachine/Preprocessor/#stateforward.state_machine.preprocessor","title":"preprocessor","text":""},{"location":"StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor","title":"StateMachinePreprocessor","text":"<p>             Bases: <code>Preprocessor</code></p> <p>A preprocessor for state machines that ensures that various elements of the model are correctly processed.</p> <p>This includes processing vertices, states, composite states, transitions, regions, and pseudostates to establish the correct relationships and properties necessary for the machine's operation. Additionally, it manages handling behavior activities, entry and exit points, and transition paths.</p> <p>Attributes:</p> Name Type Description <code>preprocessed</code> <code>set</code> <p>A set to keep track of already preprocessed elements to avoid re-processing.</p> Source code in <code>stateforward/state_machine/preprocessor.py</code> <pre><code>class StateMachinePreprocessor(model.Preprocessor):\n    \"\"\"\n    A preprocessor for state machines that ensures that various elements of the model are correctly processed.\n\n    This includes processing vertices, states, composite states, transitions, regions, and pseudostates to establish the correct relationships and properties necessary for the machine's operation. Additionally, it manages handling behavior activities, entry and exit points, and transition paths.\n\n    Attributes:\n        preprocessed (set): A set to keep track of already preprocessed elements to avoid re-processing.\n    \"\"\"\n\n    def preprocess_vertex(self, element: type[\"elements.Vertex\"]):\n        container = model.find_ancestor(\n            element,\n            lambda owned_element: model.is_subtype(owned_element, elements.Region),\n        )\n        model.set_attribute(element, \"container\", container)\n\n        outgoing = list(element.outgoing.elements()) if element.outgoing else []\n        incoming = list(element.incoming.elements()) if element.incoming else []\n        for transition in model.find_descendants(\n            element.model,\n            lambda owned_element: model.is_subtype(owned_element, elements.Transition),\n        ):\n            if (\n                transition.source or transition.owner\n            ) == element and transition not in outgoing:\n                outgoing.append(transition)\n            elif transition.target == element and transition not in incoming:\n                incoming.append(transition)\n        model.set_attribute(element, \"outgoing\", model.collection(*outgoing))\n        model.set_attribute(element, \"incoming\", model.collection(*incoming))\n\n    def preprocess_state(self, element: type[\"elements.State\"]):\n        self.preprocess_composite_state(element)\n        self.preprocess_vertex(element)\n\n        for behavior in (\"entry\", \"exit\", \"do_activity\"):\n            if getattr(element, behavior) is None:\n                model.set_attribute(\n                    element,\n                    behavior,\n                    model.new_element(behavior, bases=(elements.Behavior,)),\n                )\n\n    def preprocess_composite_state(self, element: type[\"elements.CompositeState\"]):\n        transitions = []\n        subvertex = []\n        regions = []\n        for owned_element in element.owned_elements:\n            if model.is_subtype(owned_element, elements.Transition):\n                transitions.append(owned_element)\n            elif model.is_type(owned_element, model.Collection) and all(\n                model.is_subtype(_child, elements.Transition)\n                and not model.is_association(_child)\n                for _child in owned_element.owned_elements\n            ):\n                transitions.extend(model.remove_owned_elements(owned_element))\n            elif model.is_subtype(owned_element, elements.Vertex):\n                subvertex.append(owned_element)\n            elif model.is_subtype(owned_element, elements.Region):\n                regions.append(owned_element)\n        if subvertex:\n            new_region = model.new_element(\n                f\"region_{len(regions)}\",\n                bases=(elements.Region,),\n            )\n            for owned_element in subvertex + transitions:\n                if owned_element.owner:\n                    owned_element = model.remove_owned_element(element, owned_element)\n                if owned_element.name in element.attributes:\n                    model.set_attribute(new_region, owned_element.name, owned_element)\n                else:\n                    model.add_owned_element(new_region, owned_element)\n            model.set_attribute(\n                element,\n                \"region\",\n                model.collection(new_region, *regions),\n            )\n        elif regions:\n            model.set_attribute(element, \"region\", model.collection(*regions))\n\n        else:\n            model.set_attribute(element, \"region\", model.collection())\n\n    def create_transition_path(self, transition: type[\"elements.Transition\"]):\n        enter = []\n        leave = []\n        if transition.kind == elements.TransitionKind.external:\n            leave.append(transition.source)\n            for ancestor in model.ancestors(transition.source):\n                if ancestor.qualified_name == transition.container.qualified_name:\n                    break\n                leave.append(ancestor)\n            for ancestor in model.ancestors(transition.target):\n                if ancestor.qualified_name == transition.container.qualified_name:\n                    break\n                enter.append(ancestor)\n            enter.append(transition.target)\n        elif transition.kind == elements.TransitionKind.local:\n            for ancestor in model.ancestors(transition.source):\n                if ancestor.qualified_name == transition.source.qualified_name:\n                    break\n                enter.append(ancestor)\n            enter.append(transition.target)\n        elif transition.kind == elements.TransitionKind.self:\n            leave.append(transition.source)\n            enter.append(transition.target)\n        return model.new_element(\n            \"path\",\n            bases=(elements.TransitionPath,),\n            enter=model.collection(*enter),\n            leave=model.collection(*leave),\n        )\n\n    def preprocess_final_state(self, element: type[\"elements.FinalState\"]):\n        self.preprocess_vertex(element)\n\n    def preprocess_transition(self, element: type[\"elements.Transition\"]):\n        if element.source is None:\n            if not model.is_subtype(element.owner, elements.Vertex):\n                raise ValueError(\n                    f\"transition {element.qualified_name} has no source and is not owned by a state\"\n                )\n            # transition source always defaults to the parent\n            model.set_attribute(element, \"source\", element.owner)\n\n        # yield from self.wait_for_completion_of(element.source)\n        self.preprocess_element(element.source)\n        if element.events is None:\n            if model.is_subtype(element.source, elements.State):\n                completion = element.source.completion\n                if completion is None:\n                    completion = model.new_element(\n                        f\"completion\",\n                        (elements.CompletionEvent,),\n                    )\n                    model.set_attribute(element.source, \"completion\", completion)\n\n                model.set_attribute(\n                    element,\n                    \"events\",\n                    model.collection(\n                        completion,\n                    ),\n                )\n\n        if element.effect is None:\n            model.set_attribute(\n                element,\n                \"effect\",\n                model.new_element(\n                    \"effect\",\n                    (elements.Behavior,),\n                    activity=no_async_activity\n                    if element.model.concurrency_kind\n                    is elements.ConcurrencyKind.asynchronous\n                    else no_activity,\n                ),\n            )\n        container = element.source.container\n        if element.source == element.target:\n            element.kind = elements.TransitionKind.self\n        elif element.target is None:\n            element.kind = elements.TransitionKind.internal\n        elif model.has_descendant(element.source, element.target):\n            element.kind = elements.TransitionKind.local\n        else:\n            self.preprocess_element(element.target)\n            element.kind = elements.TransitionKind.external\n            container = least_common_ancestor(element.source, element.target)\n        if container is None:\n            raise ValueError(f\"transition {element.qualified_name} has no container\")\n        model.set_attribute(element, \"container\", container)\n        path = self.create_transition_path(element)\n        model.set_attribute(element, \"path\", path)\n\n    def preprocess_region(self, element: type[\"elements.Region\"]):\n        from stateforward.elements import StateMachine\n\n        def initial_filter(vertex):\n            return model.is_subtype(vertex, elements.Initial)\n\n        model.set_attribute(\n            element,\n            \"subvertex\",\n            model.collection(\n                *model.find_owned_elements(\n                    element,\n                    lambda owned_element: model.is_subtype(\n                        owned_element, elements.Vertex\n                    ),\n                )\n            ),\n        )\n        initial = getattr(element, \"initial\", None)\n        if initial is None:\n            initial = model.find_owned_element(element, initial_filter)\n            model.set_attribute(element, \"initial\", initial)\n\n        parent = element.owner\n        if not model.is_subtype(parent, (StateMachine, elements.State)):\n            parent = parent.owner\n        model.set_attribute(\n            element,\n            \"state\",\n            parent if model.is_subtype(parent, elements.State) else None,\n        )\n        model.set_attribute(\n            element,\n            \"state_machine\",\n            parent if model.is_subtype(parent, StateMachine) else None,\n        )\n\n    def preprocess_processor(self, element: type[\"model.Interpreter\"]):\n        concurrency_kind = element.model.concurrency_kind\n        if concurrency_kind == elements.ConcurrencyKind.asynchronous:\n            model.set_attribute(element, \"queue\", AsyncQueue)\n\n    def preprocess_pseudostate(self, element: type[\"elements.Pseudostate\"]):\n        self.preprocess_vertex(element)\n        if element.kind == elements.PseudostateKind.choice:\n            last_transition = tuple(element.owned_elements.values())[-1]\n            if last_transition.guard is not None:\n                raise ValueError(\n                    f\"choice psuedostate {element.qualified_name} has a guard on the last transition\"\n                )\n        elif element.kind == elements.PseudostateKind.initial:\n            if not element.outgoing.length:\n                raise ValueError(\n                    f\"initial psuedostate {element.qualified_name} has no outgoing transitions\"\n                )\n            elif element.incoming.length:\n                raise ValueError(\n                    f\"initial psuedostate {element.qualified_name} has incoming transitions\"\n                )\n            outgoing = element.outgoing.attributes[0]\n            if outgoing.guard is not None:\n                raise ValueError(\n                    f\"initial psuedostate {element.qualified_name} has a guard on the outgoing transition\"\n                )\n        elif element.kind == elements.PseudostateKind.join:\n            containers = set()\n            for transition in element.incoming.elements():\n                if transition.source.container.type in containers:\n                    raise ValueError(\n                        f\"All {tuple(t.qualified_name for t in element.incoming.elements())} incoming a join elements.Vertex ({element.qualified_name}) must originate in different Regions\"\n                    )\n                containers.add(transition.source.container.type)\n\n    def preprocess_call_event(self, element: type[\"elements.CallEvent\"]):\n        def __call__(self, *args, **kwargs):\n            return self.operation.method(self.owner, *args, **kwargs)\n\n        setattr(element, \"__call__\", __call__)\n\n    def preprocess_change_event(self, element: type[elements.ChangeEvent]):\n        element.condition = asyncio.Condition\n\n    def preprocess_behavior(self, element: type[\"elements.Behavior\"]):\n        concurrency_kind = element.model.concurrency_kind\n        activity = element.activity\n        if activity is None:\n            if concurrency_kind == elements.ConcurrencyKind.asynchronous:\n                activity = no_async_activity\n            else:\n                activity = no_activity\n        elif (\n            concurrency_kind == elements.ConcurrencyKind.asynchronous\n            and not iscoroutinefunction(element.activity)\n        ):\n\n            def activity(self, event: \"elements.Event\", _activity=element.activity):\n                return _activity(self, event)\n\n        activity.__module__ = element.model.__module__\n        activity.__qualname__ = f\"{element.qualified_name}.activity\"\n        model.set_attribute(element, \"activity\", activity)\n        context = model.find_ancestor(\n            element, lambda ancestor: model.is_subtype(ancestor, elements.Behavior)\n        )\n        self.preprocess_owned_elements(element)\n\n        events = []\n        for descendant in model.all_owned_elements(element):\n            if model.is_subtype(descendant, elements.Event):\n                events.append(descendant)\n        model.set_attribute(element, \"pool\", model.collection(*events))\n\n        model.set_attribute(\n            element,\n            \"context\",\n            context,\n        )\n\n    def preprocess_state_machine(self, element: type[\"elements.Behavior\"]):\n        from stateforward.state_machine.interpreters.asynchronous import (\n            AsyncStateMachineInterpreter,\n        )\n\n        self.preprocess_composite_state(element)\n        if element.region.length == 0:\n            raise ValueError(f\"state machine {element.qualified_name} has no regions\")\n        self.preprocess_behavior(element)\n        model.sort_collection(\n            element.pool,\n            lambda event: not model.is_subtype(event, elements.CompletionEvent),\n        )\n        if element.model.concurrency_kind is None:\n            model.set_attribute(\n                element,\n                \"interpreter\",\n                model.new_element(\"interpreter\", bases=(AsyncStateMachineInterpreter,)),\n            )\n</code></pre>"},{"location":"StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess","title":"preprocess","text":"<pre><code>preprocess(element: Type[model.Model])\n</code></pre> <p>Preprocesses a StateMachine model or its subtypes, ensuring various consistency checks and setting up certain derived attributes that require calculation before the model is used.</p> <p>Recursively traverses the entire model structure, invoking preprocess_* methods tailored for different kinds of elements within the model. If a specific element type has a dedicated preprocess method (e.g., preprocess_state for a State element), that method is called; otherwise, general processing is applied.</p> <p>This function is the entry point for preprocessing when a model needs to be prepared, so it should be called before the model is ready for activities like validation, simulation or code generation.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Model]</code> <p>A class derived from Model which is the root or a subset of the StateMachine model to be preprocessed.</p> required Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess(self, element: Type[model.Model]):\n    \"\"\"\n    Preprocesses a StateMachine model or its subtypes, ensuring various consistency\n    checks and setting up certain derived attributes that require calculation before\n    the model is used.\n\n    Recursively traverses the entire model structure, invoking preprocess_*\n    methods tailored for different kinds of elements within the model. If a specific\n    element type has a dedicated preprocess method (e.g., preprocess_state for a\n    State element), that method is called; otherwise, general processing is applied.\n\n    This function is the entry point for preprocessing when a model needs to be prepared,\n    so it should be called before the model is ready for activities like validation,\n    simulation or code generation.\n\n    Args:\n        element (Type[Model]): A class derived from Model which is the root or a\n            subset of the StateMachine model to be preprocessed.\n    \"\"\"\n    self.preprocess_element(element)\n</code></pre>"},{"location":"StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_element","title":"preprocess_element","text":"<pre><code>preprocess_element(element: Type[model.Element])\n</code></pre> <p>Process a single element, applying preprocessing logic based on its type.</p> <p>This method iterates through the MRO (Method Resolution Order) of the provided element class and applies specific preprocessing logic for the first matching base class found in the class hierarchy. This is achieved by calling the corresponding method named 'preprocess_{element_class_name_in_snake_case}'. If no specific preprocessing method is found, owned elements of the class are preprocessed.</p> <p>Parameters: - element (Type[Element]): The element class to be preprocessed.</p> <p>Returns: None</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess_element(self, element: Type[model.Element]):\n    \"\"\"\n    Process a single element, applying preprocessing logic based on its type.\n\n    This method iterates through the MRO (Method Resolution Order) of the provided\n    element class and applies specific preprocessing logic for the first matching base\n    class found in the class hierarchy. This is achieved by calling the corresponding\n    method named 'preprocess_{element_class_name_in_snake_case}'. If no specific\n    preprocessing method is found, owned elements of the class are preprocessed.\n\n    Parameters:\n    - element (Type[Element]): The element class to be preprocessed.\n\n    Returns:\n    None\n    \"\"\"\n    if (\n        not model.is_redefined(element)\n        and element.qualified_name not in self.preprocessed\n    ):\n        self.preprocessed.add(element.qualified_name)\n        for base in element.__mro__:\n            method = getattr(\n                self,\n                f\"preprocess_{TITLE_CASE_PATTERN.sub(UNDERSCORE_REPLACE_PATTERN, base.__name__).lower()}\",\n                None,\n            )\n            if method not in (None, self.preprocess_element):\n                method(element.type)\n                break\n        self.preprocess_owned_elements(element.type)\n</code></pre>"},{"location":"StateMachine/Preprocessor/#stateforward.state_machine.preprocessor.StateMachinePreprocessor.preprocess_owned_elements","title":"preprocess_owned_elements","text":"<pre><code>preprocess_owned_elements(element: Type[model.Element])\n</code></pre> <p>Preprocesses all owned elements of the given element by recursively applying the preprocessor method for each owned element.</p> <p>Each owned element's specific preprocessing method is invoked based on its type hierarchy. This method iterates over all of the owned elements and processes them accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Type[Element]</code> <p>The element whose owned elements should be preprocessed.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an owned element's type or processing conditions are invalid,         a ValueError may be raised from the specific preprocessing method.</p> Note <p>This method is an integral part of the preprocessing step of the elements and is usually called within the context of the preprocessor's lifecycle. It should be used with caution as elements could be dynamically modified during the preprocessing.</p> Source code in <code>stateforward/model/preprocessor.py</code> <pre><code>def preprocess_owned_elements(self, element: Type[model.Element]):\n    \"\"\"\n    Preprocesses all owned elements of the given element by recursively applying\n    the preprocessor method for each owned element.\n\n    Each owned element's specific preprocessing method is invoked based on its type\n    hierarchy. This method iterates over all of the owned elements and processes\n    them accordingly.\n\n    Args:\n        element (Type[Element]): The element whose owned elements should be preprocessed.\n\n    Raises:\n        ValueError: If an owned element's type or processing conditions are invalid,\n                    a ValueError may be raised from the specific preprocessing method.\n\n    Note:\n        This method is an integral part of the preprocessing step of the elements and\n        is usually called within the context of the preprocessor's lifecycle.\n        It should be used with caution as elements could be dynamically modified\n        during the preprocessing.\n    \"\"\"\n\n    for owned_element in element.owned_elements:\n        self.preprocess_element(owned_element)\n</code></pre>"},{"location":"StateMachine/Elements/Behavior/","title":"Behavior","text":""},{"location":"StateMachine/Elements/Behavior/#stateforward.elements.Behavior","title":"Behavior","text":"<p>             Bases: <code>Model</code>, <code>Generic[T]</code></p> <p>Represents the behavior associated with states in a state machine.</p> <p>A behavior is an action or series of actions that may occur when a specific event is processed by the state machine. This class is designed to be subclassed to provide custom behavior logic as needed for different states.</p> ClassVar Attributes <p>concurrency_kind (ClassVar[ConcurrencyKind]): Specifies the kind of concurrency used                                                by the behavior. Options include                                                sequential, thread, multiprocessing,                                                and asynchronous.</p> <p>Attributes:</p> Name Type Description <code>activity</code> <code>Callable[[Behavior, Event], Union[Any, Task]]</code> <p>A callable representing the activity to be performed. When behavior is executed, this function is called with the behavior instance and the event as arguments.</p> <code>context</code> <code>Union[T, Behavior]</code> <p>The context in which the behavior is executed. This is typically the state or the state machine that the behavior belongs to.</p> <code>pool</code> <code>Collection[Event]</code> <p>A collection of events that are considered part of the behavior's event pool, which it may respond to.</p> Note <p>The <code>activity</code> attribute can be either a synchronous or an asynchronous callable, depending on the concurrency kind specified.</p> <p>Info</p> <p>The actual concurrency behavior is determined by the model Interpreter, and the <code>concurrency_kind</code> simply provides an indication of how the behavior is meant to be executed in terms of concurrency.</p> <p>Example</p> light_switch.pyOutput <pre><code># ... existing code from the LightSwitch example\n\n# Defining a new Behavior by inheriting the Behavior element\nclass PrintBehavior(sf.Behavior):\n    # An activity function that prints the state and event information\n    def activity(self, event: sf.Event = None):\n        print(\n            f\"{self.qualified_name} -&gt; {event.qualified_name if event else 'None'}\"\n        )\n\n# Updating the LightSwitch state machine to use the PrintBehavior\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        entry = sf.bind(PrintBehavior)  # Binding the PrintBehavior to the entry event\n        exit = sf.bind(PrintBehavior)   # Binding the PrintBehavior to the exit event\n\n    class Off(sf.State):\n        entry = sf.bind(PrintBehavior)  # Similarly for the Off state\n        exit = sf.bind(PrintBehavior)\n\n# ... continuation of the LightSwitch example\n</code></pre> <p>The example output below illustrates the invocation of the <code>PrintBehavior</code> for each state's entry and exit procedures, with accompanying event details.</p> <pre><code>LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; None\nLightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\nLightSwitch.region.region_0.On.entry&lt;4313137296&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\nLightSwitch.region.region_0.On.exit&lt;4313139536&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\nLightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\nLightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; None\n</code></pre> <p>This output demonstrates that the behavior is correctly associated with each state, with the <code>bind</code> function ensuring that each behavior is instantiated as a unique object. In contrast, without the <code>bind</code> method, multiple states could end up sharing a reference to the same <code>Behavior</code> instance, as behavior definitions are types. Using <code>bind</code>, we can also pass arguments to adjust the behavior's attributes, allowing for tailored functionality within each state.</p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class Behavior(model.Model, Generic[T]):\n    \"\"\"\n    Represents the behavior associated with states in a state machine.\n\n    A behavior is an action or series of actions that may occur when a specific event is\n    processed by the state machine. This class is designed to be subclassed to provide\n    custom behavior logic as needed for different states.\n\n    ClassVar Attributes:\n        concurrency_kind (ClassVar[ConcurrencyKind]): Specifies the kind of concurrency used\n                                                       by the behavior. Options include\n                                                       sequential, thread, multiprocessing,\n                                                       and asynchronous.\n\n    Attributes:\n        activity (Callable[['Behavior', 'Event'], Union[Any, asyncio.Task]]):\n            A callable representing the activity to be performed. When behavior is executed,\n            this function is called with the behavior instance and the event as arguments.\n        context (Union[T, 'Behavior']):\n            The context in which the behavior is executed. This is typically the state or the\n            state machine that the behavior belongs to.\n        pool (Collection[Event]):\n            A collection of events that are considered part of the behavior's event pool,\n            which it may respond to.\n\n    Note:\n        The `activity` attribute can be either a synchronous or an asynchronous callable,\n        depending on the concurrency kind specified.\n\n\n    !!! info\n        The actual concurrency behavior is determined by the model Interpreter, and the `concurrency_kind`\n        simply provides an indication of how the behavior is meant to be executed in terms of concurrency.\n\n    !!! example \"Example\"\n        === \"light_switch.py\"\n            ```python\n            # ... existing code from the LightSwitch example\n\n            # Defining a new Behavior by inheriting the Behavior element\n            class PrintBehavior(sf.Behavior):\n                # An activity function that prints the state and event information\n                def activity(self, event: sf.Event = None):\n                    print(\n                        f\"{self.qualified_name} -&gt; {event.qualified_name if event else 'None'}\"\n                    )\n\n            # Updating the LightSwitch state machine to use the PrintBehavior\n            class LightSwitch(sf.AsyncStateMachine):\n                class On(sf.State):\n                    entry = sf.bind(PrintBehavior)  # Binding the PrintBehavior to the entry event\n                    exit = sf.bind(PrintBehavior)   # Binding the PrintBehavior to the exit event\n\n                class Off(sf.State):\n                    entry = sf.bind(PrintBehavior)  # Similarly for the Off state\n                    exit = sf.bind(PrintBehavior)\n\n            # ... continuation of the LightSwitch example\n            ```\n        === \"Output\"\n            The example output below illustrates the invocation of the `PrintBehavior` for each state's entry and exit procedures, with accompanying event details.\n\n            ```bash\n            LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; None\n            LightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\n            LightSwitch.region.region_0.On.entry&lt;4313137296&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\n            LightSwitch.region.region_0.On.exit&lt;4313139536&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\n            LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\n            LightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; None\n            ```\n\n            This output demonstrates that the behavior is correctly associated with each state, with the `bind` function ensuring that each behavior is instantiated as a unique object. In contrast, without the `bind` method, multiple states could end up sharing a reference to the same `Behavior` instance, as behavior definitions are types. Using `bind`, we can also pass arguments to adjust the behavior's attributes, allowing for tailored functionality within each state.\n\n    \"\"\"\n\n    concurrency_kind: ClassVar[ConcurrencyKind] = None\n    activity: Callable[[\"Behavior\", \"Event\"], Union[Any, asyncio.Task]] = None\n    context: Union[T, \"Behavior\"] = None\n    pool: model.Collection[Event] = None\n</code></pre>"},{"location":"StateMachine/Elements/CompositeState/","title":"CompositeState","text":""},{"location":"StateMachine/Elements/CompositeState/#stateforward.elements.CompositeState","title":"CompositeState","text":"<p>             Bases: <code>Element</code></p> <p>A class representing a CompositeState in a UML model. A CompositeState is a Vertex that contains other Vertexes, known as subvertexes, potentially organized into Regions.</p> <p>A CompositeState can represent more complex behavior in state machines, where states can be nested within other states. This concept supports the hierarchical nesting of states and the definition of orthogonal regions of parallel states.</p> <p>Attributes:</p> Name Type Description <code>region</code> <code>Collection[Region]</code> <p>A collection of Region elements that defines the orthogonal regions within the composite state. The regions contain substates (subvertexes) and handle state transitions independently.</p> Inherits from <p>Element (type[T]): Inherits methods and attributes from the Element class.</p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class CompositeState(model.Element):\n    \"\"\"\n    A class representing a CompositeState in a UML model. A CompositeState is a Vertex that\n    contains other Vertexes, known as subvertexes, potentially organized into Regions.\n\n    A CompositeState can represent more complex behavior in state machines, where states can be\n    nested within other states. This concept supports the hierarchical nesting of states and\n    the definition of orthogonal regions of parallel states.\n\n    Attributes:\n        region (Collection[\"Region\"]): A collection of Region elements that defines the orthogonal\n            regions within the composite state. The regions contain substates (subvertexes) and\n            handle state transitions independently.\n\n    Inherits from:\n        Element (type[T]): Inherits methods and attributes from the Element class.\n    \"\"\"\n\n    region: model.Collection[\"Region\"] = None\n</code></pre>"},{"location":"StateMachine/Elements/Overview/","title":"Overview","text":"<p>In this document, we provide a comprehensive overview of the <code>stateforward.elements</code> module, part of the StateForward framework. The module defines the primary building blocks used to model state machines, which include vertices, states, transitions, and events. These constructs encapsulate the behavior, conditions, and structure of state-based systems.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--elements","title":"Elements","text":""},{"location":"StateMachine/Elements/Overview/#stateforward.elements--vertex","title":"Vertex","text":"<p>A base class for objects that represent the nodes within a state machine. It has <code>outgoing</code> and <code>incoming</code> collections for transitions, as well as a <code>container</code> which refers to the region it belongs to.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--finalstate","title":"FinalState","text":"<p>A special kind of vertex indicating a state that, once entered, signifies the completion of a process within a particular region of the state machine.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--transition","title":"Transition","text":"<p>Defines a pathway or a link between two vertices (<code>source</code> and <code>target</code>). Transitions can be governed by <code>events</code>, have an assigned <code>effect</code> (behavior), and be protected by a <code>guard</code> condition. Transitions also have a <code>kind</code> signifying their type (internal, local, external, or self) and a <code>path</code> describing the entry and exit states involved during the transition.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--pseudostatekind-enum","title":"PseudostateKind (Enum)","text":"<p>Enumerates the different kinds of special purpose states within a state machine, such as initial, choice, join, fork, and more.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--pseudostate","title":"Pseudostate","text":"<p>A specialized form of vertex representing various control nodes within a state machine, such as initial states or decision points. Its <code>kind</code> is determined by PseudostateKind.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--transitionkind-enum","title":"TransitionKind (Enum)","text":"<p>Enumerates different kinds of transitions, such as internal, local, external, and self-transitions.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--transitionpath","title":"TransitionPath","text":"<p>Represents the sequence of vertices one must enter (<code>enter</code>) and leave (<code>leave</code>) when performing a transition.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--concurrencykind-enum","title":"ConcurrencyKind (Enum)","text":"<p>Enumerates the different concurrency models that can be used, such as sequential, threaded, multiprocessing, and asynchronous.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--event","title":"Event","text":"<p>A base class for different types of events that can trigger transitions.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--anyevent","title":"AnyEvent","text":"<p>Represents a wildcard event that matches any occurring event.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--callevent","title":"CallEvent","text":"<p>Defines an event that represents the invocation of a callable, with potential <code>results</code> and an operation to execute (<code>operation</code>).</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--timeevent","title":"TimeEvent","text":"<p>An event triggered based on time, with a <code>when</code> attribute specifying the timing.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--changeevent","title":"ChangeEvent","text":"<p>An event triggered by a change in the system's conditions.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--completionevent","title":"CompletionEvent","text":"<p>An event that indicates the completion of the activities within a state.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--constraint","title":"Constraint","text":"<p>Defines a conditional expression or constraint that can influence the behavior of a transition (<code>condition</code>).</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--compositestate","title":"CompositeState","text":"<p>A base class for complex states that may contain other states (regions).</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--state","title":"State","text":"<p>A simple or composite state within the state machine that can perform <code>entry</code>, <code>exit</code>, and <code>do_activity</code> behaviors. It may also contain <code>completion</code>, <code>deferred</code> events, and a reference to a <code>submachine</code>.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--region","title":"Region","text":"<p>Represents a 'container' for states inside composite states or state machines. Maintains a <code>subvertex</code> collection for the vertices it encloses and references its <code>initial</code> state.</p>"},{"location":"StateMachine/Elements/Overview/#stateforward.elements--behavior-and-statemachine","title":"Behavior and StateMachine","text":"<p>Defines abstract bases for behaviors and state machines, enabling the modeling of more complex functional behaviors within the system.</p> <p>By exploring these elements, developers can model the states and transitions of their systems, defining exactly how their state machines should behave in response to events and conditions. Each class provides the necessary attributes and mechanisms to accomplish this, forming a foundational toolkit for state management.</p>"},{"location":"StateMachine/Elements/StateMachine/","title":"StateMachine","text":""},{"location":"StateMachine/Elements/StateMachine/#stateforward.elements.StateMachine","title":"StateMachine","text":"<p>             Bases: <code>Behavior</code>, <code>CompositeState</code></p> <p>The <code>StateMachine</code> in StateForward is partially inspired by UML2.5 and is therefore designed with flexibility to deviate from the strict UML specifications when it provides practical benefits for development.</p> <p>Attributes:</p> Name Type Description <code>submachine_state</code> <code>State</code> <p>The current State of the submachine. This refers to the currently active State within the StateMachine.</p> <code>state</code> <code>tuple[State]</code> <p>Retrieves a tuple of active <code>State</code> instances that are currently active in the state machine.</p> <p>A <code>StateMachine</code> is organized into one or more <code>Region</code> elements \u2014 see CompositeState for more details.</p> <p>The StateForward preprocessor automatically creates <code>Region</code> elements when substates are added to a <code>State</code> or <code>StateMachine</code>. This concurrent workflow within different regions of the state machine allows for sophisticated behavior patterns that can simulate complex systems' parallel operations.</p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class StateMachine(Behavior, CompositeState):\n    \"\"\"\n    The `StateMachine` in StateForward is partially inspired by UML2.5 and is therefore designed with flexibility to deviate from the strict UML specifications when it provides practical benefits for development.\n\n    Attributes:\n        submachine_state (State): The current State of the submachine. This refers to the currently active State\n            within the StateMachine.\n        state: Retrieves a tuple of active `State` instances that are currently active in the state machine.\n\n\n    A `StateMachine` is organized into one or more `Region` elements \u2014 see [CompositeState](#compositestate) for more details.\n\n    The StateForward preprocessor automatically creates `Region` elements when substates are added to a `State` or `StateMachine`. This concurrent workflow within different regions of the state machine allows for sophisticated behavior patterns that can simulate complex systems' parallel operations.\n    \"\"\"\n\n    submachine_state: State = None\n\n    @property\n    def state(self) -&gt; tuple[State]:\n        return tuple(\n            cast(State, value)\n            for value in self.interpreter.active.keys()\n            if model.is_subtype(value, State)\n        )\n</code></pre>"},{"location":"StateMachine/Interpreters/AsyncStateMachineInterpreter/","title":"AsyncStateMachineInterpreter","text":""},{"location":"StateMachine/Interpreters/AsyncStateMachineInterpreter/#stateforward.state_machine.interpreters.AsyncStateMachineInterpreter","title":"AsyncStateMachineInterpreter","text":"<p>             Bases: <code>AsyncBehaviorInterpreter</code></p> <p>An asynchronous state machine interpreter responsible for processing events and managing state transitions within an asynchronous environment.</p> <p>The interpreter leverages Python's asyncio library to handle the execution of state machine behaviors, ensuring non-blocking operations.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>StateMachine</code> <p>The state machine to be interpreted.</p> <code>idle</code> <code>Event</code> <p>An event to indicate if the interpreter is idle.</p> <code>tasks</code> <code>dict[Element, Future]</code> <p>A mapping of elements (e.g., states) to their respective awaitable task objects.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/state_machine_interpreter.py</code> <pre><code>class AsyncStateMachineInterpreter(AsyncBehaviorInterpreter):\n    \"\"\"\n    An asynchronous state machine interpreter responsible for processing events\n    and managing state transitions within an asynchronous environment.\n\n    The interpreter leverages Python's asyncio library to handle the execution\n    of state machine behaviors, ensuring non-blocking operations.\n\n    Attributes:\n        model (StateMachine): The state machine to be interpreted.\n        idle (asyncio.Event): An event to indicate if the interpreter is idle.\n        tasks (dict[Element, asyncio.Future]): A mapping of elements (e.g., states) to\n            their respective awaitable task objects.\n\n    \"\"\"\n\n    model: \"elements.StateMachine\"\n\n    async def process_event(self, event: elements.elements.Event):\n        \"\"\"\n        Asynchronously handles an incoming event and determines the resultant state machine processing action.\n\n        This method looks through the active regions and states of the state machine and attempts to process\n        the event. If any transitions match the event and its associated guard conditions, those transitions\n        are taken, and the state machine moves to the next appropriate state(s).\n\n        Args:\n            event (Event): The event instance to be processed by the state machine.\n\n        Returns:\n            Processing: An enumeration value indicating the result of the event processing. This value can\n                        be Processing.complete if the event led to a transition, Processing.incomplete if the\n                        event did not lead to a transition, or Processing.deferred if the event processing is\n                        ongoing or deferred.\n\n        Raises:\n            Exception: If no valid transitions are found for a choice pseudostate. This situation\n                       indicates a model error where a choice cannot make a valid decision based on the\n                       guards of its outgoing transitions.\n        \"\"\"\n        # could possibly improve this with using state in reverse\n        results = await asyncio.gather(\n            *(self.process_region(region, event) for region in self.model.region)\n        )\n        if model.Processing.complete in results:\n            return model.Processing.complete\n        return model.Processing.incomplete\n\n    async def process_region(\n        self, region: elements.elements.Region, event: elements.elements.Event\n    ):\n        if not self.is_active(region):\n            return model.Processing.incomplete\n        active_state = next(\n            (state for state in region.subvertex if self.is_active(state)), None\n        )\n        if active_state is None:\n            return model.Processing.incomplete\n        return await self.process_state(active_state, event)\n\n    async def process_state(\n        self, state: elements.elements.State, event: elements.elements.Event\n    ):\n        if not self.is_active(state):\n            return model.Processing.incomplete\n        result = next(\n            (\n                result\n                for result in (\n                    await asyncio.gather(\n                        *(self.process_region(region, event) for region in state.region)\n                    )\n                )\n                if result is not model.Processing.incomplete\n            ),\n            model.Processing.incomplete,\n        )\n        if result is not model.Processing.incomplete:\n            return result\n        return await self.process_vertex(state, event)\n\n    async def process_vertex(self, vertex: elements.Vertex, event: elements.Event):\n        for transition in vertex.outgoing:\n            if (\n                await self.process_transition(transition, event)\n                == model.Processing.complete\n            ):\n                return model.Processing.complete\n        return model.Processing.incomplete\n\n    async def process_transition(\n        self, transition: elements.Transition, event: elements.Event\n    ):\n        if any(\n            isinstance(_event, (type(event), elements.AnyEvent))\n            for _event in transition.events\n        ) and await self.evaluate_constraint(transition.guard, event):\n            await self.execute_transition(transition, event)\n            return model.Processing.complete\n        return model.Processing.incomplete\n\n        # could possibly improve this with using state in reverse\n\n    async def evaluate_constraint(\n        self, constraint: elements.Constraint, event: elements.Event\n    ):\n        if constraint is None:\n            return True\n        result = constraint.condition(event)\n        if asyncio.iscoroutine(result):\n            result = await result\n        return result\n\n    async def leave_vertex(self, vertex: elements.Vertex, event: elements.Event):\n        if isinstance(vertex, elements.State):\n            await asyncio.gather(\n                *(self.leave_transition(transition) for transition in vertex.outgoing)\n            )\n            await self.leave_state(vertex, event)\n        else:\n            await self.leave_psuedostate(vertex, event)\n        self.remove_active(vertex)\n\n    async def execute_transition(\n        self, transition: elements.Transition, event: elements.Event = None\n    ):\n        await asyncio.gather(\n            *(self.leave_vertex(vertex, event) for vertex in transition.path.leave)\n        )\n        await (await self.execute_behavior(transition.effect, event))\n        return await asyncio.gather(\n            *(\n                self.enter_vertex(\n                    vertex,\n                    event,\n                    elements.EntryKind.default\n                    if index == transition.path.enter.length - 1\n                    else elements.EntryKind.explicit,\n                )\n                for index, vertex in enumerate(transition.path.enter)\n            )\n        )\n\n    async def leave_transition(self, transition: elements.Transition):\n        for element in (*transition.events, transition.events, transition):\n            self.remove_active(element)\n\n    async def enter_vertex(\n        self, vertex: elements.Vertex, event: elements.Event, kind: elements.EntryKind\n    ):\n        self.add_active(vertex)\n\n        if isinstance(vertex, elements.State):\n            await self.enter_state(vertex, event, kind)\n            return await asyncio.gather(\n                *(self.enter_transition(transition) for transition in vertex.outgoing)\n            )\n\n        elif isinstance(vertex, elements.FinalState):\n            return await self.enter_final_state(vertex, event)\n        return await self.enter_psuedostate(vertex, event)\n\n    async def enter_final_state(self, final_state: elements.FinalState):\n        await self.terminate()\n\n    async def leave_event(self, event: elements.Event):\n        self.remove_active(event)\n\n    def enter_change_event(self, event: elements.ChangeEvent):\n        async def wait(_self=self, _event=event, _condition=event.condition()):\n            while True:\n                if _event.expr(_event):\n                    _self.dispatch(_event)\n                    break\n                await asyncio.sleep(0)\n\n        return asyncio.create_task(wait())\n\n    def enter_time_event(self, event: elements.TimeEvent):\n        async def wait(_self=self, _event=event):\n            await asyncio.sleep(_event.when.total_seconds())\n            self.add_active(event)\n\n        return asyncio.create_task(wait())\n\n    def enter_completion_event(self, event: elements.CompletionEvent):\n        async def wait(_self=self, _event=event, _source=event.owner):\n            await _self.get_active(\n                _source.do_activity\n            )  # wait for the activity of the state to complete\n            await asyncio.gather(\n                *(\n                    _self.get_active(active.do_activity)\n                    for active in _self.active\n                    if model.is_subtype(active, elements.State)\n                    and active.qualified_name.startswith(_source.qualified_name)\n                )\n            )\n            self.add_active(_event)\n\n        return asyncio.create_task(wait())\n\n    def enter_call_event(self, event: elements.CallEvent):\n        async def wait(_self=self, _event=event):\n            await _event.operation.results\n            _self.add_active(_event)\n\n        return asyncio.create_task(wait())\n\n    def enter_event(self, event: elements.Event):\n        if isinstance(event, elements.TimeEvent):\n            return self.enter_time_event(event)\n\n        elif isinstance(event, elements.CompletionEvent):\n            return self.enter_completion_event(event)\n\n        elif isinstance(event, elements.CallEvent):\n            return self.enter_call_event(event)\n\n        elif isinstance(event, elements.ChangeEvent):\n            return self.enter_change_event(event)\n\n    async def enter_transition(self, transition: elements.Transition):\n        self.add_active(transition)\n        tasks = []\n        for event in transition.events:\n            task = self.enter_event(event)\n            if task is not None:\n                tasks.append(self.enter_event(event))\n\n        self.add_active(\n            transition.events,\n            asyncio.create_task(asyncio.wait_for(asyncio.gather(*tasks), None)),\n        )\n\n    async def enter_state(\n        self, state: elements.State, event: elements.Event, kind: elements.EntryKind\n    ):\n        await (await self.execute_behavior(state.entry, event))\n        assert state.entry not in self.active\n        await self.execute_behavior(state.do_activity, event)\n        if state.submachine is not None:\n            await self.enter_state_machine(state.submachine, event, kind)\n        else:\n            await asyncio.gather(\n                *(\n                    self.enter_region(region, event, kind)\n                    for region in state.region or []\n                )\n            )\n\n    async def enter_state_machine(\n        self,\n        state_machine: \"elements.StateMachine\",\n        event: elements.Event,\n        kind: elements.EntryKind,\n    ):\n        return await asyncio.gather(\n            *(self.enter_region(region, event, kind) for region in state_machine.region)\n        )\n\n    async def enter_region(\n        self, region: elements.Region, event: elements.Event, kind: elements.EntryKind\n    ):\n        states = ()\n        if kind == elements.EntryKind.default:\n            if region.initial is None:\n                return states\n            self.add_active(region)\n            return await self.enter_psuedostate(region.initial, event)\n        self.add_active(region)\n        return states\n\n    async def leave_region(self, region: elements.Region, event: elements.Event):\n        active_vertex = next(\n            (vertex for vertex in region.subvertex if vertex in self.active),\n            None,\n        )\n        if active_vertex is not None:\n            await self.leave_vertex(active_vertex, event)\n        self.remove_active(region)\n\n    async def leave_psuedostate(\n        self, psuedostate: elements.Pseudostate, event: elements.Event\n    ):\n        pass\n\n    async def leave_state(self, state: elements.State, event: elements.Event):\n        if state.submachine is not None:\n            await self.leave_state_machine(state.submachine, event)\n        else:\n            await asyncio.gather(\n                *(self.leave_region(region, event) for region in state.region or [])\n            )\n        self.remove_active(state.do_activity)\n        await (await self.execute_behavior(state.exit, event))\n\n    async def leave_state_machine(\n        self, state_machine: \"elements.StateMachine\", event: elements.Event\n    ):\n        await asyncio.gather(\n            *(self.leave_region(region, event) for region in state_machine.region)\n        )\n\n    async def enter_psuedostate(\n        self, psuedostate: elements.Pseudostate, event: elements.Event\n    ):\n        if psuedostate.kind == elements.PseudostateKind.initial:\n            return await self.execute_transition(psuedostate.outgoing[0], event)\n        elif psuedostate.kind == elements.PseudostateKind.choice:\n            for transition in psuedostate.outgoing:\n                if await self.evaluate_constraint(transition.guard, event):\n                    return await self.execute_transition(transition, event)\n                raise Exception(\"no valid transition this should never throw\")\n        elif psuedostate.kind == elements.PseudostateKind.join:\n            if all(\n                transition.source not in self.active\n                for transition in psuedostate.incoming\n            ):\n                return await self.execute_transition(psuedostate.outgoing[0], event)\n        elif psuedostate.kind == elements.PseudostateKind.fork:\n            return await asyncio.gather(\n                *(\n                    self.execute_transition(transition, event)\n                    for transition in psuedostate.outgoing\n                )\n            )\n\n    async def run(self, machine):\n        await self.enter_state_machine(machine, None, elements.EntryKind.default)\n        await super().run(machine)\n\n    async def terminate(self):\n        await self.leave_state_machine(self.model, None)\n</code></pre>"},{"location":"StateMachine/Interpreters/AsyncStateMachineInterpreter/#stateforward.state_machine.interpreters.AsyncStateMachineInterpreter.process_event","title":"process_event  <code>async</code>","text":"<pre><code>process_event(event: elements.elements.Event)\n</code></pre> <p>Asynchronously handles an incoming event and determines the resultant state machine processing action.</p> <p>This method looks through the active regions and states of the state machine and attempts to process the event. If any transitions match the event and its associated guard conditions, those transitions are taken, and the state machine moves to the next appropriate state(s).</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event instance to be processed by the state machine.</p> required <p>Returns:</p> Name Type Description <code>Processing</code> <p>An enumeration value indicating the result of the event processing. This value can         be Processing.complete if the event led to a transition, Processing.incomplete if the         event did not lead to a transition, or Processing.deferred if the event processing is         ongoing or deferred.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no valid transitions are found for a choice pseudostate. This situation        indicates a model error where a choice cannot make a valid decision based on the        guards of its outgoing transitions.</p> Source code in <code>stateforward/state_machine/interpreters/asynchronous/state_machine_interpreter.py</code> <pre><code>async def process_event(self, event: elements.elements.Event):\n    \"\"\"\n    Asynchronously handles an incoming event and determines the resultant state machine processing action.\n\n    This method looks through the active regions and states of the state machine and attempts to process\n    the event. If any transitions match the event and its associated guard conditions, those transitions\n    are taken, and the state machine moves to the next appropriate state(s).\n\n    Args:\n        event (Event): The event instance to be processed by the state machine.\n\n    Returns:\n        Processing: An enumeration value indicating the result of the event processing. This value can\n                    be Processing.complete if the event led to a transition, Processing.incomplete if the\n                    event did not lead to a transition, or Processing.deferred if the event processing is\n                    ongoing or deferred.\n\n    Raises:\n        Exception: If no valid transitions are found for a choice pseudostate. This situation\n                   indicates a model error where a choice cannot make a valid decision based on the\n                   guards of its outgoing transitions.\n    \"\"\"\n    # could possibly improve this with using state in reverse\n    results = await asyncio.gather(\n        *(self.process_region(region, event) for region in self.model.region)\n    )\n    if model.Processing.complete in results:\n        return model.Processing.complete\n    return model.Processing.incomplete\n</code></pre>"}]}