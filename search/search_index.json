{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#stateforward--about-stateforward-python","title":"About StateForward Python","text":"<p>StateForward Python is where code complexity meets simplicity. This library is your ally in evolving spaghetti code into elegant, robust state machines. Say goodbye to the dense forest of if-else statements and welcome a world where adding features doesn\u2019t mean unraveling a complex knot.</p> <p>With StateForward Python, you\u2019re building on solid ground. Your code becomes a clear map of states and transitions, making it easily extendable and a joy to maintain. It's about writing software that grows with grace, ensuring that your project's future is as structured and reliable as its present.</p>"},{"location":"#stateforward--installation","title":"Installation","text":"<pre><code>pip install stateforward\n</code></pre>"},{"location":"#stateforward--usage","title":"Usage","text":"<p>Light Switch Example</p> Diagramlight_switch.pyOutput <p>Here is a simple example of a light switch state machine using StateForward Python. <pre><code>stateDiagram-v2\n    direction LR\n    Off: Off\n    Off: entry / print(\"Light off entry\")\n    Off: exit / print(\"Light off exit\")\n    [*] --&gt; Off\n    On: On\n    On: entry / print(\"Light on entry\")\n    On: exit / print(\"Light on exit\")\n    Off --&gt; On : OnEvent\n    On --&gt; Off : OffEvent\n\n</code></pre></p> <pre><code>import stateforward as sf\nimport asyncio\n\n\nclass OnEvent(sf.Event):\n    pass\n\n\nclass OffEvent(sf.Event):\n    pass\n\n\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light on entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light on exit\")\n\n    class Off(sf.State):\n        @sf.decorators.behavior\n        async def entry(self, event: OnEvent):\n            print(\"Light off entry\")\n\n        @sf.decorators.behavior\n        async def exit(self, event: OffEvent):\n            print(\"Light off exit\")\n\n    initial = sf.initial(Off)\n    transitions = sf.collection(\n        sf.transition(OnEvent, source=Off, target=On),\n        sf.transition(OffEvent, source=On, target=Off),\n    )\n\n\nasync def main():\n    # instantiate a light switch\n    light_switch = LightSwitch()\n    # start the interpreter and wait for it to be settled\n    await light_switch.interpreter.start()\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OnEvent to the state machine\n    await sf.dispatch(OnEvent(), light_switch)\n    # output the current states of the state machine\n    print(light_switch.state)\n    # dispatch a OffEvent to the state machine\n    await sf.dispatch(OffEvent(), light_switch)\n    print(light_switch.state)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>Light off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\nLight on entry\n(&lt;__main__.LightSwitch.region.region_0.On object at 0x10683dd90&gt;,)\nLight on exit\nLight off entry\n(&lt;__main__.LightSwitch.region.region_0.Off object at 0x10683e590&gt;,)\nLight off exit\n</code></pre>"},{"location":"Behavior/","title":"Behavior","text":""},{"location":"Behavior/#stateforward.elements.Behavior","title":"Behavior","text":"<p>             Bases: <code>Model</code>, <code>Generic[T]</code></p> <p>A behavior is a specification of how its context classifier changes state over time.</p> Type Parameters <p>T: The type of context in which this behavior can operate, typically a classifier that the behavior can update or    interact with.</p> <p>Attributes:</p> Name Type Description <code>concurrency_kind</code> <code>(ConcurrencyKind, ClassVar)</code> <p>The concurrency kind of this behavior.</p> <code>activity</code> <code>Callable[[Behavior, Event], Union[Any, Task]]</code> <p>The activity function of this behavior, which may return either a direct result or an asyncio.Task if the activity is intended to be performed asynchronously.</p> <code>context</code> <code>Union[T, Behavior]</code> <p>The context in which this behavior operates, which can either be another instance of a Behavior or an instance of a type T defined by the specific model.</p> <code>pool</code> <code>Collection[Event]</code> <p>A collection of events that this behavior can handle. These events are used to trigger the behavior's activity.</p> <p>Info</p> <p>The actual concurrency behavior is determined by the model Interpreter, and the <code>concurrency_kind</code> simply provides an indication of how the behavior is meant to be executed in terms of concurrency.</p> <p>Example</p> light_switch.pyOutput <pre><code># ... existing code from the LightSwitch example\n\n# Defining a new Behavior by inheriting the Behavior element\nclass PrintBehavior(sf.Behavior):\n    # An activity function that prints the state and event information\n    def activity(self, event: sf.Event = None):\n        print(\n            f\"{self.qualified_name} -&gt; {event.qualified_name if event else 'None'}\"\n        )\n\n# Updating the LightSwitch state machine to use the PrintBehavior\nclass LightSwitch(sf.AsyncStateMachine):\n    class On(sf.State):\n        entry = sf.bind(PrintBehavior)  # Binding the PrintBehavior to the entry event\n        exit = sf.bind(PrintBehavior)   # Binding the PrintBehavior to the exit event\n\n    class Off(sf.State):\n        entry = sf.bind(PrintBehavior)  # Similarly for the Off state\n        exit = sf.bind(PrintBehavior)\n\n# ... continuation of the LightSwitch example\n</code></pre> <p>The example output below illustrates the invocation of the <code>PrintBehavior</code> for each state's entry and exit procedures, with accompanying event details.</p> <pre><code>LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; None\nLightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\nLightSwitch.region.region_0.On.entry&lt;4313137296&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\nLightSwitch.region.region_0.On.exit&lt;4313139536&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\nLightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\nLightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; None\n</code></pre> <p>This output demonstrates that the behavior is correctly associated with each state, with the <code>bind</code> function ensuring that each behavior is instantiated as a unique object. In contrast, without the <code>bind</code> method, multiple states could end up sharing a reference to the same <code>Behavior</code> instance, as behavior definitions are types. Using <code>bind</code>, we can also pass arguments to adjust the behavior's attributes, allowing for tailored functionality within each state.</p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class Behavior(model.Model, Generic[T]):\n    \"\"\"\n    A behavior is a specification of how its context classifier changes state over time.\n\n    Type Parameters:\n        T: The type of context in which this behavior can operate, typically a classifier that the behavior can update or\n           interact with.\n\n    Attributes:\n        concurrency_kind (ConcurrencyKind, ClassVar): The concurrency kind of this behavior.\n        activity (Callable[[Behavior, Event], Union[Any, asyncio.Task]]): The activity function of this behavior, which\n            may return either a direct result or an asyncio.Task if the activity is intended to be performed\n            asynchronously.\n        context (Union[T, Behavior]): The context in which this behavior operates, which can either be another instance\n            of a Behavior or an instance of a type T defined by the specific model.\n        pool (model.Collection[Event]): A collection of events that this behavior can handle. These events are used to trigger\n            the behavior's activity.\n\n\n\n    !!! info\n        The actual concurrency behavior is determined by the model Interpreter, and the `concurrency_kind`\n        simply provides an indication of how the behavior is meant to be executed in terms of concurrency.\n\n    !!! example \"Example\"\n        === \"light_switch.py\"\n            ```python\n            # ... existing code from the LightSwitch example\n\n            # Defining a new Behavior by inheriting the Behavior element\n            class PrintBehavior(sf.Behavior):\n                # An activity function that prints the state and event information\n                def activity(self, event: sf.Event = None):\n                    print(\n                        f\"{self.qualified_name} -&gt; {event.qualified_name if event else 'None'}\"\n                    )\n\n            # Updating the LightSwitch state machine to use the PrintBehavior\n            class LightSwitch(sf.AsyncStateMachine):\n                class On(sf.State):\n                    entry = sf.bind(PrintBehavior)  # Binding the PrintBehavior to the entry event\n                    exit = sf.bind(PrintBehavior)   # Binding the PrintBehavior to the exit event\n\n                class Off(sf.State):\n                    entry = sf.bind(PrintBehavior)  # Similarly for the Off state\n                    exit = sf.bind(PrintBehavior)\n\n            # ... continuation of the LightSwitch example\n            ```\n        === \"Output\"\n            The example output below illustrates the invocation of the `PrintBehavior` for each state's entry and exit procedures, with accompanying event details.\n\n            ```bash\n            LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; None\n            LightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\n            LightSwitch.region.region_0.On.entry&lt;4313137296&gt; -&gt; LightSwitch.region.region_0.transition_from_Off_to_On.events.OnEvent\n            LightSwitch.region.region_0.On.exit&lt;4313139536&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\n            LightSwitch.region.region_0.Off.entry&lt;4313140624&gt; -&gt; LightSwitch.region.region_0.transition_from_On_to_Off.events.OffEvent\n            LightSwitch.region.region_0.Off.exit&lt;4313140752&gt; -&gt; None\n            ```\n\n            This output demonstrates that the behavior is correctly associated with each state, with the `bind` function ensuring that each behavior is instantiated as a unique object. In contrast, without the `bind` method, multiple states could end up sharing a reference to the same `Behavior` instance, as behavior definitions are types. Using `bind`, we can also pass arguments to adjust the behavior's attributes, allowing for tailored functionality within each state.\n\n    \"\"\"\n\n    concurrency_kind: ClassVar[ConcurrencyKind] = None\n    activity: Callable[[\"Behavior\", \"Event\"], Union[Any, asyncio.Task]] = None\n    context: Union[T, \"Behavior\"] = None\n    pool: model.Collection[Event] = None\n</code></pre>"},{"location":"CompositeState/","title":"CompositeState","text":""},{"location":"CompositeState/#stateforward.elements.CompositeState","title":"CompositeState","text":"<p>             Bases: <code>Element</code></p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class CompositeState(model.Element):\n    region: model.Collection[\"Region\"] = None\n</code></pre>"},{"location":"Roadmap/","title":"Roadmap","text":""},{"location":"Roadmap/#roadmap","title":"Roadmap","text":""},{"location":"Roadmap/#submachine","title":"Submachine","text":"<ul> <li> Implement Submachine: Creation of a substate machine within the larger state machine architecture is complete.</li> <li> Define Entry Point: Establish the initialization state where the submachine commences its process.</li> <li> Institute Exit Point: Designate the final state that concludes the submachine's execution and handle any necessary state cleanup.</li> </ul>"},{"location":"Roadmap/#history-pseudostate","title":"History Pseudostate","text":"<ul> <li> Integrate Shallow History: Develop a state memory system that recalls the most recent active substate without retaining nested state histories, enabling reentry at the last active state.</li> <li> Incorporate Deep History: Implement a comprehensive state memory system that retains complete nested state histories for accurate restoration upon reentry.</li> </ul>"},{"location":"Roadmap/#statemachine-interpreters","title":"StateMachine Interpreters","text":"<ul> <li> Implement Async StateMachine Interpreter: Completed the asynchronous state machine interpreter, facilitating non-blocking state execution.</li> <li> Develop Multi-Processing StateMachine Interpreter: Construct an interpreter that utilizes multiple processes for parallel state processing, enhancing performance for computations.</li> <li> Construct Thread-Based Interpreter: Build an interpreter that manages state operations via threading, optimizing for concurrent I/O-bound tasks.</li> <li> Design SequentialStateMachine Interpreter: Initiate the creation of an interpreter that deals with state transitions in a sequential, ordered manner, designed for straightforward execution flows.</li> </ul>"},{"location":"Roadmap/#unit-tests","title":"Unit Tests","text":"<ul> <li> Develop Unit Tests: Write tests for individual state components to evaluate their independent functionalities, ensuring reliability and bug-free operation.</li> </ul>"},{"location":"Roadmap/#documentation","title":"Documentation","text":"<ul> <li> Compile Documentation: Produce detailed documentation outlining the state machine's configuration, including its states, transitions, and state machine protocols, to support maintenance and usage comprehension.</li> </ul>"},{"location":"Roadmap/#interpreter-refactoring","title":"Interpreter Refactoring","text":"<ul> <li> Refactor Interpreter Logic: Rework the interpreter component to execute a sequence of abstract instructions, rather than direct manipulation of the state tree, for better modularity and maintainability.</li> </ul> <p>See the open issues for a full list of proposed features (and known issues).</p>"},{"location":"StateMachine/","title":"StateMachine","text":""},{"location":"StateMachine/#stateforward.elements.StateMachine","title":"StateMachine","text":"<p>             Bases: <code>Behavior</code>, <code>CompositeState</code></p> <p>The <code>StateMachine</code> in StateForward is partially inspired by UML2.5 and is therefore designed with flexibility to deviate from the strict UML specifications when it provides practical benefits for development.</p> <p>Attributes:</p> Name Type Description <code>submachine_state</code> <code>State</code> <p>The current State of the submachine. This refers to the currently active State within the StateMachine.</p> <code>state</code> <code>tuple[State]</code> <p>Retrieves a tuple of active <code>State</code> instances that are currently active in the state machine.</p> <p>A <code>StateMachine</code> is organized into one or more <code>Region</code> elements \u2014 see CompositeState for more details.</p> <p>The StateForward preprocessor automatically creates <code>Region</code> elements when substates are added to a <code>State</code> or <code>StateMachine</code>. This concurrent workflow within different regions of the state machine allows for sophisticated behavior patterns that can simulate complex systems' parallel operations.</p> Source code in <code>stateforward/elements/elements.py</code> <pre><code>class StateMachine(Behavior, CompositeState):\n    \"\"\"\n    The `StateMachine` in StateForward is partially inspired by UML2.5 and is therefore designed with flexibility to deviate from the strict UML specifications when it provides practical benefits for development.\n\n    Attributes:\n        submachine_state (State): The current State of the submachine. This refers to the currently active State\n            within the StateMachine.\n        state: Retrieves a tuple of active `State` instances that are currently active in the state machine.\n\n\n    A `StateMachine` is organized into one or more `Region` elements \u2014 see [CompositeState](#compositestate) for more details.\n\n    The StateForward preprocessor automatically creates `Region` elements when substates are added to a `State` or `StateMachine`. This concurrent workflow within different regions of the state machine allows for sophisticated behavior patterns that can simulate complex systems' parallel operations.\n    \"\"\"\n\n    submachine_state: State = None\n\n    @property\n    def state(self) -&gt; tuple[State]:\n        return tuple(\n            cast(State, value)\n            for value in self.interpreter.active.keys()\n            if model.is_subtype(value, State)\n        )\n</code></pre>"},{"location":"modeling/Element/","title":"Element","text":""},{"location":"modeling/Element/#stateforward.model.Element","title":"Element","text":"<p>             Bases: <code>ElementInterface[T]</code></p> Source code in <code>stateforward/model/element.py</code> <pre><code>class Element(ElementInterface[T]):\n    __init__: Callable[P, None] = object.__init__\n\n    def __init_subclass__(\n        cls: type[\"Element\"],\n        name: str = None,\n        redefined_element: \"ElementType\" = None,\n        **kwargs: dict,\n    ) -&gt; None:\n        \"\"\"Customize initialization process when creating a subclass of Element.\n\n        This class method is automatically invoked when a subclass of Element is\n        created, allowing the subclass to inherit or define additional attributes\n        and behaviors.\n\n        Args:\n            cls: The class object that is being initialized as a subclass.\n            name: The name given to the subclass. If not provided,\n                the name of the class will be used as the default.\n            redefined_element: The element that this\n                subclass is intending to redefine. It links back to the base element\n                being redefined.\n            **kwargs: Additional keyword arguments representing attributes that may be\n                passed to define or redefine behaviors and properties of the subclass.\n\n        Raises:\n            TypeError: If a keyword in `kwargs` is neither found in the attributes of\n                the class nor in the annotations of `ElementInterface`.\n\n        After subclass creation, various class attributes are initialized or updated:\n\n        - `attributes`: A dictionary of attributes, which is a copy of the existing\n          attributes or an empty dictionary if it does not exist.\n        - `owned_elements`: A list that tracks elements owned by this class, initialized\n          as an empty list.\n        - `name`: The name of the subclass, which either comes from the provided `name`\n          argument or defaults to the class's `__name__` attribute.\n        - `qualified_name`: The qualified name of the class, derived from `__qualname__`.\n        - `owner`: Set to None, indicating that this class does not have an owner by\n          default.\n        - `type`: A reference to the class itself.\n        - `model`: An association of the class, typically constructed through a separate\n          `association` function or method.\n        - `associations`: A dictionary for tracking associations, initialized as an\n          empty dictionary.\n        - `redefined_element`: The element set for redefinition, if provided, otherwise\n          it falls back to the class's own `redefined_element` if previously set.\n\n        Depending on the context, `__define__` or `__redefine__` method is called to\n        finalize the subclass definition.\n\n        Note:\n            This method forms the crux for the creation of structured, inheritable, and\n            customizable model elements within a modeling framework.\n\n        Example:\n            To create a new subclass of `Element`:\n\n            ```python\n            class MyCustomElement(Element, name='MyElement', custom_attribute='value'):\n                # custom definitions and attributes here\n            ```\n        \"\"\"\n        attributes = cls.attributes = (cls.attributes or {}).copy()\n        for key in kwargs:\n            if key not in attributes and key not in ElementInterface.__annotations__:\n                raise TypeError(\n                    f\"{name or cls.__name__}.__init_subclass__ got an unexpected keyword {key}\"\n                )\n        cls.owned_elements = []\n        cls.name = name or cls.__name__\n        cls.qualified_name = cls.__qualname__\n        cls.owner = None\n        cls.type = cls\n        cls.model = association(cls)\n        cls.associations = {}\n        cls.redefined_element = redefined_element or cls.redefined_element\n        if cls.__base__.owned_elements:\n            specialize(cls.__base__, cls)\n        if redefined_element is None:\n            cls.__define__(name=name, **kwargs)\n        else:\n            cls.__redefine__(redefined_element=cls.redefined_element, **kwargs)\n\n    @classmethod\n    def __redefine__(cls, **kwargs):\n        for key, value in kwargs.items():\n            set_attribute(cls, key, value)\n\n    @classmethod\n    def __define__(\n        cls: type[\"Element\"],\n        name: str = None,\n        owned_elements: Sequence[\"ElementType\"] = (),\n        **kwargs: dict,\n    ) -&gt; None:\n        \"\"\"Defines the class with specified attributes and set of owned elements.\n\n        This method is responsible for setting up the attributes on the class based\n        on input from the `__init_subclass__` method of the class. It allows defining\n        the class according to specified rules and the addition of owned elements\n        that are tied to this class.\n\n        Args:\n            cls: The class object being defined.\n            name: The name of the class. If not provided, defaults to\n                `None` and does not contribute to setting attributes.\n            owned_elements: A sequence of element types\n                that are owned by the class. These will be subsequently added to the\n                class's owned elements.\n            **kwargs: Additional keyword arguments representing attributes that are\n                meant to be set on the class.\n\n        For each element in the `owned_elements`, the `add_owned_element` function is\n        called to register it with this class.\n\n        It also iterates through the class annotations and existing class attributes,\n        combined with `kwargs`, to set attributes on the class. Unless the key is\n        specifically structured as an internal attribute (e.g., `__something__`),\n        it will be set using the `set_attribute` function provided key is not part\n        of `ElementInterface` annotations.\n        \"\"\"\n        for owned_element in owned_elements:\n            add_owned_element(cls, owned_element)\n        for key, value in {\n            **dict((name, getattr(cls, name, MISSING)) for name in cls.__annotations__),\n            **cls.__dict__,\n            **kwargs,\n        }.items():\n            if (\n                f\"{key[-2:]}{key[:2]}\" != \"____\"\n                and key not in ElementInterface.__annotations__\n            ):\n                set_attribute(cls, key, value)\n\n    @staticmethod\n    def __new__(\n        cls: type[\"Element\"],\n        *args: Sequence[Any],\n        **kwargs: dict,\n    ) -&gt; Union[\"Element\", Callable[[], \"Element\"]]:\n        \"\"\"Create a new instance of an Element or its subclass.\n\n        The `__new__` method is responsible for instance creation and is invoked\n        before `__init__`. For the `Element` class, this method also initializes owned\n        elements, sets up an element map for namespace management, and defines the\n        model and attributes.\n\n        Args:\n            cls: The class of which an instance is to be created.\n            *args: Variable-length argument list, not directly used in this method.\n            **kwargs: Arbitrary keyword arguments that may include:\n                - owner: an optional reference to the owner of the element instance.\n                - element_map: a dictionary that holds element instances keyed by their\n                  qualified names, providing a namespace for elements.\n\n        Returns:\n            A new instance of `cls` if not called on an owned element. Otherwise, it provides a lambda function that returns the instance itself when called, as a workaround to suppress further initialization logic from being executed automatically.\n\n        The `element_map` is a crucial component that allows elements to reference\n        each other correctly. When the `owner` is `None`, the hierarchy of elements is\n        initialised recursively. This involves populating `attributes` with proper\n        references to other elements within the map and invoking `__init__` for each\n        non-root element with any additional keyword arguments matching their qualified\n        name. The `element_map` should initially include at least the current instance\n        with its qualified name.\n\n        \"\"\"\n        self = super().__new__(cls)\n        self.owner = kwargs.pop(\"owner\", None)\n        self.owned_elements = []\n        self.attributes = {}\n        self.model = self.owner.model if self.owner is not None else self\n        element_map = kwargs.pop(\n            \"element_map\", {self.qualified_name: self}\n        )  # create a namespace for the elements in the element\n        for owned_element in cls.owned_elements:\n            instance = owned_element(\n                owner=self,\n                element_map=element_map,\n            )()  # using the extra function call to prevent __init__ from being called\n            element_map[owned_element.qualified_name] = instance\n            self.owned_elements.append(instance)\n        if self.owner is None:\n            for element in reversed(element_map.values()):\n                for name, value in element.__class__.attributes.items():\n                    if is_element(value):\n                        value = element.attributes[name] = element_map[\n                            value.qualified_name\n                        ]\n                        setattr(element, str(name), value)\n                if element is not self:\n                    element.__init__(**kwargs.pop(element.qualified_name, {}))\n            # this is the root element of the element, so we can start initializing\n            return self\n        # a hack to prevent __init__ from being called\n        return lambda _self=self: _self\n</code></pre>"},{"location":"modeling/Element/#stateforward.model.Element.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(name: str = None, redefined_element: ElementType = None, **kwargs: dict) -&gt; None\n</code></pre> <p>Customize initialization process when creating a subclass of Element.</p> <p>This class method is automatically invoked when a subclass of Element is created, allowing the subclass to inherit or define additional attributes and behaviors.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Element]</code> <p>The class object that is being initialized as a subclass.</p> required <code>name</code> <code>str</code> <p>The name given to the subclass. If not provided, the name of the class will be used as the default.</p> <code>None</code> <code>redefined_element</code> <code>ElementType</code> <p>The element that this subclass is intending to redefine. It links back to the base element being redefined.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments representing attributes that may be passed to define or redefine behaviors and properties of the subclass.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a keyword in <code>kwargs</code> is neither found in the attributes of the class nor in the annotations of <code>ElementInterface</code>.</p> <p>After subclass creation, various class attributes are initialized or updated:</p> <ul> <li><code>attributes</code>: A dictionary of attributes, which is a copy of the existing   attributes or an empty dictionary if it does not exist.</li> <li><code>owned_elements</code>: A list that tracks elements owned by this class, initialized   as an empty list.</li> <li><code>name</code>: The name of the subclass, which either comes from the provided <code>name</code>   argument or defaults to the class's <code>__name__</code> attribute.</li> <li><code>qualified_name</code>: The qualified name of the class, derived from <code>__qualname__</code>.</li> <li><code>owner</code>: Set to None, indicating that this class does not have an owner by   default.</li> <li><code>type</code>: A reference to the class itself.</li> <li><code>model</code>: An association of the class, typically constructed through a separate   <code>association</code> function or method.</li> <li><code>associations</code>: A dictionary for tracking associations, initialized as an   empty dictionary.</li> <li><code>redefined_element</code>: The element set for redefinition, if provided, otherwise   it falls back to the class's own <code>redefined_element</code> if previously set.</li> </ul> <p>Depending on the context, <code>__define__</code> or <code>__redefine__</code> method is called to finalize the subclass definition.</p> Note <p>This method forms the crux for the creation of structured, inheritable, and customizable model elements within a modeling framework.</p> Example <p>To create a new subclass of <code>Element</code>:</p> <pre><code>class MyCustomElement(Element, name='MyElement', custom_attribute='value'):\n    # custom definitions and attributes here\n</code></pre> Source code in <code>stateforward/model/element.py</code> <pre><code>def __init_subclass__(\n    cls: type[\"Element\"],\n    name: str = None,\n    redefined_element: \"ElementType\" = None,\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"Customize initialization process when creating a subclass of Element.\n\n    This class method is automatically invoked when a subclass of Element is\n    created, allowing the subclass to inherit or define additional attributes\n    and behaviors.\n\n    Args:\n        cls: The class object that is being initialized as a subclass.\n        name: The name given to the subclass. If not provided,\n            the name of the class will be used as the default.\n        redefined_element: The element that this\n            subclass is intending to redefine. It links back to the base element\n            being redefined.\n        **kwargs: Additional keyword arguments representing attributes that may be\n            passed to define or redefine behaviors and properties of the subclass.\n\n    Raises:\n        TypeError: If a keyword in `kwargs` is neither found in the attributes of\n            the class nor in the annotations of `ElementInterface`.\n\n    After subclass creation, various class attributes are initialized or updated:\n\n    - `attributes`: A dictionary of attributes, which is a copy of the existing\n      attributes or an empty dictionary if it does not exist.\n    - `owned_elements`: A list that tracks elements owned by this class, initialized\n      as an empty list.\n    - `name`: The name of the subclass, which either comes from the provided `name`\n      argument or defaults to the class's `__name__` attribute.\n    - `qualified_name`: The qualified name of the class, derived from `__qualname__`.\n    - `owner`: Set to None, indicating that this class does not have an owner by\n      default.\n    - `type`: A reference to the class itself.\n    - `model`: An association of the class, typically constructed through a separate\n      `association` function or method.\n    - `associations`: A dictionary for tracking associations, initialized as an\n      empty dictionary.\n    - `redefined_element`: The element set for redefinition, if provided, otherwise\n      it falls back to the class's own `redefined_element` if previously set.\n\n    Depending on the context, `__define__` or `__redefine__` method is called to\n    finalize the subclass definition.\n\n    Note:\n        This method forms the crux for the creation of structured, inheritable, and\n        customizable model elements within a modeling framework.\n\n    Example:\n        To create a new subclass of `Element`:\n\n        ```python\n        class MyCustomElement(Element, name='MyElement', custom_attribute='value'):\n            # custom definitions and attributes here\n        ```\n    \"\"\"\n    attributes = cls.attributes = (cls.attributes or {}).copy()\n    for key in kwargs:\n        if key not in attributes and key not in ElementInterface.__annotations__:\n            raise TypeError(\n                f\"{name or cls.__name__}.__init_subclass__ got an unexpected keyword {key}\"\n            )\n    cls.owned_elements = []\n    cls.name = name or cls.__name__\n    cls.qualified_name = cls.__qualname__\n    cls.owner = None\n    cls.type = cls\n    cls.model = association(cls)\n    cls.associations = {}\n    cls.redefined_element = redefined_element or cls.redefined_element\n    if cls.__base__.owned_elements:\n        specialize(cls.__base__, cls)\n    if redefined_element is None:\n        cls.__define__(name=name, **kwargs)\n    else:\n        cls.__redefine__(redefined_element=cls.redefined_element, **kwargs)\n</code></pre>"},{"location":"modeling/Element/#stateforward.model.Element.__define__","title":"__define__  <code>classmethod</code>","text":"<pre><code>__define__(name: str = None, owned_elements: Sequence[ElementType] = (), **kwargs: dict) -&gt; None\n</code></pre> <p>Defines the class with specified attributes and set of owned elements.</p> <p>This method is responsible for setting up the attributes on the class based on input from the <code>__init_subclass__</code> method of the class. It allows defining the class according to specified rules and the addition of owned elements that are tied to this class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Element]</code> <p>The class object being defined.</p> required <code>name</code> <code>str</code> <p>The name of the class. If not provided, defaults to <code>None</code> and does not contribute to setting attributes.</p> <code>None</code> <code>owned_elements</code> <code>Sequence[ElementType]</code> <p>A sequence of element types that are owned by the class. These will be subsequently added to the class's owned elements.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments representing attributes that are meant to be set on the class.</p> <code>{}</code> <p>For each element in the <code>owned_elements</code>, the <code>add_owned_element</code> function is called to register it with this class.</p> <p>It also iterates through the class annotations and existing class attributes, combined with <code>kwargs</code>, to set attributes on the class. Unless the key is specifically structured as an internal attribute (e.g., <code>__something__</code>), it will be set using the <code>set_attribute</code> function provided key is not part of <code>ElementInterface</code> annotations.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@classmethod\ndef __define__(\n    cls: type[\"Element\"],\n    name: str = None,\n    owned_elements: Sequence[\"ElementType\"] = (),\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"Defines the class with specified attributes and set of owned elements.\n\n    This method is responsible for setting up the attributes on the class based\n    on input from the `__init_subclass__` method of the class. It allows defining\n    the class according to specified rules and the addition of owned elements\n    that are tied to this class.\n\n    Args:\n        cls: The class object being defined.\n        name: The name of the class. If not provided, defaults to\n            `None` and does not contribute to setting attributes.\n        owned_elements: A sequence of element types\n            that are owned by the class. These will be subsequently added to the\n            class's owned elements.\n        **kwargs: Additional keyword arguments representing attributes that are\n            meant to be set on the class.\n\n    For each element in the `owned_elements`, the `add_owned_element` function is\n    called to register it with this class.\n\n    It also iterates through the class annotations and existing class attributes,\n    combined with `kwargs`, to set attributes on the class. Unless the key is\n    specifically structured as an internal attribute (e.g., `__something__`),\n    it will be set using the `set_attribute` function provided key is not part\n    of `ElementInterface` annotations.\n    \"\"\"\n    for owned_element in owned_elements:\n        add_owned_element(cls, owned_element)\n    for key, value in {\n        **dict((name, getattr(cls, name, MISSING)) for name in cls.__annotations__),\n        **cls.__dict__,\n        **kwargs,\n    }.items():\n        if (\n            f\"{key[-2:]}{key[:2]}\" != \"____\"\n            and key not in ElementInterface.__annotations__\n        ):\n            set_attribute(cls, key, value)\n</code></pre>"},{"location":"modeling/Element/#stateforward.model.Element.__new__","title":"__new__  <code>staticmethod</code>","text":"<pre><code>__new__(*args: Sequence[Any], **kwargs: dict) -&gt; Union[Element, Callable[[], Element]]\n</code></pre> <p>Create a new instance of an Element or its subclass.</p> <p>The <code>__new__</code> method is responsible for instance creation and is invoked before <code>__init__</code>. For the <code>Element</code> class, this method also initializes owned elements, sets up an element map for namespace management, and defines the model and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Element]</code> <p>The class of which an instance is to be created.</p> required <code>*args</code> <code>Sequence[Any]</code> <p>Variable-length argument list, not directly used in this method.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Arbitrary keyword arguments that may include: - owner: an optional reference to the owner of the element instance. - element_map: a dictionary that holds element instances keyed by their   qualified names, providing a namespace for elements.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Element, Callable[[], Element]]</code> <p>A new instance of <code>cls</code> if not called on an owned element. Otherwise, it provides a lambda function that returns the instance itself when called, as a workaround to suppress further initialization logic from being executed automatically.</p> <p>The <code>element_map</code> is a crucial component that allows elements to reference each other correctly. When the <code>owner</code> is <code>None</code>, the hierarchy of elements is initialised recursively. This involves populating <code>attributes</code> with proper references to other elements within the map and invoking <code>__init__</code> for each non-root element with any additional keyword arguments matching their qualified name. The <code>element_map</code> should initially include at least the current instance with its qualified name.</p> Source code in <code>stateforward/model/element.py</code> <pre><code>@staticmethod\ndef __new__(\n    cls: type[\"Element\"],\n    *args: Sequence[Any],\n    **kwargs: dict,\n) -&gt; Union[\"Element\", Callable[[], \"Element\"]]:\n    \"\"\"Create a new instance of an Element or its subclass.\n\n    The `__new__` method is responsible for instance creation and is invoked\n    before `__init__`. For the `Element` class, this method also initializes owned\n    elements, sets up an element map for namespace management, and defines the\n    model and attributes.\n\n    Args:\n        cls: The class of which an instance is to be created.\n        *args: Variable-length argument list, not directly used in this method.\n        **kwargs: Arbitrary keyword arguments that may include:\n            - owner: an optional reference to the owner of the element instance.\n            - element_map: a dictionary that holds element instances keyed by their\n              qualified names, providing a namespace for elements.\n\n    Returns:\n        A new instance of `cls` if not called on an owned element. Otherwise, it provides a lambda function that returns the instance itself when called, as a workaround to suppress further initialization logic from being executed automatically.\n\n    The `element_map` is a crucial component that allows elements to reference\n    each other correctly. When the `owner` is `None`, the hierarchy of elements is\n    initialised recursively. This involves populating `attributes` with proper\n    references to other elements within the map and invoking `__init__` for each\n    non-root element with any additional keyword arguments matching their qualified\n    name. The `element_map` should initially include at least the current instance\n    with its qualified name.\n\n    \"\"\"\n    self = super().__new__(cls)\n    self.owner = kwargs.pop(\"owner\", None)\n    self.owned_elements = []\n    self.attributes = {}\n    self.model = self.owner.model if self.owner is not None else self\n    element_map = kwargs.pop(\n        \"element_map\", {self.qualified_name: self}\n    )  # create a namespace for the elements in the element\n    for owned_element in cls.owned_elements:\n        instance = owned_element(\n            owner=self,\n            element_map=element_map,\n        )()  # using the extra function call to prevent __init__ from being called\n        element_map[owned_element.qualified_name] = instance\n        self.owned_elements.append(instance)\n    if self.owner is None:\n        for element in reversed(element_map.values()):\n            for name, value in element.__class__.attributes.items():\n                if is_element(value):\n                    value = element.attributes[name] = element_map[\n                        value.qualified_name\n                    ]\n                    setattr(element, str(name), value)\n            if element is not self:\n                element.__init__(**kwargs.pop(element.qualified_name, {}))\n        # this is the root element of the element, so we can start initializing\n        return self\n    # a hack to prevent __init__ from being called\n    return lambda _self=self: _self\n</code></pre>"},{"location":"modeling/ElementInterface/","title":"ElementInterface","text":""},{"location":"modeling/ElementInterface/#stateforward.model.element.ElementInterface","title":"ElementInterface","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A generic interface defining the structure and behavior of model elements.</p> <p>The <code>ElementInterface</code> is a generic class that serves as a base for creating elements within a model. It defines both class variables and instance variables which are used to maintain element metadata, associations, and ownership relationships.</p> Type Variables <p>T: The generic type parameter specifying the type of owned elements.</p> Class Variables <p>name (ClassVar[str]): The name of the element. qualified_name (ClassVar[str]): The fully qualified name of the element. type (ClassVar[Type[\"Element\"]]): The type of the element itself; usually     a reference to the class. redefined_element (ClassVar[Type[\"Element\"]]): The element that is being     redefined by this element class, if any.</p> <p>Class &amp; Instance Variables:     associations (dict[str, Association]): A dictionary holding associations with         other elements. For each association name (key), the corresponding         <code>Association</code> object is the value.     owned_elements (Union[list[\"ElementType\"], list[T]]): A list of elements         owned by this element. <code>ElementType</code> is assumed to refer to other classes         that should be replaced with specific element types that are owned by this         interface.     owner (Optional[Association[\"ElementType\"]]): The association representing         the owner of this element. It is optional and could be <code>None</code> if the         element has no owner.     model (Association[\"Model\"]): An association linking this element to its         containing model.     attributes (dict[Any, Any]): A dictionary of attributes for the element         where keys are attribute names and values are the associated data.</p> Note <ul> <li>The <code>ElementInterface</code> is not meant to be instantiated directly but to be   subclassed by specific element implementations in a modeling framework.</li> <li>It assumes the existence of the <code>Association</code> class or type, referenced in   variable annotations, which should be defined elsewhere in the code.</li> </ul> Source code in <code>stateforward/model/element.py</code> <pre><code>class ElementInterface(Generic[T]):\n    \"\"\"A generic interface defining the structure and behavior of model elements.\n\n    The `ElementInterface` is a generic class that serves as a base for creating\n    elements within a model. It defines both class variables and instance variables\n    which are used to maintain element metadata, associations, and ownership\n    relationships.\n\n    Type Variables:\n        T: The generic type parameter specifying the type of owned elements.\n\n    Class Variables:\n        name (ClassVar[str]): The name of the element.\n        qualified_name (ClassVar[str]): The fully qualified name of the element.\n        type (ClassVar[Type[\"Element\"]]): The type of the element itself; usually\n            a reference to the class.\n        redefined_element (ClassVar[Type[\"Element\"]]): The element that is being\n            redefined by this element class, if any.\n\n    Class &amp; Instance Variables:\n        associations (dict[str, Association]): A dictionary holding associations with\n            other elements. For each association name (key), the corresponding\n            `Association` object is the value.\n        owned_elements (Union[list[\"ElementType\"], list[T]]): A list of elements\n            owned by this element. `ElementType` is assumed to refer to other classes\n            that should be replaced with specific element types that are owned by this\n            interface.\n        owner (Optional[Association[\"ElementType\"]]): The association representing\n            the owner of this element. It is optional and could be `None` if the\n            element has no owner.\n        model (Association[\"Model\"]): An association linking this element to its\n            containing model.\n        attributes (dict[Any, Any]): A dictionary of attributes for the element\n            where keys are attribute names and values are the associated data.\n\n    Note:\n        - The `ElementInterface` is not meant to be instantiated directly but to be\n          subclassed by specific element implementations in a modeling framework.\n        - It assumes the existence of the `Association` class or type, referenced in\n          variable annotations, which should be defined elsewhere in the code.\n    \"\"\"\n\n    # class variables\n    name: ClassVar[str] = None\n    qualified_name: ClassVar[str] = None\n    type: ClassVar[Type[\"Element\"]] = None\n    redefined_element: ClassVar[Type[\"Element\"]] = None\n\n    # class &amp; instance variables\n    associations: dict[str, Association] = None\n    owned_elements: Union[list[\"ElementType\"], list[T]] = None\n    owner: Optional[Association[\"ElementType\"]] = None\n    model: Association[\"Model\"] = None\n    attributes: dict[Any, Any] = None\n</code></pre>"},{"location":"modeling/Model/","title":"Model","text":""},{"location":"modeling/Model/#stateforward.model.Model","title":"Model","text":"<p>             Bases: <code>Element</code></p> <p>A base Model class for handling processing elements.</p> <p><code>Model</code> serves as a template for creating models which include preprocessing, validation, and interpretation logic. Subclasses of Model should define their specific processing behavior.</p> <p>Attributes:</p> Name Type Description <code>preprocessor</code> <code>ClassVar[Preprocessor]</code> <p>A class-level attribute that holds a <code>Preprocessor</code> instance or None by default. The <code>Preprocessor</code> instance is responsible for preparing input data for the model.</p> <code>validator</code> <code>ClassVar[Validator]</code> <p>A class-level attribute that holds a <code>Validator</code> instance or None by default. The <code>Validator</code> instance is responsible for ensuring that the model's input data is valid.</p> <code>interpreter</code> <code>ClassVar[type[Interpreter]]</code> <p>A class-level attribute that holds a 'Interpreter' class or None by default. The 'Interpreter' class is responsible for interpreting the model's output.</p> <p>To create a subclass of Model with specific processing components:</p> <pre><code>class MyModel(Model, preprocessor=MyPreprocessor, validator=MyValidator,\n              interpreter=MyInterpreter):\n    pass\n</code></pre> <p>When creating a subclass, if specific processors are not provided, the class-level attributes from the <code>Model</code> base class will be used.</p> Note <ul> <li>If a preprocessor is provided and a preprocessor already exists, the   existing one's <code>preprocess</code> method will be called before it is replaced.</li> <li>Similarly, if a validator is provided and a validator already exists, the   existing one's <code>validate</code> method will be called before it is replaced.</li> </ul> Source code in <code>stateforward/model/model.py</code> <pre><code>class Model(Element):\n    \"\"\"A base Model class for handling processing elements.\n\n    `Model` serves as a template for creating models which include preprocessing,\n    validation, and interpretation logic. Subclasses of Model should define their\n    specific processing behavior.\n\n    Attributes:\n        preprocessor (ClassVar[Preprocessor], optional): A class-level attribute\n            that holds a `Preprocessor` instance or None by default. The `Preprocessor`\n            instance is responsible for preparing input data for the model.\n        validator (ClassVar[Validator], optional): A class-level attribute that\n            holds a `Validator` instance or None by default. The `Validator` instance is\n            responsible for ensuring that the model's input data is valid.\n        interpreter (ClassVar[type[Interpreter]], optional): A class-level attribute\n            that holds a 'Interpreter' class or None by default. The 'Interpreter'\n            class is responsible for interpreting the model's output.\n\n    To create a subclass of Model with specific processing components:\n\n    ```python\n    class MyModel(Model, preprocessor=MyPreprocessor, validator=MyValidator,\n                  interpreter=MyInterpreter):\n        pass\n    ```\n\n    When creating a subclass, if specific processors are not provided, the\n    class-level attributes from the `Model` base class will be used.\n\n    Note:\n        - If a preprocessor is provided and a preprocessor already exists, the\n          existing one's `preprocess` method will be called before it is replaced.\n        - Similarly, if a validator is provided and a validator already exists, the\n          existing one's `validate` method will be called before it is replaced.\n    \"\"\"\n\n    preprocessor: ClassVar[Type[\"Preprocessor\"]] = None\n    validator: ClassVar[Type[\"Validator\"]] = None\n    interpreter: ClassVar[Type[\"Interpreter\"]] = None\n\n    def __init_subclass__(\n        cls: type[\"Model\"],\n        preprocessor: Optional[type[\"Preprocessor\"]] = None,\n        validator: Optional[type[\"Validator\"]] = None,\n        processor: Optional[type[\"Interpreter\"]] = None,\n        **kwargs: dict,\n    ):\n        \"\"\"Initializes the subclass with the provided processors.\n\n        This magic method is automatically called during the creation of a subclass\n        and updates the subclass's preprocessor, validator, and interpreter with the\n        provided arguments if they are not None; otherwise, it retains the existing\n        processors from the base class.\n\n        Args:\n            cls: The subclass of `Model` being initialized.\n            preprocessor: An instance or class of\n                a `Preprocessor`.\n            validator: An instance or class of a `Validator`.\n            processor: A class of `Interpreter`.\n            **kwargs: Arbitrary keyword arguments that are passed to the base\n                class's `__init_subclass__` method.\n        \"\"\"\n        super().__init_subclass__(**kwargs)\n        if cls.preprocessor is not None:\n            cls.preprocessor().preprocess(cls)\n        cls.preprocessor = preprocessor or cls.preprocessor\n        if cls.validator is not None:\n            cls.validator().validate(cls)\n        cls.validator = validator or cls.validator\n</code></pre>"},{"location":"modeling/Model/#stateforward.model.Model.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(preprocessor: Optional[type[Preprocessor]] = None, validator: Optional[type[Validator]] = None, processor: Optional[type[Interpreter]] = None, **kwargs: dict)\n</code></pre> <p>Initializes the subclass with the provided processors.</p> <p>This magic method is automatically called during the creation of a subclass and updates the subclass's preprocessor, validator, and interpreter with the provided arguments if they are not None; otherwise, it retains the existing processors from the base class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Model]</code> <p>The subclass of <code>Model</code> being initialized.</p> required <code>preprocessor</code> <code>Optional[type[Preprocessor]]</code> <p>An instance or class of a <code>Preprocessor</code>.</p> <code>None</code> <code>validator</code> <code>Optional[type[Validator]]</code> <p>An instance or class of a <code>Validator</code>.</p> <code>None</code> <code>processor</code> <code>Optional[type[Interpreter]]</code> <p>A class of <code>Interpreter</code>.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Arbitrary keyword arguments that are passed to the base class's <code>__init_subclass__</code> method.</p> <code>{}</code> Source code in <code>stateforward/model/model.py</code> <pre><code>def __init_subclass__(\n    cls: type[\"Model\"],\n    preprocessor: Optional[type[\"Preprocessor\"]] = None,\n    validator: Optional[type[\"Validator\"]] = None,\n    processor: Optional[type[\"Interpreter\"]] = None,\n    **kwargs: dict,\n):\n    \"\"\"Initializes the subclass with the provided processors.\n\n    This magic method is automatically called during the creation of a subclass\n    and updates the subclass's preprocessor, validator, and interpreter with the\n    provided arguments if they are not None; otherwise, it retains the existing\n    processors from the base class.\n\n    Args:\n        cls: The subclass of `Model` being initialized.\n        preprocessor: An instance or class of\n            a `Preprocessor`.\n        validator: An instance or class of a `Validator`.\n        processor: A class of `Interpreter`.\n        **kwargs: Arbitrary keyword arguments that are passed to the base\n            class's `__init_subclass__` method.\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    if cls.preprocessor is not None:\n        cls.preprocessor().preprocess(cls)\n    cls.preprocessor = preprocessor or cls.preprocessor\n    if cls.validator is not None:\n        cls.validator().validate(cls)\n    cls.validator = validator or cls.validator\n</code></pre>"},{"location":"modeling/Overview/","title":"Overview","text":"<p>The Element is the foundational class for all StateForward elements. It provides essential functionality for creating a tree structure and managing relationships.</p> <p>In contrast to the <code>ast</code> module, the Element and its associated elements are classes rather than objects. This design choice is based on several reasons:</p> <ol> <li>The tree is constructed only once at the initiation of the Python process and remains static thereafter. This results in a one-time overhead, which becomes significant when we examine the <code>Model</code> element.</li> <li>Elements can be customized through standard inheritance and polymorphism. This feature enables the development of unique elements that can enhance the capabilities of the <code>Element</code> class.</li> <li>Elements are instantiated in the same manner as any other Python object.</li> </ol>"},{"location":"modeling/Overview/#stateforward.model--element-definition","title":"Element Definition","text":"<p>Element Example</p> CodeOutput <pre><code>import stateforward as sf\nfrom typing import Union\n\n\nclass FamilyTreeElement(sf.Element):\n    def __new__(cls, *args, **kwargs):\n        print(f\"{cls.qualified_name}.__new__\")\n        return super().__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        print(f\"{self.qualified_name}.__init__\")\n        super().__init__(*args, **kwargs)\n\n\nclass Person(FamilyTreeElement):\n    first_name: str\n    age: int\n    kids: Union[FamilyTreeElement, sf.Collection[FamilyTreeElement]] = None\n\n\nclass FamilyTree(FamilyTreeElement):\n    pass\n\n\nclass Family(FamilyTree):\n    class Dad(Person, first_name=\"John\", age=40):\n        pass\n\n    class Mom(Person, first_name=\"Jane\", age=38):\n        class Son(Person, first_name=\"Jack\", age=15):\n            pass\n\n        class Daughter(Person, first_name=\"Jill\", age=26):\n            class Grandson(Person, first_name=\"Jimmy\", age=1):\n                pass\n\n        class SonInLaw(Person, first_name=\"John\", age=26):\n            pass\n\n\nsf.dump(Family)\n</code></pre> <pre><code>0 -&gt; Family type[FamilyTree] @ 0x105882730\n 1 -&gt; Family.Dad type[Person] @ 0x10587feb0\n 1 -&gt; Family.Mom type[Person] @ 0x105882070\n  2 -&gt; Family.Mom.Son type[Person] @ 0x105880570\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x1058812f0\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x105880c30\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x1058819b0\n</code></pre> <p>The leading numbers in the output denote the hierarchical level of each element within the tree structure, which aids in deciphering the connections among elements. Even upon instantiation, this hierarchical format is preserved.</p>"},{"location":"modeling/Overview/#stateforward.model--instantiating-elements","title":"Instantiating Elements","text":"<p>Element Instantiation Example</p> element_example.pyOutput <pre><code>my_family = Family()\nsf.dump(my_family)\nprint(my_family.Dad)\n</code></pre> <pre><code>Family.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x1011ea59\n 1 -&gt; Family.Dad object[Person] @ 0x101a7cb9\n 1 -&gt; Family.Mom object[Person] @ 0x101a7cc9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x101a7cdd\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x101a7ced\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x101a7d05\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x101a7d11\n&lt;__main__.Family.Dad object at 0x101a7cb9&gt;\n</code></pre> <p>Print statements were added to <code>__new__</code> and <code>__init__</code> to demonstrate the order of instantiation and initialization of a tree of Elements. This is done intentionally to ensure that all elements are instantiated before any of them are initialized making them safe to access or references inside the <code>__init__</code> method. Additionally the owned elements that are declared in <code>Family</code> become object attributes of the <code>Family</code> instance. As you can see in the printed <code>my_family.Dad</code> statement output.</p>"},{"location":"modeling/Overview/#stateforward.model--association-definition","title":"Association Definition","text":"<p>An <code>Association</code> represents a relationship to an element that is already under ownership elsewhere in the object hierarchy. It acts as a reference that enables access to these elements without directly owning them, maintaining a clear structure of ownership and dependencies.</p> <p>In Python, an <code>Association</code> is a specialized wrapper around <code>weakref.proxy</code>, which allows the referred objects to be accessible as long as they exist, without affecting their lifetime by creating strong reference counts that would prevent garbage collection.</p> <p>For example, in the <code>Family</code> tree structure mentioned earlier, if the <code>Grandson</code> needs to be associated with both <code>Daughter</code> and <code>SonInLaw</code>, rather than duplicating the <code>Grandson</code> object or directly sharing ownership, an <code>Association</code> can be created from <code>SonInLaw</code> to the pre-existing <code>Grandson</code> element. This setup symbolizes the relationship without taking full ownership, thus keeping the <code>Grandson</code> within the sole ownership tree of <code>Daughter</code> but still accessible from <code>SonInLaw</code> through this lightweight relationship.</p> <p>By utilizing an <code>Association</code>, you ensure the system's relational integrity without being entangled in complex webs of ownership that might lead to memory leaks or logical inconsistencies.</p> <p>Association Example</p> CodeOutput <pre><code># ... same as above\n        class SonInLaw(Person, first_name=\"John\", age=26, kids=Daughter.Grandson):\n            pass\n\n\nsf.dump(Family)\n</code></pre> <pre><code>0 -&gt; Family type[FamilyTree] @ 0x106f0ab10\n 1 -&gt; Family.Dad type[Person] @ 0x106f08290\n 1 -&gt; Family.Mom type[Person] @ 0x106f0a450\n  2 -&gt; Family.Mom.Son type[Person] @ 0x106f08950\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x106f096d0\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x106f09010\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x106f09d90\n   3 -&gt; Family.Mom.SonInLaw.kids type[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x106f09010\n</code></pre> <p>Inspecting the output reveals that <code>SonInLaw.kids</code> has been established as an <code>Association</code> pointing to <code>Daughter.Grandson</code>. It is noteworthy that this association references the grandson using the very same memory location, underscoring that it does not constitute a separate instance but a different access path to the same object.</p> <p>Now, let's proceed to create another instance of the family tree to observe the effects of these relationships in practice.</p> <p>Element With Associations</p> CodeOutput <pre><code>my_family = Family()\nsf.dump(my_family)\n</code></pre> <pre><code>Family.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x1010d245\n 1 -&gt; Family.Dad object[Person] @ 0x1010d899\n 1 -&gt; Family.Mom object[Person] @ 0x1010d8b9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x1010d8d1\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x1010d8e1\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x1010d8f9\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x1010d905\n   3 -&gt; Family.Mom.SonInLaw.kids object[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x1010d8f9\n</code></pre> <p>Upon observation, we can discern that the <code>Association</code> has maintained its link to the same <code>Grandson</code> instance, as indicated by the identical memory address.</p> <p>Additionally, the output highlights that the <code>Grandson</code> element is initialized only once, even though it's included in the family tree twice\u2014once directly within <code>Daughter</code> and once as an associated reference in <code>SonInLaw</code>. It demonstrates the efficiency of <code>Associations</code> in managing relationships without redundant initializations, thus providing a single source of truth for shared objects within complex structures.</p>"},{"location":"modeling/Overview/#stateforward.model--collection-overview","title":"Collection Overview","text":"<p>A <code>Collection</code> is a fixed container designed to hold elements, which can be either directly owned entities or associations to other elements. Elements within a <code>Collection</code> are automatically mapped or instantiated at the time the <code>Collection</code> itself is instantiated, making the container's content predictable and consistent.</p>"},{"location":"modeling/Overview/#stateforward.model--usage-example","title":"Usage Example","text":"<p>The following modification to the family tree example introduces a <code>GrandDaughter</code> under the <code>Mom.Daughter</code> class. Additionally, the <code>SonInLaw</code> class now includes a <code>Collection</code> named <code>kids</code> to hold both the <code>Grandson</code> and the <code>Granddaughter</code>. <pre><code># ... same as the original\n        class Daughter(Person, first_name=\"Jill\", age=26):\n            class Grandson(Person, first_name=\"Jimmy\", age=1):\n                pass\n\n            class Granddaughter(Person, first_name=\"Jenny\", age=3):\n                pass\n\n        class SonInLaw(\n            Person,\n            first_name=\"John\",\n            age=26,\n            kids=sf.collection(Daughter.Grandson, Daughter.Granddaughter),\n        ):\n            pass\n\n\nsf.dump(Family)\n</code></pre> In this scenario, the <code>SonInLaw</code> class reflects that <code>John</code> has two children: <code>Grandson</code> and <code>Granddaughter</code>. These children are grouped together using the <code>sf.collection()</code> method, signifying that <code>John</code>'s <code>kids</code> attribute is an immutable set of his children. When the <code>Family</code> instance is created, this <code>Collection</code> ensures that the <code>Grandson</code> and <code>Granddaughter</code> are both tied into the family structure within the context of the <code>SonInLaw</code> class.</p>"},{"location":"modeling/Overview/#stateforward.model--output","title":"Output","text":"<p><pre><code>0 -&gt; Family type[FamilyTree] @ 0x120eb8a40\n 1 -&gt; Family.Dad type[Person] @ 0x120eb5440\n 1 -&gt; Family.Mom type[Person] @ 0x120eb8380\n  2 -&gt; Family.Mom.Son type[Person] @ 0x120eb5b00\n  2 -&gt; Family.Mom.Daughter type[Person] @ 0x120eb6f40\n   3 -&gt; Family.Mom.Daughter.Grandson type[Person] @ 0x120eb61c0\n   3 -&gt; Family.Mom.Daughter.Granddaughter type[Person] @ 0x120eb6880\n  2 -&gt; Family.Mom.SonInLaw type[Person] @ 0x120eb7cc0\n   3 -&gt; Family.Mom.SonInLaw.kids type[Collection] @ 0x120eb7600\n    4 -&gt; Family.Mom.SonInLaw.kids.0 type[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x120eb61c0\n    4 -&gt; Family.Mom.SonInLaw.kids.1 type[Association&lt;Family.Mom.Daughter.Granddaughter&gt;] @ 0x120eb6880\n</code></pre> You can discern from this output that the <code>kids</code> attribute of the <code>SonInLaw</code> instance is now a <code>Collection</code>. Within this <code>Collection</code>, there are <code>Associations</code> to the <code>Grandson</code> and <code>Granddaughter</code>. Crucially, these associations preserve the original memory addresses of the grandchildren, as they should, confirming the <code>Collection</code> utilizes direct associations to existing instances rather than creating duplicate objects.</p> <p>The output enumerates and maintains the hierarchical integrity and precise order of elements, as exhibited by the four-level deep printout where <code>SonInLaw.kids</code> consists of indexes (<code>.0</code> and <code>.1</code>) signifying individual positions within the <code>Collection</code>. This ensures each child's relational context within the family is clear and traceable.</p>"},{"location":"modeling/Overview/#stateforward.model--example","title":"Example","text":"<p>instantiating the family again. <pre><code>my_family = Family()\nsf.dump(my_family)\nprint(my_family.Mom.SonInLaw.kids[0])\n</code></pre> <pre><code>#### Output\n```bash\nFamily.__new__\nFamily.Dad.__new__\nFamily.Mom.__new__\nFamily.Mom.Son.__new__\nFamily.Mom.Daughter.__new__\nFamily.Mom.Daughter.Grandson.__new__\nFamily.Mom.Daughter.Granddaughter.__new__\nFamily.Mom.SonInLaw.__new__\nFamily.Mom.__init__\nFamily.Mom.SonInLaw.__init__\nFamily.Mom.Daughter.__init__\nFamily.Mom.Daughter.Granddaughter.__init__\nFamily.Mom.Daughter.Grandson.__init__\nFamily.Mom.Son.__init__\nFamily.Dad.__init__\nFamily.__init__\n0 -&gt; Family object[FamilyTree] @ 0x102eaf7d\n 1 -&gt; Family.Dad object[Person] @ 0x103f14e9\n 1 -&gt; Family.Mom object[Person] @ 0x103f14f9\n  2 -&gt; Family.Mom.Son object[Person] @ 0x103f1511\n  2 -&gt; Family.Mom.Daughter object[Person] @ 0x103f1521\n   3 -&gt; Family.Mom.Daughter.Grandson object[Person] @ 0x103f153d\n   3 -&gt; Family.Mom.Daughter.Granddaughter object[Person] @ 0x103f154d\n  2 -&gt; Family.Mom.SonInLaw object[Person] @ 0x103f1559\n   3 -&gt; Family.Mom.SonInLaw.kids object[Collection] @ 0x103f155d\n    4 -&gt; Family.Mom.SonInLaw.kids.0 object[Association&lt;Family.Mom.Daughter.Grandson&gt;] @ 0x103f153d\n    4 -&gt; Family.Mom.SonInLaw.kids.1 object[Association&lt;Family.Mom.Daughter.Granddaughter&gt;] @ 0x103f154d\n&lt;__main__.Family.Mom.Daughter.Grandson object at 0x103f153d&gt;\n</code></pre></p> <p>Just as anticipated from our previous discussion, the <code>Collection</code> within <code>SonInLaw.kids</code> endures as a reference to the <code>Grandson</code> and <code>Granddaughter</code>. It's worth observing that these associations are now presented as <code>objects</code> instead of <code>types</code>, reflecting the instantiated state of the elements. In this context, \"instantiated state\" suggests that instead of merely referring to the class blueprints (types), we're now handling actual, constructed instances of these elements, as represented by their memory addresses.</p> <p>Moreover, the <code>Grandson</code> and <code>Granddaughter</code> are both initialized just once, despite being referenced mutiple times within the family tree, affirming the intelligent management of object creation and relationships through <code>Associations</code> and <code>Collections</code> in this family tree representation.</p>"},{"location":"modeling/Overview/#stateforward.model--model","title":"Model","text":"<p>The <code>Model</code> class is an enhancement of the <code>Element</code> that includes additional features for preprocessing, validation, and interpretation, providing a structured way to represent complex entities within a system. Each <code>Element</code> nested within a <code>Model</code> is provided with a <code>model</code> attribute, granting a reference to the root <code>Model</code> instance, which allows elements to be aware of their context within the larger entity.</p>"},{"location":"modeling/Overview/#stateforward.model--example_1","title":"Example","text":"<pre><code>import stateforward as sf\n\nclass Automobile(sf.Model):\n    manufacturer: str = None\n    wheels: sf.Collection[\"Wheel\"]\n    engine: \"Engine\"\n\nclass Wheel(sf.Element):\n    size: int\n\nclass Engine(sf.Element):\n    power: int\n\nclass Car(\n    Automobile,\n    manufacturer=\"Saturn\",\n):\n    class V8(Engine, power=300):\n        pass\n\n    class FrontLeft(Wheel, size=16):\n        pass\n\n    class FrontRight(Wheel, size=16):\n        pass\n\n    class RearLeft(Wheel, size=16):\n        pass\n\n    class RearRight(Wheel, size=16):\n        pass\n\nsf.dump(Car)\nprint(Car.V8.model)\n</code></pre>"},{"location":"modeling/Overview/#stateforward.model--output_1","title":"Output","text":"<p><pre><code>0 -&gt; Car type[Automobile] @ 0x11861f820\n 1 -&gt; Car.V8 type[Engine] @ 0x11861d660\n 1 -&gt; Car.FrontLeft type[Wheel] @ 0x11861dd20\n 1 -&gt; Car.FrontRight type[Wheel] @ 0x11861e3e0\n 1 -&gt; Car.RearLeft type[Wheel] @ 0x11861eaa0\n 1 -&gt; Car.RearRight type[Wheel] @ 0x11861f160\n&lt;class '__main__.Car'&gt;\n</code></pre> The output shows the structure of the <code>Car</code> as a <code>Model</code>, which is a concrete representation of an <code>Automobile</code>. The nested classes like <code>V8</code> and the individual wheels are displayed as <code>Element</code> types that are part of the <code>Car</code> model. It also exhibits that the <code>V8</code> class within <code>Car</code> understands it is part of the <code>Car</code> model via the <code>model</code> attribute.</p> <p>The <code>Automobile</code> model specifies that <code>manufacturer</code>, <code>wheels</code>, and an <code>engine</code> are essential components. In the context of the example, it means that a valid <code>Car</code> must have these attributes defined. However, it's important to note that the presence and correctness of these parts are not automatically checked by the <code>Model</code> or <code>Element</code> classes \u2014 a dedicated <code>Validator</code> would be required to ensure that the <code>Car</code> model adheres to the defined rules and structure of an <code>Automobile</code>.</p>"},{"location":"modeling/Overview/#stateforward.model--model-validator","title":"Model Validator","text":"<p>The <code>Model</code> class facilitates the use of a validator which is executed once the <code>Model</code> is fully constructed. The validation occurs only once at runtime, after the entire model is built, ensuring that the instance complies with the predefined rules and requirements.</p>"},{"location":"modeling/Overview/#stateforward.model--example-with-validator","title":"Example with Validator","text":"<p>Below is an excerpt showing the incorporation of an <code>AutomobileValidator</code> for an <code>Automobile</code> <code>Model</code>. The validator checks for the presence of essential components like <code>engine</code> and <code>wheels</code>.</p> <pre><code># ... the rest of the example above\n\nclass AutomobileValidator(sf.Validator):\n    def validate_automobile(self, automobile: type[\"Automobile\"]):\n        if automobile.engine is None:\n            raise ValueError(f\"Automobile {automobile.name} must have an engine\")\n        elif automobile.wheels is None:\n            raise ValueError(f\"Automobile {automobile.name} must have wheels\")\n\nclass Automobile(sf.Model, validator=AutomobileValidator()):\n# ... the rest of the example\n</code></pre>"},{"location":"modeling/Overview/#stateforward.model--example-with-validator-output","title":"Example With Validator Output","text":"<pre><code>Traceback (most recent call last):\n  File \"car_model_example.py\", line 26, in &lt;module&gt;\n    class Car(\n  File \"model.py\", line 33, in __init_subclass__\n    cls.validator.validate(cls)\n  File \"validator.py\", line 35, in validate\n    self.validate_element(element)\n  File \"validator.py\", line 26, in validate_element\n    method(element.type)\n  File \"car_model_example.py\", line 7, in validate_automobile\n    raise ValueError(f\"Automobile {automobile.name} must have an engine\")\nValueError: Automobile Car must have an engine\n</code></pre> <p>In this case, the validator indicates that the <code>Car</code> class or its derivatives must include both an <code>engine</code> and <code>wheels</code> to be considered valid. However, explicitly specifying these components for every car class can be cumbersome.</p> <p>To address this, we can introduce preprocessors to the <code>Model</code>. Preprocessors can simplify the code by automatically inferring or setting default values for properties like <code>engine</code> and <code>wheels</code>, reducing verbosity and making the model definitions more efficient and less error-prone.</p>"},{"location":"modeling/Overview/#stateforward.model--model-preprocessor","title":"Model Preprocessor","text":"<p>Preprocessors are executed as part of the <code>Model</code> construction process, taking place after the entire <code>Model</code> has been built but ahead of the validation phase. They are useful for setting up or modifying <code>Model</code> attributes based on a specific logic before the model is validated for correctness.</p>"},{"location":"modeling/Overview/#stateforward.model--example-utilizing-preprocessor","title":"Example Utilizing Preprocessor","text":"<p>This extension of the earlier example incorporates a <code>Preprocessor</code> for the <code>Automobile</code> <code>Model</code>, which dynamically assigns the <code>wheels</code> and <code>engine</code> attributes by inspecting the elements present in the model.</p> <pre><code># ... continuation from the Automobile validation example\n\n# Define a Preprocessor class specific to the Automobile model\nclass AutomobilePreprocessor(sf.Preprocessor):\n    def preprocess_automobile(self, element: type[\"Automobile\"]):\n        sf.set_attribute(\n            element,\n            \"wheels\",\n            sf.collection(\n                *sf.find_owned_elements(\n                    element, lambda _element: sf.is_subtype(_element, Wheel)\n                )\n            ),\n        )\n        sf.set_attribute(\n            element,\n            \"engine\",\n            sf.find_owned_element(\n                element, lambda _element: sf.is_subtype(_element, Engine)\n            ),\n        )\n\n# Update the Automobile Model to leverage the Preprocessor and Validator\nclass Automobile(\n    sf.Model, validator=AutomobileValidator(), preprocessor=AutomobilePreprocessor()\n):\n# ... the remaining code for the Automobile model etc.\n</code></pre>"},{"location":"modeling/Overview/#stateforward.model--output_2","title":"Output","text":"<p><pre><code>0 -&gt; Car type[Automobile] @ 0x11d616af0\n 1 -&gt; Car.V8 type[Engine] @ 0x11d614930\n 1 -&gt; Car.FrontLeft type[Wheel] @ 0x11d614ff0\n 1 -&gt; Car.FrontRight type[Wheel] @ 0x11d6156b0\n 1 -&gt; Car.RearLeft type[Wheel] @ 0x11d615d70\n 1 -&gt; Car.RearRight type[Wheel] @ 0x11d616430\n 1 -&gt; Car.wheels type[Collection] @ 0x11d6171b0\n  2 -&gt; Car.wheels.0 type[Association&lt;Car.FrontLeft&gt;] @ 0x11d614ff0\n  2 -&gt; Car.wheels.1 type[Association&lt;Car.FrontRight&gt;] @ 0x11d6156b0\n  2 -&gt; Car.wheels.2 type[Association&lt;Car.RearLeft&gt;] @ 0x11d615d70\n  2 -&gt; Car.wheels.3 type[Association&lt;Car.RearRight&gt;] @ 0x11d616430\n 1 -&gt; Car.engine type[Association&lt;Car.V8&gt;] @ 0x11d614930\n</code></pre> With the preprocessor's functionality, we've streamlined the <code>Model</code> definition process, making it less verbose and more maintainable without the need to explicitly declare <code>wheels</code> and <code>engine</code> for every <code>Automobile</code> subclass. This approach allows for easier extension and customization of the model by simply including the relevant subclass elements.</p>"},{"location":"modeling/Overview/#stateforward.model--validator-mechanism","title":"Validator Mechanism","text":"<p>The <code>Validator</code> in the context of the <code>Model</code> functions analogously to the <code>NodeVisitor</code> found in Python\u2019s abstract syntax tree (<code>ast</code>) module. It follows a set path to discover the appropriate validation method for a given element within the structure.</p> <p>Here\u2019s an outline of the search logic:</p> <ol> <li>Element names are normalized to lowercase and converted to snake_case.</li> <li>The search attempts to find a method called <code>validate_{element.name}</code>.</li> <li>If not found, it looks for <code>validate_{element.type.name}</code>, continuing the search up the inheritance chain until <code>validate_element</code> is found or a matching method is identified.</li> <li>This search stops as soon as a validation method is discovered, and that method is executed.</li> </ol> <p>Further, if the <code>Element</code> derives from another <code>Element</code>, the base class validation methods must be explicitly called within the identified validation method; they are not called automatically.</p>"},{"location":"modeling/Overview/#stateforward.model--example-usage","title":"Example Usage","text":"<p>In the example provided, different color elements are created along with a corresponding <code>Validator</code> class that contains specific validation methods.</p> <pre><code>import stateforward as sf\n\n# Define a Validator to handle ColorWheel and its elements\nclass ColorWheelValidator(sf.Validator):\n    # Validates a ColorWheel instance\n    def validate_color_wheel(self, element: type[\"ColorWheel\"]):\n        print(f\"validate_color_wheel({element.name})\")\n        # Invokes validation for each owned element within ColorWheel\n        self.validate_owned_elements(element)\n\n    # Validates an instance of Red, inheriting from Theme.Red\n    def validate_red(self, element: type[\"Theme.Red\"]):\n        print(\"validate_red(Red)\")\n        # Calls validation for the Color base class with an indent\n        self.validate_color(element, 2)\n\n    # Validates an instance of Green\n    def validate_green(self, element: type[\"Theme.Green\"]):\n        print(\"validate_green(Green)\")\n\n    # Validates any Color instance with an optional indent\n    def validate_color(self, element: type[\"Color\"], indent=0):\n        print(f\"{' ' * indent}validate_color({element.name})\")\n\n# Define a generic Color Element\nclass Color(sf.Element):\n    pass\n\n# Define a ColorWheel Model, which incorporates the Validator\nclass ColorWheel(sf.Model, validator=ColorWheelValidator()):\n    pass\n\n# Define a Theme Model that inherits from ColorWheel and includes color elements\nclass Theme(ColorWheel):\n    class Red(Color):\n        pass\n\n    class Green(Color):\n        pass\n\n    class Blue(Color):\n        pass\n\n# The output will demonstrate the Validator searching for and executing\n# validation rules for the Theme Model's color elements\n</code></pre>"},{"location":"modeling/Overview/#stateforward.model--output-explanation","title":"Output Explanation","text":"<p>The console output should indicate that the Validator successfully navigates through the elements, invoking the corresponding validation methods:</p> <pre><code>validate_color_wheel(Theme)\nvalidate_red(Red)\n  validate_color(Red)\nvalidate_green(Green)\nvalidate_color(Blue)\n</code></pre> <p>In the bullet points, it is explained how each color's validation method is resolved, showcasing the Validator's logic:</p> <ol> <li>The <code>Blue</code> color is validated using <code>validate_color</code> directly, as there is no explicit <code>validate_blue</code> method available.</li> <li><code>validate_color</code> is not called for the <code>Green</code> color because <code>validate_green</code> is already present and does not call <code>validate_color</code>.</li> <li><code>validate_color</code> is invoked for the <code>Red</code> color due to an explicit call within <code>validate_red</code>.</li> <li><code>validate_owned_elements</code> is used in the <code>ColorWheel</code> validator, ensuring that all owned elements (<code>Red</code>, <code>Green</code>, and <code>Blue</code>) get validated. This step is vital because element validation would not occur without it.</li> </ol> <p>By defining and structuring the Validator and validation methods correctly, developers can enforce specific validation rules tailored to their <code>Model</code> structure and ensure that all elements comply with the defined criteria.</p> <p>(back to top)</p>"},{"location":"modeling/Overview/#stateforward.model--preprocessor-overview","title":"Preprocessor Overview","text":"<p>The preprocessor in the <code>stateforward</code> library operates identically to the <code>Validator</code>, with the key difference being the timing of its invocation. It is called before the validation phase, which allows it to modify or augment the <code>Model</code> structure prior to any checks for correctness. The primary role of the <code>Preprocessor</code> is to streamline the model construction process, adding convenience and reducing code verbosity, thus enhancing the clarity and maintainability of the model definitions.</p> <p>The <code>Preprocessor</code> follows a search pattern similar to the <code>Validator</code> to determine the appropriate processing method for a given element:</p> <ol> <li>Element names are converted to lowercase and snake_case for standardization.</li> <li>It seeks a method with the signature <code>preprocess_{element.name}</code>.</li> <li>Failing that, it looks for <code>preprocess_{element.type.name}</code>, proceeding recursively up the inheritance hierarchy until either <code>preprocess_element</code> is found or a suitable method is located.</li> <li>Once a preprocessing method is identified, the search concludes and that method is executed.</li> </ol> <p>Should an <code>Element</code> inherit from another <code>Element</code>, base preprocessing functions are not automatically invoked. They must be explicitly called within the identified preprocessing method.</p> <p>While the preprocessor can perform a wide range of tasks, common uses include auto-filling attributes with default values, organizing collections of elements, and setting up links or associations between parts of the model. This enables developers to define elegant and concise models that automatically adjust to include necessary attributes or sub-elements, thus freeing them from repetitive boilerplate code.</p> <p>The <code>Preprocessor</code> is a powerful tool within the <code>stateforward</code> library that aids in simplifying complex model preparation while ensuring a solid foundation for subsequent validation steps.</p>"},{"location":"modeling/Overview/#stateforward.model--interpreter","title":"Interpreter","text":"<p>The <code>Interpreter</code> is an abstract class responsible for executing a <code>Model</code>.</p>"}]}